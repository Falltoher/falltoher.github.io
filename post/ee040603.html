<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>图 | 个人博客</title><meta name="author" content="falltoher"><meta name="copyright" content="falltoher"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本概念和术语图：G&#x3D;(V,E)  V:顶点（数据元素）的有穷非空集合    E:边的有穷集合 无向图：每条边都是无方向的 有向图：每条边都是有方向的 完全图：任意两个点都有一条边相连 稀疏图：如果边或弧的个数满足e &lt; n log2n 稠密图： 路径：接续的边构成的顶点序列 路径长度：路径上边或弧的数目&#x2F;权值之和 回路(环)：第一个顶点和最后一个顶点相同的路径 简单路径：除路径起点和终点可">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="https://falltoher.github.io/post/ee040603.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="基本概念和术语图：G&#x3D;(V,E)  V:顶点（数据元素）的有穷非空集合    E:边的有穷集合 无向图：每条边都是无方向的 有向图：每条边都是有方向的 完全图：任意两个点都有一条边相连 稀疏图：如果边或弧的个数满足e &lt; n log2n 稠密图： 路径：接续的边构成的顶点序列 路径长度：路径上边或弧的数目&#x2F;权值之和 回路(环)：第一个顶点和最后一个顶点相同的路径 简单路径：除路径起点和终点可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-14T11:51:51.000Z">
<meta property="article:modified_time" content="2023-04-16T02:54:11.921Z">
<meta property="article:author" content="falltoher">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://falltoher.github.io/post/ee040603.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-16 10:54:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tools/"><i class="fa-fw fas fa-tools"></i><span> 工具</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumi/"><i class="fa-fw fas fa-tv"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="个人博客"><span class="site-name">个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tools/"><i class="fa-fw fas fa-tools"></i><span> 工具</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumi/"><i class="fa-fw fas fa-tv"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-14T11:51:51.000Z" title="Created 2023-04-14 19:51:51">2023-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-16T02:54:11.921Z" title="Updated 2023-04-16 10:54:11">2023-04-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">19.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>83min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h1><p>图：G=(V,E)  V:顶点（数据元素）的有穷非空集合    E:边的有穷集合</p>
<p>无向图：每条边都是无方向的</p>
<p>有向图：每条边都是有方向的</p>
<p>完全图：任意两个点都有一条边相连</p>
<p>稀疏图：如果边或弧的个数满足e &lt; n log2n</p>
<p>稠密图：</p>
<p>路径：接续的边构成的顶点序列</p>
<p>路径长度：路径上边或弧的数目/权值之和</p>
<p>回路(环)：第一个顶点和最后一个顶点相同的路径</p>
<p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径</p>
<p>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径</p>
<p>连通图(强连通图)：在无(有)向图G=(V,{E})中，若任何两个顶点v，u都存在从v到u的路径，则称G是连通图(强连通图)</p>
<p>权与网：图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网</p>
<p>子图：若有两个图G=(V,E),G1=(V1,E2)，若V1是V的子集且E2是E的子集，称G1是G的子图</p>
<h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT&#123;</span><br><span class="line">    数据对象V:;</span><br><span class="line">    数据关系R:R=&#123;VR&#125;</span><br><span class="line">    基本操作P:</span><br><span class="line">    CreatGraph(&amp;G,V,VR)</span><br><span class="line">        初始条件：V是图的顶点集，VR是图中弧的集合</span><br><span class="line">        操作结果：按V和VR的定义构造图G</span><br><span class="line">    BFSTraverse(G)</span><br><span class="line">        初始条件：图G存在</span><br><span class="line">        操作结果：对图进行深度优先遍历</span><br><span class="line">    DFSTraverse(G)</span><br><span class="line">        初始条件：图G存在</span><br><span class="line">        操作结果：对图进行广度优先遍历</span><br><span class="line">&#125;ADT Graph</span><br></pre></td></tr></table></figure>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>图的逻辑结构：多对多</p>
<p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即<strong>图没有顺序存储结构</strong>，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，由于图的任意两个顶点间都可能存在关系，因此，可以用链式存储表示图。图的链式存储有多种，有邻接表、十字链表和邻接多重表</p>
<ol>
<li><p><strong>邻接矩阵</strong></p>
<p><strong>邻接矩阵（数组）表示法</strong></p>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。设G（V，E）是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵。</p>
<p><img src="https://img-blog.csdnimg.cn/97522e6906ef4913bb0b4fcdbdcf36b9.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/079231c04e2641b78e9b8db50d9e07f4.png#pic_center" alt></p>
<p>在有向图的邻接矩阵中，</p>
<ul>
<li>第i行含义︰以结点v;为起点的边(即出度边);</li>
<li>第i列含义:以结点v;为终点的边(即入度边)。</li>
</ul>
<p>有向图的邻接矩阵可能是不对称的。</p>
<ul>
<li>顶点的出度=第i行元素之和</li>
<li>顶点的入度=第i列元素之和</li>
<li>顶点的度=第i行元素之和+第i列元素之和</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c12873e1d7794b12802953ca6dea50c1.png#pic_center" alt></p>
<p>无向图的邻接矩阵是对称的;</p>
<ul>
<li>顶点i的度=第i 行（列)中1的个数;</li>
<li>图的边数=所有非0元素之和的一半;</li>
<li>完全图的邻接矩阵中，对角元素为0，其余1。</li>
</ul>
<p>若G是网，则邻接矩阵可以定义为：</p>
<p><img src="https://img-blog.csdnimg.cn/4f0bd60aab4d459a918215b44eef9e45.png#pic_center" alt></p>
<p>其中，wi,j表示边上的权值;∞表示计算机允许的、大于所有边上权值的数。</p>
<p><img src="https://img-blog.csdnimg.cn/6fd74f7f3ea24ebbacb2d89879db1178.png#pic_center" alt></p>
</li>
</ol>
<p>邻接矩阵表示法的特点:</p>
<ul>
<li>优点:容易实现图的操作。<br>如:求某顶点的度、判断顶点之间是否有边、找顶点的邻接点…</li>
<li><p>缺点:n个顶点需要n*n个单元存储边;空间效率为O(n2)。<br>对稀疏图而言尤其浪费空间。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图的邻接矩阵存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767     <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100        <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType; <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;     <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125; AMGraph;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>采用邻接矩阵表示法创建无向网：</p>
<pre><code>  1. 输入总顶点数和总边数。
  2. 依次输入点的信息存入顶点表中。
  3. 初始化邻接矩阵，使每个权值初始化为极大值。
  4. 构造邻接矩阵。依次输人每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。
</code></pre>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i];          <span class="comment">//依次输入点的信息</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = MaxInt;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)&#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);        <span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;            <span class="comment">//边&lt;v1, v2&gt;的权值置为w</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j]; <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;                                <span class="comment">// for</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// CreateUDN</span></span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度是O(n^2)。</p>
<p>若要建立无向图，只需对上述算法做两处小的改动:一是<strong>初始化邻接矩阵时，将边的权值均初始化为0</strong>;二是<strong>构造邻接矩阵时，将权值w改为常量值1</strong>即可。同样，将该算法稍做修改即可建立一个有向网或有向图</p>
<ol>
<li><p><strong>邻接表</strong></p>
<p>邻接表(Adjacency List）是图的一种链式存储结构。在邻接表中，对图中每个顶点v;建立一个单链表，把与v相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成:表头结点表和边表</p>
<p><img src="https://img-blog.csdnimg.cn/d1027b1a3cad48f6b2ec2bdfa3704b19.png#pic_center" alt></p>
<ul>
<li><p>无向图</p>
<p>无向图的边结点表示与顶点结点有边相连的关系</p>
<p><img src="https://img-blog.csdnimg.cn/534bbdd59a674d96a0049d0659f6bba5.png#pic_center" alt></p>
</li>
<li><p>有向图</p>
<p>有向图的边结点表示顶点结点为起点，有以边结点为终点的关系</p>
<p><img src="https://img-blog.csdnimg.cn/8deb9cf11caf4b97b816347b2017ecb5.png#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图的邻接表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;              <span class="comment">// 该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span> <span class="comment">// 指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;          <span class="comment">// 和边相关的信息</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;     <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *firstarc;   <span class="comment">// 指向第一条依附该顶点的边</span></span><br><span class="line">&#125; VNode, AdjList[MVNum]; <span class="comment">// AdjList表示邻接表类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;   <span class="comment">// vertices—vertex的复数</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure>
<p>特点<br>1.图的邻接表表示不为1（链表前后元素可以调换）。</p>
<p>2.对于无向图，顶点的度是链表的长度-1。</p>
</li>
</ul>
<p>3.对于有向图，顶点的出度是链表的长度-1。入度需要遍历整个邻接表。</p>
<p>4.存储空间主要与顶点数n和边数e有关，无向图空间复杂度为O（n+2e），有向图为O（n+e）。</p>
<p>5.当边数小于n（n-1）/2即有向图最多边数的一半时，就可以用三元组压缩存储</p>
<p><strong>采用邻接表表示法创建无向图</strong></p>
<ol>
<li>输人总顶点数和总边数。</li>
<li>依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li>
<li><p>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123;<span class="comment">//采用邻接表表示法，创建无向图G</span></span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入顶点数和弧数</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">          G.vertices[i].firstarc = <span class="literal">NULL</span>; <span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)&#123; <span class="comment">//输入各边，构造邻接表，头插法</span></span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2; <span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">          i = LocateVex(G, v1);</span><br><span class="line">          j = LocateVex(G, v2);</span><br><span class="line">          p1 = new ArcNode; <span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">          p1-&gt;adjvex = j;   <span class="comment">//邻接点序号为j</span></span><br><span class="line">          p1-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">          G.vertices[i].firstarc = p1;<span class="comment">//将新结点*p1插入到顶点vi的边表头部</span></span><br><span class="line">          p2 = new ArcNode;<span class="comment">//生成一个新的边结点*p2</span></span><br><span class="line">          p2-&gt;adjvex = i;<span class="comment">//邻接点序号为j</span></span><br><span class="line">          p2-&gt;nextarc = G.vertices[j].firstarc; <span class="comment">//插入弧结点到单链表</span></span><br><span class="line">          G.vertices[j].firstarc = p2;<span class="comment">//将新结点*p2插入到顶点vj的边表头部</span></span><br><span class="line">      &#125;<span class="comment">//头插法</span></span><br><span class="line">      <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其时间复杂度为O(n+e)</p>
<p>建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号<i,j>，仅需生成一个邻接点序号为j的边表结点，并将其插入到v的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</i,j></p>
<p><strong>邻接矩阵与邻接表的比较</strong>:</p>
<p><img src alt></p>
<blockquote>
<p>例题1 <img src="https://img-blog.csdnimg.cn/9d43c13493ec41bab804a3904bc51f75.png#pic_center" alt></p>
<p>例题2 <img src="https://img-blog.csdnimg.cn/5295de9604764fcf9c07dbf032b016f2.png#pic_center" alt></p>
</blockquote>
</li>
<li><p><strong>十字链表</strong></p>
<p>十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。</p>
<p>|  名称   |               解释               |<br>   | :——-: | :———————————————: |<br>| tailvex |    指示弧尾顶点在图中的位置。    |<br>| headtex |    指示弧头顶点在图中的位置。    |<br>|  hlink  | 是指向弧头相同的下一条弧的指针。 |<br>|  tlink  | 是指向弧尾相同的下一条弧的指针。 |<br>|  Info   |       指向该弧的相关信息。       |</p>
<p><img src="https://img-blog.csdnimg.cn/3f6e27895ee541ffb35fb0ff9e26a537.png#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有向图的十字链表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> tailvex, headvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>, *<span class="title">tlink</span>;</span></span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125; ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span> <span class="comment">// ArcBox为弧结点变量</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcBox *firstin, *firstout;</span><br><span class="line">&#125; VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">// VexNode为顶点变量</span></span><br><span class="line">    VexNode xlist[MAX_VERTEX_NUM]; <span class="comment">// 表头向</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;            <span class="comment">// 有向图的当前顶点数和弧数</span></span><br><span class="line">&#125; OLGraph;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例 <img src="https://img-blog.csdnimg.cn/a6aea7ac55ed4f42bfcdb5bb37200f2a.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/a920d93055314208999e55367e9ff6e7.png#pic_center" alt></p>
</blockquote>
<p>邻接表、逆邻接表、十字链表<br>对于有向图而言，邻接表是将当前顶点走向其他顶点的路径信息存储在边表当中，既将出度信息存储于边表，所以求出度十分容易，出度就是边表中的链节个数，但是邻接表却难求出度。逆邻接表将入度信息存储于边表，所以容易求入度，但逆邻接表却难求出度。所以在我们如果需要频繁的求出度与入度的时候，就会引用——十字链表。十字链表是将邻接表与逆邻接表合二为一，易求出度也易求入度。总结如下：<br>邻接表：易求出度，不易求入度<br>逆邻接表：易求入度，不易求出度<br>十字链表：合二为一，易求出度也易求入度</p>
</li>
<li><p><strong>邻接多重表</strong></p>
<p>邻接多重表是无向图的另一种链式存储结构，由于用邻接表存储无向图时，虽然容易求出顶点和边的各种信息，但在邻接表中每一条边有两个结点，分别在第i和第j个链表中，给图的某些操作带来不便。在邻接多重表中，每一条边只有一个边结点，为有关边的处理提供了方便。</p>
<p>|    名称    |                  解释                  |<br>   | :————: | :——————————————————: |<br>|    mark    | 为标志域，可用以标记该条边是否被搜索过 |<br>| ivex和jvex |   为该边依附的两个顶点在图中的位置;    |<br>|    ilnk    |     指向下一条依附于顶点ivex的边;      |<br>|   jlink    |      指向下一条依附于顶点jvex的边      |<br>|    info    |   为指向和边相关的各种信息的指针域。   |</p>
<p><img src="https://img-blog.csdnimg.cn/1d52ad2eb0564c46af086ad8ff60083d.png#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图的邻接多重表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    unvisited,</span><br><span class="line">    viseited</span><br><span class="line">&#125; ViseitIF;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VisitIf mark;               <span class="comment">//访问标志域</span></span><br><span class="line">    <span class="type">int</span> ivex, jvex;             <span class="comment">//该边依附的两个顶点在表头数组中位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span> <span class="comment">//分别指向依附于ivex和jvex的下一条边</span></span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125; Ebox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data; <span class="comment">//存与顶点有关的信息</span></span><br><span class="line">    EBox *firstedge; <span class="comment">//指向第一条依附于该顶点的边</span></span><br><span class="line">&#125; VexBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexBox adjmulist[MAX_VERTEX_NUM]; <span class="comment">// 表头向量</span></span><br><span class="line">    <span class="type">int</span> vexnum, edgenum;              <span class="comment">// 无向图的当前顶点数和弧数</span></span><br><span class="line">&#125; AMLGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题：画出无向图G的多重邻接表<img src="https://img-blog.csdnimg.cn/c9411620611f4952a1d84b33c3bc19cf.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/a38fd52e3137451e8ffdd29969663cd1.png#pic_center" alt></p>
</blockquote>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/22495a9e70204f52bbd695cb5c10a458.png#pic_center" alt></p>
<ol>
<li><p>补充：<strong>边集数组法</strong></p>
<p>边集数组是由两个一维数组构成的，一个是存储顶点的信息；另一个存储边的信息，这个数组的元素存储边的起点，终点，权重。</p>
<p>在边集数组中要确定一个顶点的度要扫描整个边集数组，效率很低，不过边集数组可以很容易的帮助我们找到修改边的信息，显然边集数组法更适合需要对边进行处理的情况。</p>
</li>
</ol>
<p>代码汇总</p>
<p><strong>Graph.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 65535</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">//顶点的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">//边上权值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType vexs[MAXSIZE][MAXSIZE];<span class="comment">//顶点数组</span></span><br><span class="line">	EdgeType arr[MAXSIZE][MAXSIZE];<span class="comment">//邻接矩阵 也可以用来存放权值</span></span><br><span class="line">	<span class="type">int</span> numNodes;<span class="comment">//顶点的个数</span></span><br><span class="line">	<span class="type">int</span> numEdges;<span class="comment">//边的个数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createMGraph</span><span class="params">(MGraph* G)</span>;<span class="comment">//无向网的建立</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMGraph</span><span class="params">(MGraph G)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;<span class="comment">//确定这个点的下标</span></span><br><span class="line">	EdgeType w;<span class="comment">//储存头结点到这个结点的邻接边的权值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;EdgeNode;<span class="comment">//每个头结点的邻接链表的节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];<span class="comment">//结点名</span></span><br><span class="line">	EdgeNode* firstedgenode;<span class="comment">//指向第一个邻接点</span></span><br><span class="line">&#125;VertexNode,AdjList[MAXSIZE];</span><br><span class="line"><span class="comment">//定义结点数组的元素，并直接把大小为MAXSIZE的结点数组这种类型定义为AdjList</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList adjlist;<span class="comment">//头节点数组</span></span><br><span class="line">	<span class="type">int</span> numNode;<span class="comment">//结点个数</span></span><br><span class="line">	<span class="type">int</span> numEdge;<span class="comment">//边的个数</span></span><br><span class="line">&#125;GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAdjlistGraph</span><span class="params">(GraphAdjList* G)</span>;<span class="comment">//以邻接表法创无向权图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAdjlistGraph</span><span class="params">(GraphAdjList G)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十字链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLarc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> startvex;<span class="comment">//弧的起点</span></span><br><span class="line">	<span class="type">int</span> endvex;<span class="comment">//弧的终点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OLarc</span>* <span class="title">nextsameSarc</span>;</span><span class="comment">//指向起点相同的下一条弧</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OLarc</span>* <span class="title">nextsameEarc</span>;</span><span class="comment">//指向终点相同的下一条弧</span></span><br><span class="line">	EdgeType w;</span><br><span class="line">&#125;OLarc;<span class="comment">//每个弧节点</span></span><br><span class="line"><span class="comment">//对每个结点，形成两个链表，一个是全部都以这个结点开头的弧的弧形成的链表，用指针nextsameSarc连起来</span></span><br><span class="line"><span class="comment">//另一个是全部都以这个结点为结尾的弧形成的链表，用指针nextsameEarc连起来。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];<span class="comment">//结点名</span></span><br><span class="line">	OLarc* firstin;<span class="comment">//指向第一个入结点弧</span></span><br><span class="line">	OLarc* firstout;<span class="comment">//指向第一个出结点弧</span></span><br><span class="line">&#125;OLNode,OList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	OList olist;</span><br><span class="line">	<span class="type">int</span> numNodes;<span class="comment">//结点数</span></span><br><span class="line">	<span class="type">int</span> numarcs;<span class="comment">//弧数</span></span><br><span class="line">&#125;OLGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createOLGraph</span><span class="params">(OLGraph* G)</span>;<span class="comment">//利用十字链表创建一个有向带权图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printOLGraph</span><span class="params">(OLGraph G)</span>;<span class="comment">//展示该图的弧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接多重表</span></span><br><span class="line"><span class="comment">//仿照十字链表的方式，对边表结点的结构进行一些改造。(不过我后面看来 这个删除操作还是很复杂= =)</span></span><br><span class="line"><span class="comment">//把邻接表中用来放边的另一端的结构体修改成如下结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMEdge</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> start;</span><br><span class="line">	<span class="type">int</span> end;<span class="comment">//用start和end表示一个边</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AMEdge</span>* <span class="title">startlink</span>;</span><span class="comment">//指向下一个依附于这个start顶点的边的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AMEdge</span>* <span class="title">endlink</span>;</span><span class="comment">//指向下一个依附于这个end顶点的边的指针</span></span><br><span class="line">&#125;AMEdge;</span><br><span class="line"><span class="comment">//这样，我们就用一个结点就表示了一个无向图中的边，而不是像邻接表法中那样对一个边用两个结点来表示它。</span></span><br><span class="line"><span class="comment">//然后仿照邻接表法构建其他的结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];<span class="comment">//结点的名字</span></span><br><span class="line">	AMEdge* pEdge;<span class="comment">//指向第一个依附于此结点的边</span></span><br><span class="line">&#125;AMvertex,AMList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AMList Amlist;</span><br><span class="line">	<span class="type">int</span> numvertex;</span><br><span class="line">	<span class="type">int</span> numedge;</span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAMGraph</span><span class="params">(AMGraph* G)</span>;<span class="comment">//创建一个无权有向图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph G)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteEdge</span><span class="params">(AMGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边集数组法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> start;</span><br><span class="line">	<span class="type">int</span> end;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Node vertex[MAXSIZE];</span><br><span class="line">	Edge edge[MAXSIZE];</span><br><span class="line">&#125;ESAGraph;</span><br></pre></td></tr></table></figure>
<p><strong>Graph.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createMGraph</span><span class="params">(MGraph* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数,以a空格b的形式输入:&quot;</span>);</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	G-&gt;numNodes = n;</span><br><span class="line">	G-&gt;numEdges = m;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入%d个顶点\n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;vexs[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">			G-&gt;arr[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j, w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入边(Vi,Vj)的下标(i,j)和权w，以i,j,w的形式输入:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;i, &amp;j, &amp;w);</span><br><span class="line">		G-&gt;arr[i][j] = w;</span><br><span class="line">		G-&gt;arr[j][i] = G-&gt;arr[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMGraph</span><span class="params">(MGraph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个顶点是%s\n&quot;</span>, i + <span class="number">1</span>, G.vexs[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.numNodes; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (G.arr[i][j] != INF)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;边(%s,%s)的权值是%d\n&quot;</span>, G.vexs[i], G.vexs[j], G.arr[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建邻接表</span></span><br><span class="line"><span class="comment">//在邻接表法的基础上，对每个结点，形成两个链表，一个是全部都以这个结点开头的弧的弧形成的链表，用指针nextsameSarc连起来。另一个是全部都以这个结点为结尾的弧形成的链表，用指针nextsameEarc连起来。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAdjlistGraph</span><span class="params">(GraphAdjList* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入图G的结点数和边数,以a空格b的形式输入:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;(G-&gt;numNode), &amp;(G-&gt;numEdge));</span><br><span class="line">    <span class="comment">//输入结点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numNode; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入序号为%d的结点:&quot;</span>, i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;adjlist[i].str);</span><br><span class="line">		G-&gt;adjlist[i].firstedgenode = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//输入边</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numEdge; k++)&#123;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		EdgeNode* e = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入边(vi,vj)上的序号i和j和权值w,以i,j,w的形式输入:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;i, &amp;j,&amp;(e-&gt;w));</span><br><span class="line">		e-&gt;adjvex = j;</span><br><span class="line">		<span class="comment">//头插法把e插入链表中</span></span><br><span class="line">        e-&gt;next = G-&gt;adjlist[i].firstedgenode;</span><br><span class="line">		G-&gt;adjlist[i].firstedgenode = e;</span><br><span class="line">		<span class="comment">//因为是无向图，所以要把e插入到头结点为j的链表汇总</span></span><br><span class="line">        <span class="type">int</span> tmp = e-&gt;w;</span><br><span class="line">		e= (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">		e-&gt;adjvex = i;</span><br><span class="line">		e-&gt;next = G-&gt;adjlist[j].firstedgenode;</span><br><span class="line">		G-&gt;adjlist[j].firstedgenode = e;</span><br><span class="line">		e-&gt;w = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接表法存储的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAdjlistGraph</span><span class="params">(GraphAdjList G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNode; i++)&#123;</span><br><span class="line">		EdgeNode* p = G.adjlist[i].firstedgenode;</span><br><span class="line">        <span class="comment">//遍历每个以数组元素为头结点的链表 以此来输出自己的边。</span></span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;边(%s,%s)的权值为%d\n&quot;</span>, G.adjlist[i].str, G.adjlist[p-&gt;adjvex].str, p-&gt;w);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建十字链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createOLGraph</span><span class="params">(OLGraph* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入图的顶点个数和弧的个数，以a空格b的形式输入：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;(G-&gt;numNodes), &amp;(G-&gt;numarcs));</span><br><span class="line">    <span class="comment">//输入结点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numNodes; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入序号为%d的节点：&quot;</span>,i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;olist[i].str);</span><br><span class="line">		G-&gt;olist[i].firstin = G-&gt;olist[i].firstout = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//对每个弧(vi,vj)，利用头插法把这个弧插入到以数组中下标i对应的元素开头的相同起点链表中</span></span><br><span class="line">    <span class="comment">//利用头插法把这个弧插入到以数组中下标j对应的元素开头的相同终点链表中。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numarcs; k++)&#123;</span><br><span class="line">		OLarc* e = (OLarc*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLarc));</span><br><span class="line">		<span class="type">int</span> i, j, w;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入弧(vi,vj)的顶点序号i和j以及它的权重w，以i,j,w形式输入&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;i, &amp;j, &amp;w);</span><br><span class="line">		e-&gt;startvex = i;</span><br><span class="line">		e-&gt;endvex = j;</span><br><span class="line">		e-&gt;w = w;</span><br><span class="line">		e-&gt;nextsameSarc = G-&gt;olist[i].firstout;</span><br><span class="line">		G-&gt;olist[i].firstout = e;</span><br><span class="line">		e-&gt;nextsameEarc = G-&gt;olist[j].firstin;</span><br><span class="line">		G-&gt;olist[j].firstin = e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印十字链表存储的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printOLGraph</span><span class="params">(OLGraph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++)&#123;</span><br><span class="line">		<span class="type">int</span> ID = <span class="number">0</span>;<span class="comment">//入度</span></span><br><span class="line">		<span class="type">int</span> OD = <span class="number">0</span>;<span class="comment">//出度</span></span><br><span class="line">		OLarc* p1 = G.olist[i].firstin;</span><br><span class="line">		<span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;弧&lt;%s,%s&gt;的权是%d\n&quot;, G.olist[p1-&gt;startvex].str, G.olist[i].str);</span></span><br><span class="line">			p1 = p1-&gt;nextsameEarc;</span><br><span class="line">			ID++;</span><br><span class="line">		&#125;</span><br><span class="line">		OLarc* p2 = G.olist[i].firstout;</span><br><span class="line">		<span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;弧&lt;%s,%s&gt;的权是%d\n&quot;</span>, G.olist[i].str, G.olist[p2-&gt;endvex].str,p2-&gt;w);</span><br><span class="line">			p2 = p2-&gt;nextsameSarc;</span><br><span class="line">			OD++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;结点%s的入度是%d,出度是%d\n&quot;</span>, G.olist[i].str, ID, OD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建邻接多重表</span></span><br><span class="line"><span class="comment">//这里创建的方法仿照十字链表，每输入一个边（Vi，Vj）后，利用头插法把这个边插入到以数组下标i对应的元素为头结点的链表中，并且插入i时把这个边的指向下一个依附于这个i顶点的边的指针指向链表头结点的下一个元素，然后把指向链表头结点的下一个元素的指针指向这个边；然后对以数组下标i对应的元素为头结点的链表进行同样的操作，不过要把startlink指针换成endlink指针。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAMGraph</span><span class="params">(AMGraph* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入该无向图的顶点数和边数，以i空格j格式输入:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;G-&gt;numvertex, &amp;G-&gt;numedge);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numvertex; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入序号为%d的结点的名字\n&quot;</span>, i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;Amlist[i].str);</span><br><span class="line">		G-&gt;Amlist[i].pEdge = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numedge; k++)&#123;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入边(Vi,Vj)的顶点序号i和j,以格式i,j输入:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">		AMEdge* e = (AMEdge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AMEdge));</span><br><span class="line">		e-&gt;start = i;</span><br><span class="line">		e-&gt;end = j;</span><br><span class="line">		e-&gt;startlink = G-&gt;Amlist[i].pEdge;</span><br><span class="line">		G-&gt;Amlist[i].pEdge = e;</span><br><span class="line">		e-&gt;endlink = G-&gt;Amlist[j].pEdge;</span><br><span class="line">		G-&gt;Amlist[j].pEdge = e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接多重表存储的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numvertex; i++)&#123;</span><br><span class="line">		AMEdge* p = G.Amlist[i].pEdge;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;结点%s的邻接边为：&quot;</span>,G.Amlist[i].str);</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%s,%s) &quot;</span>, G.Amlist[p-&gt;start].str, G.Amlist[p-&gt;end].str);</span><br><span class="line">            <span class="comment">//根据p这个边的start端点是i还是end端点是i来判断走startlink还是endlink</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				p = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				p = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除图中的边</span></span><br><span class="line"><span class="comment">//这里需要传G的指针进去，因为当我们把一个点的相邻边都删除完了以后，需要把这个链表中头结点中指向下一个元素的指针的值改成空，我们要修改指针的值，所以要传G的指针进去，相当于传了头结点中指向下一个元素的指针的二级指针。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteEdge</span><span class="params">(AMGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G-&gt;numedge != <span class="number">0</span>)&#123;</span><br><span class="line">		AMEdge* p = G-&gt;Amlist[i].pEdge;</span><br><span class="line">		AMEdge* tmp = <span class="literal">NULL</span>;</span><br><span class="line">		AMEdge* tmp1 = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> ((!(p-&gt;start == i &amp;&amp; p-&gt;end == j)) &amp;&amp; (!(p-&gt;start == j &amp;&amp; p-&gt;end == i)))&#123;</span><br><span class="line">			tmp = p;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				p = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				p = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp1 = p;</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				G-&gt;Amlist[i].pEdge = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				G-&gt;Amlist[i].pEdge = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == i)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == i)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == i)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == i)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = G-&gt;Amlist[j].pEdge;</span><br><span class="line">		tmp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> ((!(p-&gt;start == i &amp;&amp; p-&gt;end == j)) &amp;&amp; (!(p-&gt;start == j &amp;&amp; p-&gt;end == i)))&#123;</span><br><span class="line">			tmp = p;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == j)&#123;</span><br><span class="line">				p = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == j)&#123;</span><br><span class="line">				p = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == j)&#123;</span><br><span class="line">				G-&gt;Amlist[j].pEdge = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == j)&#123;</span><br><span class="line">				G-&gt;Amlist[j].pEdge = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == j)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == j)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == j)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == j)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == j)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == j)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(tmp1);</span><br><span class="line">		G-&gt;numedge--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图中的边已经都删除了\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>test.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">	MGraph G;</span><br><span class="line">	createMGraph(&amp;G);</span><br><span class="line">	printMGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	GraphAdjList G;</span><br><span class="line">	createAdjlistGraph(&amp;G);</span><br><span class="line">	printAdjlistGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">	OLGraph G;</span><br><span class="line">	createOLGraph(&amp;G);</span><br><span class="line">	printOLGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	createAMGraph(&amp;G);</span><br><span class="line">	printAMGraph(G);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的边,以i,j格式输入&quot;</span>);</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">		deleteEdge(&amp;G, i, j);</span><br><span class="line">		printAMGraph(G);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	test1();</span><br><span class="line">	test2();</span><br><span class="line">	test3();</span><br><span class="line">	test4();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>图的遍历：从图中某个顶点V。出发，沿着一些边访问图中所有的顶点，且使每个顶点被访问一次且只访问一次</p>
<ol>
<li><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索( Depth First Search，DFS)遍历类似于树的先序遍历，是树的先序遍历的推广。</p>
<p>对于一个连通图，深度优先搜索遍历的过程如下：</p>
<ol>
<li><p>从图中某个顶点v出发，访问v。</p>
</li>
<li><p>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤,直至刚访问过的顶点没有未被访问的邻接点为止。</p>
</li>
<li><p>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p>
</li>
<li><p>重复步骤（2）和（3)，直至图中所有顶点都被访问过，搜索结束。</p>
<p><img src="https://img-blog.csdnimg.cn/a510d5470cc247dfa2fcf56f4fb3469b.png#pic_center" alt></p>
</li>
</ol>
<p>对无向连通图，如果将一次深度优先搜索时前进操作所经过的边保留下来则可构成一棵深度优先搜索生成树。</p>
<p><img src="https://img-blog.csdnimg.cn/a44a9d7a871b44c09d087e2090402098.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>深度优先搜索遍历的算法实现</strong></p>
<p>深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为“false”，一旦某个顶点被访问，则其相应的分量置为“true”。</p>
<ol>
<li>从图中某个顶点v出发，访问v，并置visited[y]的值为true。</li>
<li>依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历,直到图中所有顶点都被访问过。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索遍历连通图的递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100        <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType; <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;     <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MVNum];                   <span class="comment">//访问标志数组，其初值为&quot;false&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span>;       <span class="comment">//返回v的第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span>; <span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(Graph G, VerTexType v)</span>&#123;</span><br><span class="line">    <span class="comment">//确定点v在G中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// LocateVex</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(Graph &amp;G)</span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入总顶点数，总边数 , 以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如 a：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如：a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)&#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">        VerTexType v1, v2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);            <span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j] = <span class="number">1</span>; <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;                                    <span class="comment">// for</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123; <span class="comment">//从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w))</span><br><span class="line">        <span class="comment">//依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点</span></span><br><span class="line">        <span class="comment">// NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(G, w); <span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = w; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************深度优先搜索遍历连通图的递归算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Graph G;</span><br><span class="line">    CreateUDN(G);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向连通图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">    VerTexType c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == G.vexs[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= G.vexnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点不存在，请重新输入！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == G.vexs[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先搜索遍历连通图结果：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DFS(G, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索遍历非连通图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100        <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType; <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;     <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------图的邻接矩阵-----------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MVNum];                   <span class="comment">//访问标志数组，其初值为&quot;false&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span>;       <span class="comment">//返回v的第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span>; <span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(Graph G, VerTexType v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//确定点v在G中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(Graph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">    &#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">        VerTexType v1, v2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);            <span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j] = <span class="number">1</span>; <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;                                    <span class="comment">// for</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w))</span><br><span class="line">        <span class="comment">//依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点</span></span><br><span class="line">        <span class="comment">// NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(G, w); <span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对非连通图G做深度优先遍历</span></span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = <span class="literal">false</span>;        <span class="comment">//访问标志数组初始化</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v) <span class="comment">//循环调用算法6.3</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            DFS(G, v); <span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//返回v的第一个邻接点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span>&#123;</span><br><span class="line">    <span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = w; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************深度优先搜索遍历非连通图**************&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Graph G;</span><br><span class="line">    CreateUDN(G);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先搜索遍历非连通图结果：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DFSTraverse(G);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（ Breadth First Search，BFS）遍历类似于树的按层次遍历的过程。</p>
<p>广度优先搜索遍历的过程如下：</p>
<ol>
<li><p>从图中某个顶点v出发，访问v。</p>
</li>
<li><p>依次访问v的各个未曾访问过的邻接点。</p>
</li>
<li><p>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。</p>
</li>
<li><p>重复步骤3，直至图中所有已被访问的顶点的邻接点都被访问到</p>
<p><img src="https://img-blog.csdnimg.cn/b38d873f7db345fb9e1af669a1ca2a33.png#pic_center" alt></p>
</li>
</ol>
<p>广度优先生成树</p>
<p><img src="https://img-blog.csdnimg.cn/5d8d5d18139b45ceb9cea446061845b4.png#pic_center" alt></p>
<p>广度优先搜索遍历连通图</p>
<ol>
<li>从图中某个顶点v出发，访问v，并置 visited[y]的值为true，然后将v进队。</li>
<li>只要队列不空，则重复下述操作:<ul>
<li>队头顶点u出队;</li>
<li>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先搜索遍历连通图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100                       	<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100						<span class="comment">//最大队列长度</span></span></span><br><span class="line">						</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;              		<span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;                  		<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="type">bool</span> visited[MVNum];           				<span class="comment">//访问标志数组，其初值为&quot;false&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----图的邻接矩阵存储表示----- </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];            		<span class="comment">//顶点表</span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];      		<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;                		<span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----队列的定义及操作--------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ArcType *base;							<span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line">	<span class="type">int</span> front;								<span class="comment">//头指针，若队列不空，指向队头元素</span></span><br><span class="line">	<span class="type">int</span> rear;								<span class="comment">//尾指针，若队列不空，指向队尾元素的下一个位置</span></span><br><span class="line">&#125;sqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(sqQueue &amp;Q)</span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空队列Q</span></span><br><span class="line">	Q.base = new ArcType[MAXQSIZE];</span><br><span class="line">	<span class="keyword">if</span>(!Q.base)     <span class="built_in">exit</span>(<span class="number">1</span>);				<span class="comment">//存储分配失败</span></span><br><span class="line">	Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(sqQueue &amp;Q, ArcType e)</span>&#123;</span><br><span class="line">	<span class="comment">//插入元素e为Q的新的队尾元素</span></span><br><span class="line">	<span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	Q.base[Q.rear] = e;</span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(sqQueue Q)</span>&#123;</span><br><span class="line">	<span class="comment">//判断是否为空队</span></span><br><span class="line">	<span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(sqQueue &amp;Q, ArcType &amp;u)</span>&#123;</span><br><span class="line">	<span class="comment">//队头元素出队并置为u </span></span><br><span class="line">	u = Q.base[Q.front];</span><br><span class="line">	Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(Graph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(Graph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)   </span><br><span class="line">			G.arcs[i][j] = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的顶点</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = <span class="number">1</span>;	<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G , <span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="comment">//返回v的第一个邻接点</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G , <span class="type">int</span> u , <span class="type">int</span> w)</span>&#123;</span><br><span class="line">	<span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = w ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G.arcs[u][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">(Graph G, <span class="type">int</span> v)</span>&#123; </span><br><span class="line">    <span class="comment">//按广度优先非递归遍历连通图G </span></span><br><span class="line">	sqQueue Q;</span><br><span class="line">	ArcType u;</span><br><span class="line">	ArcType w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;  &quot;</span>;    visited[v] = <span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true </span></span><br><span class="line">    InitQueue(Q); <span class="comment">//辅助队列Q初始化，置空         </span></span><br><span class="line">    EnQueue(Q, v); <span class="comment">//v进队 </span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(Q))&#123; <span class="comment">//队列非空 </span></span><br><span class="line">		DeQueue(Q, u);  <span class="comment">//队头元素出队并置为u</span></span><br><span class="line">		<span class="keyword">for</span>(w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))&#123;</span><br><span class="line">			<span class="comment">//依次检查u的所有邻接点w ，FirstAdjVex(G, u)表示u的第一个邻接点 </span></span><br><span class="line">			<span class="comment">//NextAdjVex(G, u, w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点 </span></span><br><span class="line">			<span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为u的尚未访问的邻接顶点 </span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vexs[w] &lt;&lt; <span class="string">&quot;  &quot;</span>;   visited[w] = <span class="literal">true</span>;	<span class="comment">//访问w，并置访问标志数组相应分量值为true </span></span><br><span class="line">				EnQueue(Q, w);	<span class="comment">//w进队 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************算法广度优先搜索遍历连通图**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Graph G;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向连通图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">	VerTexType c;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c == G.vexs[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &gt;= G.vexnum)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点不存在，请重新输入！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(c == G.vexs[i])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先搜索遍历连通图结果：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	BFS(G , i);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以邻接表为存储结构的图的广度优先搜索遍历代码</span></span><br><span class="line"><span class="comment">//邻接表存储的定义表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>		<span class="comment">//边表结点定义 </span></span><br><span class="line">	<span class="type">int</span> adjvex;  <span class="comment">//该边所指向的结点的位置</span></span><br><span class="line">	ArcNode *nextarc;   <span class="comment">//指向下一条边的指针</span></span><br><span class="line">	<span class="type">int</span> info;			<span class="comment">//该边的相关信息（如权值），这一句用的不多，可不写 </span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>				<span class="comment">//顶点表结点定义 </span></span><br><span class="line">	<span class="type">char</span> data;			<span class="comment">//顶点信息 </span></span><br><span class="line">	ArcNode *firstarc;	<span class="comment">//指向第一条边的指针 </span></span><br><span class="line">&#125;VNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">//邻接表结构体定义 </span></span><br><span class="line">	VNode adjlist[maxSize];  <span class="comment">//邻接表</span></span><br><span class="line">	<span class="type">int</span> n,e;				<span class="comment">//顶点数和边数 </span></span><br><span class="line">&#125;AGraph;			<span class="comment">//图的邻接表类型 </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[maxSize];			<span class="comment">//数组visit作为顶点的访问标记，初始时所有元素均为0，表示所有顶点均为被访问</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//邻接表存储的图的深度优先搜索遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	visit[i]=<span class="number">1</span>;			<span class="comment">//标记已访问 </span></span><br><span class="line">	Visit(v);			<span class="comment">//访问顶点v </span></span><br><span class="line">	p=G.adjlist[v]-&gt;firstarc; 	<span class="comment">//p指向顶点v的第一条边</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[p-&gt;adjvex]==<span class="number">0</span>)&#123;</span><br><span class="line">			DFS(G,p-&gt;adjvex);		<span class="comment">//若该顶点未被访问，则递归访问它 </span></span><br><span class="line">			p=p-&gt;nextarc;			<span class="comment">//完事儿之后p再指向顶点v的下一条边的终点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以邻接矩阵为存储结构的图的广度优先搜索遍历代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 32768</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visited[MAX_VERTEX_NUM];	<span class="comment">//访问标志数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">	<span class="type">int</span> vexnum;	</span><br><span class="line">&#125;Graph;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMatrix</span><span class="params">(Graph *G)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入顶点数：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;G-&gt;vexnum;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入矩阵：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G-&gt;vexnum;++j)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;G-&gt;arcs[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;访问&quot;</span>&lt;&lt;v+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	visited[v]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[w]&amp;&amp;G.arcs[v][w]==<span class="number">1</span>)&#123;	<span class="comment">//w跟v相连，且w未被访问过 </span></span><br><span class="line">			DFS(G,w);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseGraph</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">		visited[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">			DFS(G,i);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Graph G;</span><br><span class="line">	CreateMatrix(&amp;G);</span><br><span class="line">	TraverseGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以邻接表为存储结构的图的广度优先搜索遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AGraph *G, <span class="type">int</span> v, <span class="type">int</span> visit[maxSize])</span>&#123;</span><br><span class="line">	<span class="comment">//visit[]数组被初始化为全为0</span></span><br><span class="line">	 ArcNode *p;</span><br><span class="line">	 <span class="type">int</span> que[maxSize];		<span class="comment">//初始化一个队列 </span></span><br><span class="line">	 <span class="type">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">	 <span class="type">int</span> j; </span><br><span class="line">	 Visit(v);  <span class="comment">//访问v顶点</span></span><br><span class="line">	 visit[v]=<span class="number">1</span>;  <span class="comment">//标记为已访问</span></span><br><span class="line">	 rear=(rear+<span class="number">1</span>)%maxSize;		<span class="comment">//顶点v入队 </span></span><br><span class="line">	 que[rear]=v;</span><br><span class="line">	 </span><br><span class="line">	 p=G-&gt;adjlist[v] </span><br><span class="line">	<span class="keyword">while</span>(front!=rear)&#123;		<span class="comment">//当队不为空时，继续遍历。队为空时，遍历结束 </span></span><br><span class="line">	 	front=(front+<span class="number">1</span>)%maxSize;		<span class="comment">//顶点出队 </span></span><br><span class="line">	 	j=que[front]; </span><br><span class="line">	 </span><br><span class="line">	 	p=G-&gt;adjlist[j].firstarc; 		<span class="comment">//P指向出队顶点j的第一条边</span></span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		 	<span class="keyword">if</span>(visit[p-&gt;adjvex==<span class="number">0</span>])&#123;		<span class="comment">//当前邻接顶点未被访问，则进队 </span></span><br><span class="line">		 		Visit(p-&gt;adjvex);			</span><br><span class="line">		 		visit[p-&gt;adjvex]=<span class="number">1</span>;</span><br><span class="line">		 		rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">				que[rear]=p-&gt;adjvex; </span><br><span class="line">			&#125; </span><br><span class="line">			p=p-&gt;nextarc;			<span class="comment">//p指向j的下一条边 </span></span><br><span class="line">	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>极小连通子图:该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。</p>
<p>生成树:包含图G所有顶点的极小连通子图</p>
<p>生成树的顶点集合与图的顶点集合相等，顶点数为n；不存在回路，边数为n-1</p>
<p><img src="https://img-blog.csdnimg.cn/7aa8f27f6d864a329b6750fd66fbb135.png#pic_center" alt></p>
<p>在网的多个生成树中，寻找一个各边权值之和最小的生成树，即最小生成树</p>
<p>最小生成树的构造—MST：</p>
<ul>
<li><p>设N = (V, E)是一个连通网，U是顶点集V的一个非空子集。若边（u, v）是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边（u, v）的最小生成树</p>
<p>性质解释</p>
<p>在生成树的构造过程中，图中n个顶点分属两个集合：</p>
<ul>
<li>已落在生成树上的顶点集：U</li>
<li>尚未落在生成树上的顶点集：V-U</li>
</ul>
<p>接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边</p>
</li>
</ul>
<p>构造最小生成树的准则：</p>
<ul>
<li>必须只使用该网中的边来构造最小生成树;</li>
<li>必须使用且仅使用n-1条边来联结网络中的n个顶点</li>
<li>不能使用产生回路的边</li>
</ul>
<p>利用 <strong>普里姆（Prim）算法</strong>和 <strong>克鲁斯卡尔（Kruskal）算法</strong>可以生成一个连通网的最小代价生成树。</p>
<h3 id="普里姆算法（加点法）"><a href="#普里姆算法（加点法）" class="headerlink" title="普里姆算法（加点法）"></a>普里姆算法（加点法）</h3><p>算法思想：</p>
<ol>
<li>设N = (V, E) 是连通网，TE是N上最小生成树中边的集合。</li>
<li>初始令U = {u0}，(u0∈V)，TE={}。</li>
<li>在所有u∈U，v∈V-U的边{u, v}∈ E中，找一条代价最小的边(u0, v0)。</li>
<li>将(u0, v0)并入集合TE，同时v0并入U。</li>
<li>重复上述操作直至U=V为止，则T=(V, TE)为N的最小生成树。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/10cec169fbfb44fab90d75fc961930d2.png" alt></p>
<p>代码：</p>
<p>图采用邻接矩阵存储，二维数组closedeg，记录从U到V-U具有最小代价的边。<br>对每个顶点vi, v-U在辅助数组存在一个相应的分量closedge[i-1]，它包括两个域:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType adjvex; <span class="comment">// 最小边的顶点</span></span><br><span class="line">    VRType lowcost;    <span class="comment">// 最小边的权值</span></span><br><span class="line">&#125; closedge[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>
<p>adjvex:依附于这条最小代价边的另一个顶点。</p>
<ul>
<li>等于0表示顶点i已在U中;</li>
<li>大于0表示顶点i还在V-U中。</li>
</ul>
<p>所以，每次循环须在lowcost &gt;0(在集合V-U中)的那些顶点中选择lowcost最小的顶点加入到集合U中，同时将相关顶点的closedge作相应的调整</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普里姆算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767 <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VerTexType adjvex;<span class="comment">//最小边在U中的那个顶点</span></span><br><span class="line">	ArcType lowcost;<span class="comment">//最小边上的权值</span></span><br><span class="line">&#125;closedge[MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -图的邻接表存储表示- - - - - 						</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)   </span><br><span class="line">			G.arcs[i][j] = MaxInt;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 5&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(AMGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//返回权值最小的点</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> min = MaxInt;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(min &gt; closedge[i].lowcost &amp;&amp; closedge[i].lowcost != <span class="number">0</span>)&#123;</span><br><span class="line">			min = closedge[i].lowcost;</span><br><span class="line">			index = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Prim</span><span class="params">(AMGraph G, VerTexType u)</span>&#123; </span><br><span class="line">    <span class="comment">//无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边  </span></span><br><span class="line">	<span class="type">int</span> k , j , i;</span><br><span class="line">	VerTexType u0 , v0;</span><br><span class="line">    k =LocateVex(G, u); <span class="comment">//k为顶点u的下标 </span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123; <span class="comment">//对V-U的每一个顶点vi，初始化closedge[i] </span></span><br><span class="line">		<span class="keyword">if</span>(j != k)&#123;  </span><br><span class="line">			closedge[j].adjvex = u;</span><br><span class="line">			closedge[j].lowcost = G.arcs[k][j];<span class="comment">//&#123;adjvex, lowcost&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedge[k].lowcost = <span class="number">0</span>;<span class="comment">//初始，U = &#123;u&#125;</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//选择其余n-1个顶点，生成n-1条边(n= G.vexnum) </span></span><br><span class="line">		k = Min(G);  </span><br><span class="line">		<span class="comment">//求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边 </span></span><br><span class="line">		u0 = closedge[k].adjvex;<span class="comment">//u0为最小边的一个顶点，u0∈U </span></span><br><span class="line">		v0 = G.vexs[k];<span class="comment">//v0为最小边的另一个顶点，v0∈V-U </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;边  &quot;</span> &lt;&lt;u0 &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; v0 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出当前的最小边(u0, v0) </span></span><br><span class="line">		closedge[k].lowcost = <span class="number">0</span>;<span class="comment">//第k个顶点并入U集 </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j) </span><br><span class="line">			<span class="keyword">if</span>(G.arcs[k][j] &lt; closedge[j].lowcost)&#123;<span class="comment">//新顶点并入U后重新选择最小边 </span></span><br><span class="line">				closedge[j].adjvex = G.vexs[k];</span><br><span class="line">				closedge[j].lowcost = G.arcs[k][j];</span><br><span class="line">			&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************普里姆算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;******利用普里姆算法构造最小生成树结果：******&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	MiniSpanTree_Prim(G , <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克鲁斯卡尔算法（加边法）"><a href="#克鲁斯卡尔算法（加边法）" class="headerlink" title="克鲁斯卡尔算法（加边法）"></a>克鲁斯卡尔算法（加边法）</h3><p>算法思想：</p>
<p>假设连通网N=(V,E)，将Ⅳ中的边按权值从小到大的顺序排列。</p>
<ol>
<li>初始状态为只有n个顶点而无边的非连通图T=(V, {),图中每个顶点自成一个连通分量。</li>
<li>在E中选择权值最小的边，若该边依附的顶点落在T中不同的连通分量上（即不形成回路)，则将此边加人到T中，否则舍去此边而选择下一条权值最小的边。</li>
<li>重复②，直至T中所有顶点都在同一连通分量上为止。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/81d94ba28cd74f2498b44bd559a04e04.png" alt></p>
<p>代码：</p>
<p>算法的实现要引人以下辅助的数据结构</p>
<ol>
<li><p>结构体数组Edge:存储边的信息，包括边的两个顶点信息和权值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助数组Edges的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType Head; <span class="comment">//边的始点</span></span><br><span class="line">    VerTexType Tail; <span class="comment">//边的终点</span></span><br><span class="line">    ArcType lowcost; <span class="comment">//边上的权值</span></span><br><span class="line">&#125; Edge[arcnnum];</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vexset[i]:标识各个顶点所属的连通分量。对每个顶点v,EV，在辅助数组中存在一个相应元素Vexset[i]表示该顶点所在的连通分量。初始时Vexset[i]=i，表示各顶点自成一个连通分量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助数组Vexset的定义</span></span><br><span class="line"><span class="type">int</span> Vexset[MVNum];</span><br></pre></td></tr></table></figure>
<ol>
<li>将数组Edge中的元素按权值从小到大排序。</li>
<li>依次查看数组Edge中的边,循环执行以下操作:<ul>
<li>依次从排好序的数组 Edge 中选出一条边(U1,U2);</li>
<li>在Vexset中分别查找v1和v2所在的连通分量vs1和 vs2，进行判断:<ul>
<li>如果vs1,和vs2不等、表明所选的两个顶点分属不同的连通分量,输出此边,并合并vs1,和 vs2两个连通分量;</li>
<li>如果vs1,和 vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//克鲁斯卡尔算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------图的邻接矩阵---------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助数组Edges的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VerTexType Head;<span class="comment">//边的始点</span></span><br><span class="line">	VerTexType Tail;<span class="comment">//边的终点</span></span><br><span class="line">	ArcType lowcost;<span class="comment">//边上的权值</span></span><br><span class="line">&#125;Edge[(MVNum * (MVNum - <span class="number">1</span>)) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Vexset[MVNum];<span class="comment">//辅助数组Vexset的定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j) </span><br><span class="line">			G.arcs[i][j] = MaxInt; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 6&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">		Edge[k].lowcost = w;</span><br><span class="line">		Edge[k].Head = v1;</span><br><span class="line">		Edge[k].Tail = v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------冒泡排序-------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort</span><span class="params">(AMGraph G)</span>&#123;</span><br><span class="line">	<span class="type">int</span> m = G.arcnum - <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((m &gt; <span class="number">0</span>) &amp;&amp; flag == <span class="number">1</span>)&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(Edge[j].lowcost &gt; Edge[j+ <span class="number">1</span>].lowcost)&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				VerTexType temp_Head = Edge[j].Head;</span><br><span class="line">				Edge[j].Head = Edge[j+ <span class="number">1</span>].Head;</span><br><span class="line">				Edge[j + <span class="number">1</span>].Head = temp_Head;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				VerTexType temp_Tail = Edge[j].Tail;</span><br><span class="line">				Edge[j].Tail = Edge[j+ <span class="number">1</span>].Tail;</span><br><span class="line">				Edge[j + <span class="number">1</span>].Tail = temp_Tail;</span><br><span class="line">				</span><br><span class="line">				ArcType temp_lowcost = Edge[j].lowcost;</span><br><span class="line">				Edge[j].lowcost = Edge[j+ <span class="number">1</span>].lowcost;</span><br><span class="line">				Edge[j + <span class="number">1</span>].lowcost = temp_lowcost;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Kruskal</span><span class="params">(AMGraph G)</span>&#123; </span><br><span class="line">    <span class="comment">//无向网G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边     </span></span><br><span class="line">    <span class="type">int</span> i , j , v1 , v2 , vs1 , vs2;</span><br><span class="line">	Sort(G);<span class="comment">//将数组Edge中的元素按权值从小到大排序 </span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//辅助数组，表示各顶点自成一个连通分量 </span></span><br><span class="line">        Vexset[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.arcnum; ++i)&#123;      </span><br><span class="line">		<span class="comment">//依次查看排好序的数组Edge中的边是否在同一连通分量上     </span></span><br><span class="line">		v1 =LocateVex(G, Edge[i].Head);<span class="comment">//v1为边的始点Head的下标 </span></span><br><span class="line">		v2 =LocateVex(G, Edge[i].Tail);<span class="comment">//v2为边的终点Tail的下标 </span></span><br><span class="line">		vs1 = Vexset[v1];<span class="comment">//获取边Edge[i]的始点所在的连通分量vs1 </span></span><br><span class="line">		vs2 = Vexset[v2];<span class="comment">//获取边Edge[i]的终点所在的连通分量vs2 </span></span><br><span class="line">		<span class="keyword">if</span>(vs1 != vs2)&#123;<span class="comment">//边的两个顶点分属不同的连通分量 </span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; Edge[i].Head &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; Edge[i].Tail &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出此边 </span></span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)<span class="comment">//合并vs1和vs2两个分量，即两个集合统一编号 </span></span><br><span class="line">				<span class="keyword">if</span>(Vexset[j] == vs2) Vexset[j] = vs1;<span class="comment">//集合编号为vs2的都改为vs1 </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************克鲁斯卡尔算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*****无向网G创建完成！*****&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	MiniSpanTree_Kruskal(G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算法名</th>
<th>普里姆算法</th>
<th>克鲁斯卡尔算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法思想</td>
<td>选择点</td>
<td>选择边</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n2)（n为顶点数）</td>
<td>O(eloge)（e为边数）</td>
</tr>
<tr>
<td>适应范围</td>
<td>稠密图</td>
<td>稀疏图</td>
</tr>
</tbody>
</table>
</div>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>对于图来说，从一个顶点到另一个顶点可能存在多条路径，每条路径的所包含的边数可能不同。把所包含的边数最少的那条称为最短路径。</p>
<p>最短路径:对于网(带权的图)来说，从一个顶点到另一个顶点所经过的边的权值之和称为带权路径长度，把带权路径长度最短的那条称为最短路径</p>
<h3 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h3><p><strong>从某个源点到其余各顶点的最短路径</strong></p>
<ol>
<li>初始化:先找出从源点v0到各终点v的直达路径(v0,vk)，即通过一条弧到达的路径。</li>
<li>选择:从这些路径中找出一条长度最短的路径(v0,u) 。</li>
<li>更新:然后对其余各条路径进行适当调整。</li>
</ol>
<p>若在图中存在弧(u，vk) ，(v0，u) +(u，vk)&lt; (v0，vk) ,则以路径(v0,u,vk)代替（v0，vk)。<br>在调整后的各条路径中，再找长度最短的路径。</p>
<p>主要存储结构︰邻接矩阵G[n] (或者邻接表)</p>
<p>辅助存储结构︰</p>
<ul>
<li>数组S[n]:记录相应顶点是否已被确定最短距离<br>true:确定 false:未确定</li>
<li>数组D[n]:记录源点到相应顶点路径长度<br>初值:如果v0到vi有弧，则D[i]为弧上权值;否则为∞</li>
<li>数组Path[n]:记录相应顶点的前驱顶点<br>初值:如果v0到vi有弧，则Path[i]为v0，否则为-1</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最短路径--迪杰斯特拉算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *D=new <span class="type">int</span>[MVNum];<span class="comment">//用于记录最短路的长度</span></span><br><span class="line"><span class="type">bool</span> *S=new <span class="type">bool</span>[MVNum];<span class="comment">//标记顶点是否进入S集合</span></span><br><span class="line"><span class="type">int</span> *Path=new <span class="type">int</span>[MVNum];<span class="comment">//用于记录最短路顶点的前驱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------图的邻接矩阵-----------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称:，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)   </span><br><span class="line">			G.arcs[i][j] = MaxInt; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 7&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_DIJ</span><span class="params">(AMGraph G, <span class="type">int</span> v0)</span>&#123; </span><br><span class="line">    <span class="comment">//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 </span></span><br><span class="line">    <span class="type">int</span> v , i , w , min;</span><br><span class="line">	<span class="type">int</span> n = G.vexnum;<span class="comment">//n为G中顶点的个数 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; n; ++v)&#123;<span class="comment">//n个顶点依次初始化 </span></span><br><span class="line">		S[v] = <span class="number">0</span>;<span class="comment">//S初始为空集 </span></span><br><span class="line">		D[v] = G.arcs[v0][v];<span class="comment">//将v0到各个终点的最短路径长度初始化为弧上的权值 </span></span><br><span class="line">		<span class="keyword">if</span>(D[v] &lt; MaxInt)  Path [v] = v0;<span class="comment">//如果v0和v之间有弧，则将v的前驱置为v0 </span></span><br><span class="line">		<span class="keyword">else</span> Path [v] = <span class="number">-1</span>;<span class="comment">//如果v0和v之间无弧，则将v的前驱置为-1 </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	S[v0]=<span class="literal">true</span>;<span class="comment">//将v0加入S </span></span><br><span class="line">	D[v0]=<span class="number">0</span>;<span class="comment">//源点到源点的距离为0 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*―初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/</span> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; n; ++i)&#123;<span class="comment">//对其余n-1个顶点，依次进行计算 </span></span><br><span class="line">        min= MaxInt; </span><br><span class="line">        <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; n; ++w) </span><br><span class="line">			<span class="keyword">if</span>(!S[w] &amp;&amp; D[w] &lt; min)&#123;<span class="comment">//选择一条当前的最短路径，终点为v </span></span><br><span class="line">				v = w; </span><br><span class="line">				min = D[w];</span><br><span class="line">			&#125;</span><br><span class="line">		S[v]=<span class="literal">true</span>;<span class="comment">//将v加入S </span></span><br><span class="line">		<span class="keyword">for</span>(w = <span class="number">0</span>;w &lt; n; ++w)<span class="comment">//更新从v0出发到集合V?S上所有顶点的最短路径长度 </span></span><br><span class="line">			<span class="keyword">if</span>(!S[w] &amp;&amp; (D[v] + G.arcs[v][w] &lt; D[w]))&#123; </span><br><span class="line">				D[w] = D[v] + G.arcs[v][w];<span class="comment">//更新D[w] </span></span><br><span class="line">				Path [w] = v;<span class="comment">//更改w的前驱为v </span></span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayPath</span><span class="params">(AMGraph G , <span class="type">int</span> begin ,<span class="type">int</span> temp )</span>&#123;</span><br><span class="line">	<span class="comment">//显示最短路</span></span><br><span class="line">	<span class="keyword">if</span>(Path[temp] != <span class="number">-1</span>)&#123;</span><br><span class="line">		DisplayPath(G , begin ,Path[temp]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[Path[temp]] &lt;&lt; <span class="string">&quot;--&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************迪杰斯特拉算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G; </span><br><span class="line">	<span class="type">int</span> i , j ,num_start , num_destination;</span><br><span class="line">	VerTexType start , destination;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*****无向网G创建完成！*****&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j != G.vexnum - <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(G.arcs[i][j] != MaxInt)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; G.arcs[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;∞&quot;</span> &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(G.arcs[i][j] != MaxInt)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; G.arcs[i][j] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;∞&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入起始点、终点名称：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">	num_start = LocateVex(G , start);</span><br><span class="line">	num_destination = LocateVex(G , destination);</span><br><span class="line">	ShortestPath_DIJ(G , num_start);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="string">&quot;最短路径为：&quot;</span>;</span><br><span class="line">	DisplayPath(G , num_start , num_destination);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; G.vexs[num_destination]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h3><p><strong>每一对顶点之间的最短路径</strong></p>
<p>求最短路径步骤:</p>
<ol>
<li>初始时设置一个n阶方阵,令其对角线元素为0，若存在弧<Vi，Vj>，则对应元素为权值;否则为无穷大。</Vi，Vj></li>
<li>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之;否则，维持原值。所有顶点试探完毕，算法结束。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弗洛伊德算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Path[MVNum][MVNum];<span class="comment">//最短路径上顶点vj的前一顶点的序号</span></span><br><span class="line"><span class="type">int</span> D[MVNum][MVNum];<span class="comment">//记录顶点vi和vj之间的最短路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------图的邻接矩阵---------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建有向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123;  </span><br><span class="line">			<span class="keyword">if</span>(j != i)</span><br><span class="line">				G.arcs[i][j] = MaxInt;  </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyed</span><span class="params">(AMGraph G)</span>&#123; </span><br><span class="line">    <span class="comment">//用Floyd算法求有向网G中各对顶点i和j之间的最短路径 </span></span><br><span class="line">	<span class="type">int</span> i , j , k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//各对结点之间初始已知路径及距离 </span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123; </span><br><span class="line">            D[i][j] = G.arcs[i][j]; </span><br><span class="line">            <span class="keyword">if</span>(D[i][j] &lt; MaxInt &amp;&amp; i != j)  Path[i][j]=i;<span class="comment">//如果i和j之间有弧，则将j的前驱置为i </span></span><br><span class="line">            <span class="keyword">else</span> Path [i][j] = <span class="number">-1</span>;<span class="comment">//如果i和j之间无弧，则将j的前驱置为-1 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.vexnum; ++k) </span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i) </span><br><span class="line">				<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">					<span class="keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])&#123;<span class="comment">//从i经k到j的一条路径更短 </span></span><br><span class="line">						D[i][j] = D[i][k]+D[k][j];<span class="comment">//更新D[i][j] </span></span><br><span class="line">						Path[i][j] = Path[k][j];<span class="comment">//更改j的前驱为k </span></span><br><span class="line">					&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayPath</span><span class="params">(AMGraph G , <span class="type">int</span> begin ,<span class="type">int</span> temp )</span>&#123;</span><br><span class="line">	<span class="comment">//显示最短路径</span></span><br><span class="line">	<span class="keyword">if</span>(Path[begin][temp] != <span class="number">-1</span>)&#123;</span><br><span class="line">		DisplayPath(G , begin ,Path[begin][temp]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[Path[begin][temp]] &lt;&lt; <span class="string">&quot;--&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************弗洛伊德算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	<span class="type">char</span> start , destination;</span><br><span class="line">	<span class="type">int</span> num_start , num_destination;</span><br><span class="line"></span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有向网G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ShortestPath_Floyed(G);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入路径的起点与终点的名称：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">	num_start = LocateVex(G , start);</span><br><span class="line">	num_destination = LocateVex(G , destination);</span><br><span class="line"></span><br><span class="line">	DisplayPath(G , num_start , num_destination);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; G.vexs[num_destination] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最短路径的长度为：&quot;</span> &lt;&lt; D[num_start][num_destination] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对一项工程，我们最关心两个问题:</p>
<p>①工程能否顺利完成;(拓扑排序)<br>②整个工程完成所必需的最短工期。(关键路径)</p>
<p>有向无环图——无环的有向图，简称DAG图( directed acycling graph)</p>
<p>AOV网:用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网。</p>
<p>AOV网应该是一个有向无环图即DAG图</p>
<p>拓扑排序：就是将AOV网中所有顶点排成一个线性序列(称为拓扑序列)，该序列满足∶<br>若在AOV网中由顶点vi到vj有一条路径，则在该线性序列中的顶点vi必定在vj之前</p>
<ol>
<li>在有向图中选一个无前驱的顶点且输出它（即入度为0)</li>
<li>从图中删除该顶点和所有以它为起点的边</li>
<li>重复(1)(2)，直至不存在无前驱的顶点</li>
<li>若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在环，否则输出的顶点序列为一个拓扑序列</li>
</ol>
<p>拓扑排序实现</p>
<ul>
<li>求出个顶点的入度存入数组indegree[i]中，并将入度为0的顶点入栈。</li>
<li>只要栈不空，重复以下操作<ul>
<li>将栈顶顶点vi出栈并保存在拓扑序列数组topo中;</li>
<li>对顶点vi的每个邻接点vk的入度减1，如果vk的入度变为0，则将vk入栈</li>
</ul>
</li>
<li>如果输出顶点个数少于AOV网的顶点个数，则网址存在有向环，无法进行拓扑排序，否则拓扑排序成功。</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -图的邻接表存储表示- - - - - </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针 </span></span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息 </span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//邻接表 </span></span><br><span class="line">	AdjList converse_vertices;<span class="comment">//逆邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -顺序栈的定义- - - - -</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *base;</span><br><span class="line">	<span class="type">int</span> *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;spStack;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> indegree[MVNum];<span class="comment">//数组indegree存放个顶点的入度</span></span><br><span class="line">spStack S;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------栈的相关操作----------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(spStack &amp;S)</span>&#123;</span><br><span class="line">	<span class="comment">//初始化栈</span></span><br><span class="line">	S.base = new <span class="type">int</span>[MVNum];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = MVNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(spStack &amp;S , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="comment">//进栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top - S.base == S.stacksize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	*S.top++ = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(spStack &amp;S , <span class="type">int</span> &amp;i)</span>&#123;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	i = *--S.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(spStack S)</span>&#123;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(ALGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vertices[i].data == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123; </span><br><span class="line">	<span class="comment">//创建有向图G的邻接表、逆邻接表</span></span><br><span class="line">	<span class="type">int</span> i , k;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">		G.converse_vertices[i].data = G.vertices[i].data;</span><br><span class="line">		<span class="comment">//初始化表头结点的指针域为NULL </span></span><br><span class="line">		G.vertices[i].firstarc=<span class="literal">NULL</span>;			</span><br><span class="line">		G.converse_vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		<span class="type">int</span> i , j;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);</span><br><span class="line">		<span class="comment">//确定v1和v2在G中位置，即顶点在G.vertices中的序号 </span></span><br><span class="line"></span><br><span class="line">		ArcNode *p1=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p1-&gt;adjvex=j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">		p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line"></span><br><span class="line">		ArcNode *p2=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p2-&gt;adjvex=i;<span class="comment">//逆邻接点序号为i</span></span><br><span class="line">		p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindInDegree</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">	<span class="type">int</span> i , count;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; i++)&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		ArcNode *p = G.converse_vertices[i].firstarc;</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				p = p-&gt;nextarc;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		indegree[i] = count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G , <span class="type">int</span> topo[])</span>&#123; </span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line">    <span class="comment">//若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR </span></span><br><span class="line">	<span class="type">int</span> i , m;</span><br><span class="line">    FindInDegree(G);<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">    InitStack(S);<span class="comment">//栈S初始化为空 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!indegree[i]) Push(S, i);<span class="comment">//入度为0者进栈 </span></span><br><span class="line">	m = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始为0 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;<span class="comment">//栈S非空 </span></span><br><span class="line">		Pop(S, i);<span class="comment">//将栈顶顶点vi出栈</span></span><br><span class="line">		topo[m]=i;<span class="comment">//将vi保存在拓扑序列数组topo中 </span></span><br><span class="line">		++m;<span class="comment">//对输出顶点计数 </span></span><br><span class="line">		ArcNode *p = G.vertices[i].firstarc;<span class="comment">//p指向vi的第一个邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			<span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//vk为vi的邻接点   </span></span><br><span class="line">			--indegree[k];<span class="comment">//vi的每个邻接点的入度减1 </span></span><br><span class="line">			<span class="keyword">if</span>(indegree[k] ==<span class="number">0</span>)  Push(S, k);<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向顶点vi下一个邻接结点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m &lt; G.vexnum)  <span class="keyword">return</span> ERROR;<span class="comment">//该有向图有回路 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************拓扑排序**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateUDG(G);</span><br><span class="line">	<span class="type">int</span> *topo = new <span class="type">int</span> [G.vexnum];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有向图的邻接表、逆邻接表创建完成!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(TopologicalSort(G , topo))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该有向图的拓扑有序序列为：&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; G.vexnum; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j != G.vexnum - <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vertices[topo[j]].data &lt;&lt; <span class="string">&quot; , &quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vertices[topo[j]].data &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;网中存在环，无法进行拓扑排序！&quot;</span> &lt;&lt;<span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>AOE网(Activity On Edges)—用边表示活动的网络用一个有向图表示一个工程的各子工程及其相互制约的关系，弧表示活动，权表示活动持续的时间，顶点表示事件（活动的开始或结束时间)，称这种有向图为边表示活动的网，简称AOE网;AOE网用来估算工程的完成时间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">源点</td>
<td style="text-align:center">入度为0的顶点（只有1个)</td>
</tr>
<tr>
<td style="text-align:center">汇点</td>
<td style="text-align:center">出度为0的顶点(只有1个)</td>
</tr>
<tr>
<td style="text-align:center">路径长度</td>
<td style="text-align:center">路径上各活动持续时间之和</td>
</tr>
<tr>
<td style="text-align:center">整个工程完成的时间</td>
<td style="text-align:center">从有向图的源点到汇点的最长路径</td>
</tr>
<tr>
<td style="text-align:center">关键路径</td>
<td style="text-align:center">路径长度最长的路径</td>
</tr>
<tr>
<td style="text-align:center">关键活动</td>
<td style="text-align:center">关键路径上的活动，边上的权值增加将使有向图上的最长路径的长度增加。</td>
</tr>
<tr>
<td style="text-align:center">ve(j)</td>
<td style="text-align:center">表示事件V的最早发生时间</td>
</tr>
<tr>
<td style="text-align:center">vl(j)</td>
<td style="text-align:center">表示事件V,的最迟发生时间</td>
</tr>
<tr>
<td style="text-align:center">e(i)</td>
<td style="text-align:center">表示活动ai的最早开始时间</td>
</tr>
<tr>
<td style="text-align:center">l(i)</td>
<td style="text-align:center">表示活动ai的最迟开始时间</td>
</tr>
<tr>
<td style="text-align:center">l(i)-e(i)</td>
<td style="text-align:center">表示完成活动ai的时间余量</td>
</tr>
</tbody>
</table>
</div>
<p>注意:在一个AOE网中，可以有不止一条的关键路径。</p>
<p><img src="https://img-blog.csdnimg.cn/9c0693cd56b74b6f9f3bfd950265aa7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57Sg6ZSm5rWB5bm044Gk,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键路径算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BDNum MVNum * (MVNum - 1)<span class="comment">//最大边数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -图的邻接表存储表示- - - - - </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">	<span class="type">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针 </span></span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    AdjList vertices;<span class="comment">//邻接表 </span></span><br><span class="line">	AdjList converse_vertices;<span class="comment">//逆邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -顺序栈的定义- - - - -</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *base;</span><br><span class="line">	<span class="type">int</span> *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;spStack;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> indegree[MVNum];<span class="comment">//数组indegree存放个顶点的入度</span></span><br><span class="line"><span class="type">int</span> ve[BDNum];<span class="comment">//事件vi的最早发生时间</span></span><br><span class="line"><span class="type">int</span> vl[BDNum];<span class="comment">//事件vi的最迟发生时间</span></span><br><span class="line"><span class="type">int</span> topo[MVNum];<span class="comment">//记录拓扑序列的顶点序号</span></span><br><span class="line">spStack S;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------栈的操作--------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(spStack &amp;S)</span>&#123;</span><br><span class="line">	<span class="comment">//栈的初始化</span></span><br><span class="line">	S.base = new <span class="type">int</span>[MVNum];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = MVNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(spStack &amp;S , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top - S.base == S.stacksize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	*S.top++ = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(spStack &amp;S , <span class="type">int</span> &amp;i)</span>&#123;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	i = *--S.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(spStack S)</span>&#123;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(ALGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vertices[i].data == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123; </span><br><span class="line">	<span class="comment">//创建有向图G的邻接表、逆邻接表</span></span><br><span class="line">	<span class="type">int</span> i , k;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">		G.converse_vertices[i].data = G.vertices[i].data;</span><br><span class="line">		<span class="comment">//初始化表头结点的指针域为NULL </span></span><br><span class="line">		G.vertices[i].firstarc=<span class="literal">NULL</span>;			</span><br><span class="line">		G.converse_vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及其权值，如a b 3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		<span class="type">int</span> i , j , w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及其权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);</span><br><span class="line">		<span class="comment">//确定v1和v2在G中位置，即顶点在G.vertices中的序号 </span></span><br><span class="line"></span><br><span class="line">		ArcNode *p1=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p1-&gt;adjvex=j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">		p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;</span><br><span class="line">		p1-&gt;weight = w;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line"></span><br><span class="line">		ArcNode *p2=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p2-&gt;adjvex=i;<span class="comment">//逆邻接点序号为i</span></span><br><span class="line">		p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;</span><br><span class="line">		p2-&gt;weight = w;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindInDegree</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">	<span class="type">int</span> i , count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; i++)&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		ArcNode *p = G.converse_vertices[i].firstarc;</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				p = p-&gt;nextarc;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		indegree[i] = count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">TopologicalOrder</span><span class="params">(ALGraph G , <span class="type">int</span> topo[])</span>&#123; </span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line">    <span class="comment">//若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR </span></span><br><span class="line">	<span class="type">int</span> i , m;</span><br><span class="line">    FindInDegree(G);<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">    InitStack(S);<span class="comment">//栈S初始化为空 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!indegree[i]) Push(S, i);<span class="comment">//入度为0者进栈 </span></span><br><span class="line">	m = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始为0 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;<span class="comment">//栈S非空 </span></span><br><span class="line">		Pop(S, i);<span class="comment">//将栈顶顶点vi出栈</span></span><br><span class="line">		topo[m]=i;<span class="comment">//将vi保存在拓扑序列数组topo中 </span></span><br><span class="line">		++m;<span class="comment">//对输出顶点计数 </span></span><br><span class="line">		ArcNode *p = G.vertices[i].firstarc;<span class="comment">//p指向vi的第一个邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			<span class="type">int</span> k = p-&gt;adjvex;\<span class="comment">//vk为vi的邻接点   </span></span><br><span class="line">			--indegree[k];<span class="comment">//vi的每个邻接点的入度减1 </span></span><br><span class="line">			<span class="keyword">if</span>(indegree[k] ==<span class="number">0</span>)  Push(S, k);<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向顶点vi下一个邻接结点 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m &lt; G.vexnum)  <span class="keyword">return</span> ERROR;<span class="comment">//该有向图有回路 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CriticalPath</span><span class="params">(ALGraph G)</span>&#123; </span><br><span class="line">    <span class="comment">//G为邻接表存储的有向网，输出G的各项关键活动</span></span><br><span class="line">	<span class="type">int</span> n , i , k , j , e , l;</span><br><span class="line">    <span class="keyword">if</span> (!TopologicalOrder(G, topo))  <span class="keyword">return</span> ERROR; </span><br><span class="line">    <span class="comment">//调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环，返回ERROR </span></span><br><span class="line">    n = G.vexnum;<span class="comment">//n为顶点个数 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//给每个事件的最早发生时间置初值0 </span></span><br><span class="line">		ve[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*――――――――――按拓扑次序求每个事件的最早发生时间－――――－―――――*/</span> </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;                 </span><br><span class="line">		k = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k             </span></span><br><span class="line">		ArcNode *p = G.vertices[k].firstarc;<span class="comment">//p指向k的第一个邻接顶点  </span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;<span class="comment">//依次更新k的所有邻接顶点的最早发生时间   </span></span><br><span class="line">			j = p-&gt;adjvex;<span class="comment">//j为邻接顶点的序号                   </span></span><br><span class="line">			<span class="keyword">if</span>(ve[j] &lt; ve[k] + p-&gt;weight)<span class="comment">//更新顶点j的最早发生时间ve[j] </span></span><br><span class="line">				ve[j] = ve[k] + p-&gt;weight;     </span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向k的下一个邻接顶点  </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//给每个事件的最迟发生时间置初值ve[n-1] </span></span><br><span class="line">		vl[i]=ve[n<span class="number">-1</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*――――――――――按逆拓扑次序求每个事件的最迟发生时间－――――－―――――*/</span> </span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;               </span><br><span class="line">		k = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k             </span></span><br><span class="line">		ArcNode *p = G.vertices[k].firstarc;<span class="comment">//p指向k的第一个邻接顶点  </span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;<span class="comment">//根据k的邻接点，更新k的最迟发生时间   </span></span><br><span class="line">			j = p-&gt;adjvex;<span class="comment">//j为邻接顶点的序号                   </span></span><br><span class="line">			<span class="keyword">if</span>(vl[k] &gt; vl[j] - p-&gt;weight)<span class="comment">//更新顶点k的最迟发生时间vl[k] </span></span><br><span class="line">				vl[k] = vl[j] - p-&gt;weight;       </span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向k的下一个邻接顶点  </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*――――――――――――判断每一活动是否为关键活动－――――――－―――――*/</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;关键活动路径为:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;<span class="comment">//每次循环针对vi为活动开始点的所有活动 </span></span><br><span class="line">        ArcNode *p = G.vertices[i].firstarc;    <span class="comment">//p指向i的第一个邻接顶点  </span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			j = p-&gt;adjvex;<span class="comment">//j为i的邻接顶点的序号    </span></span><br><span class="line">			e = ve[i];<span class="comment">//计算活动&lt;vi, vj&gt;的最早开始时间 </span></span><br><span class="line">			l = vl[j] - p-&gt;weight;<span class="comment">//计算活动&lt;vi, vj&gt;的最迟开始时间 </span></span><br><span class="line">			<span class="keyword">if</span>(e == l)<span class="comment">//若为关键活动，则输出&lt;vi, vj&gt; </span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vertices[i].data &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; G.vertices[j].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向i的下一个邻接顶点  </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************关键路径算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateUDG(G);</span><br><span class="line">	<span class="type">int</span> *topo = new <span class="type">int</span> [G.vexnum];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有向图创建完成!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!CriticalPath(G))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;网中存在环，无法进行拓扑排序！&quot;</span> &lt;&lt;<span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://falltoher.github.io">falltoher</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://falltoher.github.io/post/ee040603.html">https://falltoher.github.io/post/ee040603.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a444b428.html" title="排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">排序</div></div></a></div><div class="next-post pull-right"><a href="/post/7b216a3b.html" title="树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">树</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/post/de9add19.html" title="串、数组、广义表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">串、数组、广义表</div></div></a></div><div><a href="/post/a444b428.html" title="排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">排序</div></div></a></div><div><a href="/post/35ca0ba5.html" title="数据结构概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">数据结构概述</div></div></a></div><div><a href="/post/33cb1151.html" title="查找"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">查找</div></div></a></div><div><a href="/post/7b216a3b.html" title="树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">树</div></div></a></div><div><a href="/post/a1359bee.html" title="栈、队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">栈、队列</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">falltoher</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Falltoher"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">基本概念和术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">类型定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">4.1.</span> <span class="toc-text">深度优先搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">4.2.</span> <span class="toc-text">广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E7%82%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">普里姆算法（加点法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E8%BE%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">克鲁斯卡尔算法（加边法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">5.2.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">迪杰斯特拉(Dijkstra)算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd-%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">弗洛伊德(Floyd)算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.4.</span> <span class="toc-text">关键路径</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/82f3b407.html" title="Requests">Requests</a><time datetime="2024-02-03T10:15:46.000Z" title="Created 2024-02-03 18:15:46">2024-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3e3e1b3d.html" title="Scrapy">Scrapy</a><time datetime="2024-02-03T10:07:02.000Z" title="Created 2024-02-03 18:07:02">2024-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/b0ab0ffc.html" title="“*”的用途">“*”的用途</a><time datetime="2024-01-30T06:50:00.000Z" title="Created 2024-01-30 14:50:00">2024-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/adc81e94.html" title="梳理">梳理</a><time datetime="2023-12-24T11:03:14.000Z" title="Created 2023-12-24 19:03:14">2023-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/eefd1ae3.html" title="is-VS-equals">is-VS-equals</a><time datetime="2023-12-21T11:04:01.000Z" title="Created 2023-12-21 19:04:01">2023-12-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> falltoher</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script src="//code.tidio.co/lwnnwn82q5a1rhwub0iobwelnbedmuka.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/search/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.akilar.top/api?falltoher",['#e4dfd7', '#f9f4dc', '#f7e8aa', '#f7e8aa', '#f8df72', '#fcd217', '#fcc515', '#f28e16', '#fb8b05', '#d85916', '#f43e06'],'falltoher')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>