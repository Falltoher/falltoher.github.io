<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ajax</title>
    <url>/post/65940d5a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AJAX 全称为Asynchronous JavaScript And XML，就是异步的JS 和XML<br>通过AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据<br>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</p>
<ul>
<li>优点 <ul>
<li>可以无需刷新页面而与服务器端进行通信 </li>
<li>允许你根据用户事件来更新部分页面内容</li>
</ul>
</li>
<li>缺点 <ul>
<li>没有浏览历史，不能回退 </li>
<li>存在跨域问题(同源)</li>
<li>SEO 不友好</li>
</ul>
</li>
</ul>
<h1 id="HTTP相关问题"><a href="#HTTP相关问题" class="headerlink" title="HTTP相关问题"></a>HTTP相关问题</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview">MDN 文档</a></p>
<h2 id="HTTP-请求交互的基本过程"><a href="#HTTP-请求交互的基本过程" class="headerlink" title="HTTP 请求交互的基本过程"></a>HTTP 请求交互的基本过程</h2><ol>
<li>前后应用从浏览器端向服务器发送HTTP 请求(请求报文)</li>
<li>后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)</li>
<li>浏览器端接收到响应, 解析显示响应体/调用监视回调</li>
</ol>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则</p>
<h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><ol>
<li><p>请求行<br>method url<br>GET /product_detail?id=2<br>POST /login</p>
</li>
<li><p>多个请求头<br>Host: www.baidu.com<br>Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;<br>Content-Type: application/x-www-form-urlencoded 或者application/json</p>
</li>
<li><p>请求体<br>username=tom&amp;pwd=123<br>{“username”: “tom”, “pwd”: 123}</p>
</li>
</ol>
<h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>响应状态行: status statusText<br>多个响应头<br>Content-Type: text/html;charset=utf-8<br>Set-Cookie: BD_CK_SAM=1;path=/<br>响应体<br>html 文本/json 文本/js/css/图片…</p>
<h3 id="post-请求体参数格式"><a href="#post-请求体参数格式" class="headerlink" title="post 请求体参数格式"></a>post 请求体参数格式</h3><ol>
<li><code>Content-Type: application/x-www-form-urlencoded;charset=utf-8</code><br>用于键值对参数，参数的键值用=连接, 参数之间用&amp;连接<br>例如: <code>name=%E5%B0%8F%E6%98%8E&amp;age=12</code></li>
<li><code>Content-Type: application/json;charset=utf-8</code><br>用于 json 字符串参数<br>例如: <code>&#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125;</code></li>
<li><code>Content-Type: multipart/form-data</code><br>用于文件上传请求</li>
</ol>
<h2 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h2><p><strong>状态码</strong><br>1xx：指示信息-表示请求已接收，继续处理<br>2xx：成功-表示请求已被成功接收<br>3xx：重定向-要完成请求必须进行更进一步的操作<br>4xx：客户端错误-请求有语法错误或请求无法实现<br>5xx：服务器错误-服务器未能实现合法的请求</p>
<p><strong>常见的http状态码</strong><br>200 OK 请求成功。一般用于GET 与POST 请求<br>201 Created 已创建。成功请求并创建了新的资源<br>206：客户发送带有range头的GET请求，服务器完成了它<br>301：重定向（永久）<br>302：重定向（临时）<br>304：资源未被修改，有缓存<br>401 Unauthorized 未授权/请求要求用户的身份认证<br>403：请求被拒绝<br>404 Not Found 服务器无法根据客户端的请求找到资源<br>500 Internal Server Error 服务器内部错误，无法完成请求<br>504：网关超时</p>
<h2 id="不同类型的请求及其作用"><a href="#不同类型的请求及其作用" class="headerlink" title="不同类型的请求及其作用"></a>不同类型的请求及其作用</h2><ul>
<li>GET: 从服务器端读取数据（查） </li>
<li>POST: 向服务器端添加新数据（增） </li>
<li>PUT: 更新服务器端已经数据（改） </li>
<li>DELETE: 删除服务器端数据（删）</li>
</ul>
<h2 id="API-的分类"><a href="#API-的分类" class="headerlink" title="API 的分类"></a>API 的分类</h2><ul>
<li>REST API: restful （Representational State Transfer (资源)表现层状态转化） <ol>
<li>发送请求进行CRUD 哪个操作由请求方式来决定</li>
<li>同一个请求路径可以进行多个操作</li>
<li>请求方式会用到GET/POST/PUT/DELETE </li>
</ol>
</li>
<li>非REST API: restless <ol>
<li>请求方式不决定请求的CRUD操作</li>
<li>一个请求路径只对应一个操作</li>
<li>一般只有GET/POST</li>
</ol>
</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>区别：一般http请求与Ajax请求<br>ajax请求是一种特别的 http请求<br>对服务器端来说, 没有任何区别, 区别在浏览器端<br>浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求<br>浏览器端接收到响应<br>(1) 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面<br>(2) ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据</p>
<h1 id="原生Ajax的基本使用XHR"><a href="#原生Ajax的基本使用XHR" class="headerlink" title="原生Ajax的基本使用XHR"></a>原生Ajax的基本使用XHR</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p><a href="https://nodejs.org/en">官网</a></p>
<h3 id="express服务端框架"><a href="#express服务端框架" class="headerlink" title="express服务端框架"></a>express服务端框架</h3><p><a href="http://expressjs.com/">官网</a></p>
<ol>
<li><p>初始化环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init --yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载express包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//  设置响应</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&quot;Hello Express&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动, 8000 端口监听中...&quot;</span>);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行js程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node .\01express使用.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开网页显示页面</p>
</li>
<li><p>调试程序可以查看请求和响应</p>
</li>
</ol>
<h3 id="nodemon自动重启工具"><a href="#nodemon自动重启工具" class="headerlink" title="nodemon自动重启工具"></a>nodemon自动重启工具</h3><p><a href="https://nodemon.io/">官网</a><br><a href="https://www.npmjs.com/package/nodemon">nodemon-nmp</a></p>
<p>安装<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure><br>启动服务<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndoemon server.js</span><br></pre></td></tr></table></figure></p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>使用XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送Ajax请求<br>前端可以获取到数据，而无需让整个的页面刷新。<br>这使得Web 页面可以只更新页面的局部，而不影响用户的操作。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>，AJAX 的所有操作都是通过该对象进行的</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>创建XMLHttpRequest 对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><br>设置请求信息（请求方法和url）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求方式</span></span><br><span class="line">xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line"><span class="comment">//可以设置请求头，一般不设置</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br></pre></td></tr></table></figure><br>发送请求<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>(body) <span class="comment">//get请求不传 body 参数，只有post请求使用</span></span><br></pre></td></tr></table></figure><br>接收响应（事件绑定，处理服务端返回的结果）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xhr.responseXML 接收 xml格式 的响应数据</span></span><br><span class="line"><span class="comment">//xhr.responseText 接收 文本格式 的响应数据</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> text = xhr.<span class="property">responseText</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p>点击返回响应信息<br>服务器端 server.js<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由规则</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应头 设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&quot;Hello Ajax&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 监听服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动, 8000 端口监听中...&quot;</span>);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><br>启动服务<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure><br>前端页面 html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ajax GET 请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#90b</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//获取button元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//绑定事件</span></span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 1. 创建对象 </span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 2. 初始化 设置请求方法和url</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 3. 发送</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 4. 事件绑定 处理服务端返回的结果</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//判断 (服务端返回了所有的结果)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//判断响应状态码 200  404  403 401 500</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 处理结果 行 头 空行 体</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 响应</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态码&#x27;</span>, xhr.<span class="property">status</span>); <span class="comment">// 状态码</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态字符串&#x27;</span>, xhr.<span class="property">statusText</span>); <span class="comment">// 状态字符串</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有响应头&#x27;</span>, xhr.<span class="title function_">getAllResponseHeaders</span>()); <span class="comment">// 所有响应头</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应体&#x27;</span>, xhr.<span class="property">response</span>); <span class="comment">// 响应体</span></span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//设置 result 的文本</span></span></span><br><span class="line"><span class="language-javascript">            result.<span class="property">innerHTML</span>=xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125; </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>GET</code>请求设置请求参数</strong><br>设置url参数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><p>鼠标放到div中，发post请求，将响应体放在div中呈现</p>
<p>server.js添加post<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应头, 设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&quot;Hello Ajax POST&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>post.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ajax POST 请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#903</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取元素对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 绑定事件</span></span></span><br><span class="line"><span class="language-javascript">    result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 1. 创建对象</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 2. 初始化 设置类型（请求方式）与url</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 3. 发送   设置请求参数（请求体）</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="title function_">send</span>(<span class="string">&#x27;a=100&amp;b=200&amp;c=300&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 4. 事件绑定</span></span></span><br><span class="line"><span class="language-javascript">      xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 判断</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;=<span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 处理服务端返回的结果</span></span></span><br><span class="line"><span class="language-javascript">            result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>设置请求头信息<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置请求体内容的类型</span></span><br><span class="line">xhr.<span class="title function_">setRequesHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-from-urlencoded&#x27;</span>);</span><br><span class="line"><span class="comment">// 自定义头信息</span></span><br><span class="line">xhr.<span class="title function_">setRequesHeader</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;ykyk&#x27;</span>);</span><br></pre></td></tr></table></figure><br>server.js中设置响应头允许自定义请求头 post改成all<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Header&#x27;</span>,<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="json数据请求"><a href="#json数据请求" class="headerlink" title="json数据请求"></a>json数据请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应头, 设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置响应头, 设置允许自定义头信息</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// 响应一个数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 对 对象 进行 字符串 转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">  <span class="comment">// 设置响应体 </span></span><br><span class="line">  response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSON<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#89b</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 绑定键盘按下事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// *2*.(自动转换) 设置响应体数据的类型(自动转换)</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/json-server&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 事件绑定</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 1. 手动对数据转化 (字符串再转换成json)</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// let data = JSON.parse(xhr.response); //转换成json</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// result.innerHTML = data.name;</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// *2*. (自动转换)自动转换(自动转换)</span></span></span><br><span class="line"><span class="language-javascript">                    result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>.<span class="property">name</span>; <span class="comment">//已经自动变成json</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="请求超时与网络异常"><a href="#请求超时与网络异常" class="headerlink" title="请求超时与网络异常"></a>请求超时与网络异常</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超时设置 （2秒）</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">// 超时回调</span></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;网络超时，请稍后重试&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 网络异常回调</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;网络异常，请稍后重试&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动取消请求        </span></span><br><span class="line"><span class="comment">//network中的status中pending为等待中</span></span><br><span class="line"><span class="comment">//取消就变成cancel</span></span><br><span class="line">xhr.<span class="title function_">abort</span>()</span><br></pre></td></tr></table></figure>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="请求重复发送问题"><a href="#请求重复发送问题" class="headerlink" title="请求重复发送问题"></a>请求重复发送问题</h3><h3 id="解决-IE-缓存问题"><a href="#解决-IE-缓存问题" class="headerlink" title="解决 IE 缓存问题"></a>解决 IE 缓存问题</h3><p>问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。<br>解决方式：浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;/testAJAX?t=&quot;</span>+<span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br></pre></td></tr></table></figure></p>
<h2 id="Ajax请求状态"><a href="#Ajax请求状态" class="headerlink" title="Ajax请求状态"></a>Ajax请求状态</h2><p><code>xhr.readyState</code>可以用来查看请求当前的状态 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState">网址</a></p>
<ul>
<li>0: 表示XMLHttpRequest 实例已经生成，但是open()方法还没有被调用 </li>
<li>1: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息 </li>
<li>2: 表示send()方法已经执行，并且头信息和状态码已经收到 </li>
<li>3: 表示正在接收服务器传来的body 部分的数据 </li>
<li>4: 表示服务器数据已经完全接收，或者本次接收已经失败了<h2 id="API总结"><a href="#API总结" class="headerlink" title="API总结"></a>API总结</h2></li>
<li><code>XMLHttpRequest()</code>：创建 XHR 对象的构造函数 </li>
<li><code>status</code>：响应状态码值，如 200、404 </li>
<li><code>statusText</code>：响应状态文本，如 ’ok‘、‘not found’ </li>
<li><code>readyState</code>：标识请求状态的只读属性 0-1-2-3-4 </li>
<li><code>onreadystatechange</code>：绑定 readyState 改变的监听 </li>
<li><code>responseType</code>：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应 </li>
<li><code>response</code>：响应体数据，类型取决于 responseType 的指定 </li>
<li><code>timeout</code>：指定请求超时时间，默认为 0 代表没有限制 </li>
<li><code>ontimeout</code>：绑定超时的监听 </li>
<li><code>onerror</code>：绑定请求网络错误的监听 </li>
<li><code>open()</code>：初始化一个请求，参数为：(method, url[, async])</li>
<li><code>send(data)</code>：发送请求 </li>
<li><code>abort()</code>：中断请求 （发出到返回之间）</li>
<li><code>getResponseHeader(name)</code>：获取指定名称的响应头值 </li>
<li><code>getAllResponseHeaders()</code>：获取所有响应头组成的字符串 </li>
<li><code>setRequestHeader(name, value)</code>：设置请求头</li>
</ul>
<h1 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h1><h2 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(url, [data], [callback], [type])</span><br></pre></td></tr></table></figure>
<p>url:请求的URL 地址<br>data:请求携带的参数<br>callback:载入成功时回调函数<br>type:设置返回内容格式，xml, html, script, json, text, _default</p>
<h2 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">post</span>(url, [data], [callback], [type])</span><br></pre></td></tr></table></figure>
<p>url:请求的URL 地址<br>data:请求携带的参数<br>callback:载入成功时回调函数<br>type:设置返回内容格式，xml, html, script, json, text, _default</p>
<h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">	<span class="comment">// url</span></span><br><span class="line">	<span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>,</span><br><span class="line">	<span class="comment">// 参数</span></span><br><span class="line">	<span class="attr">data</span>: &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;,</span><br><span class="line">	<span class="comment">// 请求类型</span></span><br><span class="line">	<span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">	<span class="comment">// 响应体结果</span></span><br><span class="line">	<span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">	<span class="comment">// 成功的回调</span></span><br><span class="line">	<span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;,</span><br><span class="line">	<span class="comment">// 超时时间</span></span><br><span class="line">	<span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">	<span class="comment">// 失败的回调</span></span><br><span class="line">	<span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出错拉~&#x27;</span>);&#125;,</span><br><span class="line">	<span class="comment">// 头信息</span></span><br><span class="line">	<span class="attr">headers</span>: &#123;</span><br><span class="line">		<span class="attr">c</span>: <span class="number">300</span>,</span><br><span class="line">		<span class="attr">d</span>: <span class="number">400</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="跨越"><a href="#跨越" class="headerlink" title="跨越"></a>跨越</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略(Same-Origin Policy)最早由Netscape 公司提出，是浏览器的一种安全策略<br>同源： 协议、域名、端口号必须完全相同<br>跨域： 违背同源策略就是跨域</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP(JSON with Padding)，是一个非官方的跨域解决方案，只支持get 请求</p>
<p>在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用script 标签的跨域能力来发送请求的</p>
<p>使用：</p>
<ol>
<li><p>动态的创建一个script 标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置script 的src，设置回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">script.<span class="property">src</span> = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">abc</span>(<span class="params">data</span>) &#123;</span><br><span class="line">	<span class="title function_">alert</span>(data.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将script 添加到body 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器中路由的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/testAJAX&quot;</span> , <span class="keyword">function</span> (<span class="params">req , res</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> callback = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;</span><br><span class="line">		<span class="attr">name</span>:<span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">		<span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">	&#125;</span><br><span class="line">	res.<span class="title function_">send</span>(callback+<span class="string">&quot;(&quot;</span>+<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj)+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery 中的JSONP</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./jquery-1.12.3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">				<span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">				btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">					$.<span class="title function_">getJSON</span>(<span class="string">&quot;http://api.douban.com/v2/movie/in_theaters?callback=?&quot;</span>,<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">						<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">						<span class="comment">//获取所有的电影的条目</span></span></span><br><span class="line"><span class="language-javascript">						<span class="keyword">var</span> subjects = data.<span class="property">subjects</span>;</span></span><br><span class="line"><span class="language-javascript">						<span class="comment">//遍历电影条目</span></span></span><br><span class="line"><span class="language-javascript">						<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;subjects.<span class="property">length</span> ; i++)&#123;</span></span><br><span class="line"><span class="language-javascript">							$(<span class="string">&quot;#list&quot;</span>).<span class="title function_">append</span>(<span class="string">&quot;&lt;li&gt;&quot;</span>+</span></span><br><span class="line"><span class="language-javascript">							subjects[i].<span class="property">title</span>+<span class="string">&quot;&lt;br /&gt;&quot;</span>+</span></span><br><span class="line"><span class="language-javascript">							<span class="string">&quot;&lt;img src=\&quot;&quot;</span>+subjects[i].<span class="property">images</span>.<span class="property">large</span>+<span class="string">&quot;\&quot; &gt;&quot;</span>+</span></span><br><span class="line"><span class="language-javascript">							<span class="string">&quot;&lt;/li&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">						&#125;</span></span><br><span class="line"><span class="language-javascript">					&#125;);</span></span><br><span class="line"><span class="language-javascript">				&#125;</span></span><br><span class="line"><span class="language-javascript">			&#125;</span></span><br><span class="line"><span class="language-javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">HTTP</a><br>CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p>
<p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行</p>
<p>使用：<br><strong>服务器端的设置</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/testAJAX&quot;</span> , <span class="keyword">function</span> (<span class="params">req , res</span>) &#123;</span><br><span class="line">	<span class="comment">//通过res 来设置响应头，来允许跨域请求</span></span><br><span class="line">	<span class="comment">//res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;);</span></span><br><span class="line">	res.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">	res.<span class="title function_">send</span>(<span class="string">&quot;testAJAX 返回的响应&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Django</title>
    <url>/post/c0eb71d0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Git</title>
    <url>/post/69c3279c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/post/66c016fb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h1><h2 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h2><h3 id="JVM简介"><a href="#JVM简介" class="headerlink" title="JVM简介"></a>JVM简介</h3><p><strong>JVM：跨语言的平台</strong></p>
<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p>
<p>通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序</p>
<p>Java虚拟机不关心运行在其内部的程序到底是使用何种编程语言编写的，只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行</p>
<p><strong>字节码</strong></p>
<p>java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息</p>
<p><strong>多语言混合编程</strong></p>
<p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展</p>
<h3 id="虚拟机和Java虚拟机"><a href="#虚拟机和Java虚拟机" class="headerlink" title="虚拟机和Java虚拟机"></a>虚拟机和Java虚拟机</h3><ul>
<li><p>虚拟机</p>
<p>虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li><p>Visual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</p>
</li>
<li><p>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令</p>
</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
</li>
<li><p>Java虚拟机</p>
<ul>
<li><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
</li>
<li><p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
</li>
<li><p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p>
</li>
</ul>
<p>作用：Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p>特点</p>
<ul>
<li><p>一次编译，到处运行</p>
</li>
<li><p>自动内存管理</p>
</li>
<li><p>自动垃圾回收功能</p>
</li>
</ul>
<p><strong>JVM位置</strong></p>
<p><img src="JVM/%E4%B8%8A%E7%AF%87/JVM%E4%B8%8A%E7%AF%87%E9%85%8D%E5%9B%BE/JVM%E4%B8%8A%E7%AF%87%E9%85%8D%E5%9B%BE/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg" alt></p>
<p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Fvectorx%2FImageCloud%2Fraw%2Fmaster%2Fimg%2F20210507104032.png&amp;sign=4b2cf1c3010337729dcbe08881ea0723bb28a377b38c0994fd89bfff0d55212a" alt></p>
</li>
</ul>
<h3 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h3><p><img src="JVM/%E4%B8%8A%E7%AF%87/JVM%E4%B8%8A%E7%AF%87%E9%85%8D%E5%9B%BE/JVM%E4%B8%8A%E7%AF%87%E9%85%8D%E5%9B%BE/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt></p>
<h3 id="Java执行流程"><a href="#Java执行流程" class="headerlink" title="Java执行流程"></a>Java执行流程</h3><p><img src="https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Fvectorx%2FImageCloud%2Fraw%2Fmaster%2Fimg%2F20210507124722.png&amp;sign=8f4e06b2070a3b3396eea3e796e011a815a034de378a9370f9564b9f850b527d" alt></p>
<h3 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h3><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构</p>
<ul>
<li><p>基于栈的指令集架构</p>
<ul>
<li><p>设计和实现更简单，适用于资源受限的系统</p>
</li>
<li><p>避开了寄存器的分配难题：使用零地址指令方式分配</p>
</li>
<li><p>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</p>
</li>
<li><p>不需要硬件支持，可移植性更好，更好实现跨平台</p>
</li>
</ul>
</li>
<li><p>基于寄存器的指令集架构</p>
<ul>
<li><p>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</p>
</li>
<li><p>指令集架构则完全依赖硬件，可移植性差</p>
</li>
<li><p>性能优秀和执行更高效</p>
</li>
<li><p>花费更少的指令去完成一项操作</p>
</li>
<li><p>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</p>
</li>
</ul>
</li>
</ul>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</p>
<h3 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h3><ul>
<li><p>启动</p>
<p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的</p>
</li>
<li><p>执行</p>
<p>程序开始执行时他才运行，程序结束时他就停止</p>
<p>执行一个Java程序，正在执行的是Java虚拟机的进程</p>
</li>
<li><p>退出</p>
<ul>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p>
</li>
<li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</p>
</li>
<li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况</p>
</li>
</ul>
</li>
</ul>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="JVM/%E4%B8%8A%E7%AF%87/JVM%E4%B8%8A%E7%AF%87%E9%85%8D%E5%9B%BE/JVM%E4%B8%8A%E7%AF%87%E9%85%8D%E5%9B%BE/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD.jpg" alt></p>
<h3 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h3><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载</p>
<h4 id="自带类加载器"><a href="#自带类加载器" class="headerlink" title="自带类加载器"></a>自带类加载器</h4><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
<ul>
<li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p>
</li>
<li><p>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p>
</li>
<li><p>并不继承自ava.lang.ClassLoader，没有父加载器。</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>派生于ClassLoader类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
</li>
</ul>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<ul>
<li><p>java语言编写，由sun.misc.LaunchersAppClassLoader实现</p>
</li>
<li><p>派生于ClassLoader类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p>
</li>
<li><p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p>
</li>
<li><p>通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p>
</li>
</ul>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>原因：</p>
<ul>
<li><p>隔离加载类</p>
</li>
<li><p>修改类加载的方式</p>
</li>
<li><p>扩展加载源</p>
</li>
<li><p>防止源码泄漏</p>
</li>
</ul>
<p>用户自定义类加载器实现步骤：</p>
<ol>
<li>开发人员可以通过继承抽象类ava.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass() 方法，而是建议把自定义的类加载逻辑写在findClass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()  方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><code>ClassLoader</code></h3><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h2 id="运行时数据区及程序计数器"><a href="#运行时数据区及程序计数器" class="headerlink" title="运行时数据区及程序计数器"></a>运行时数据区及程序计数器</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h4 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h4><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h2 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h2 id="对象实例化及执行内存"><a href="#对象实例化及执行内存" class="headerlink" title="对象实例化及执行内存"></a>对象实例化及执行内存</h2><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h2 id="SpringTable"><a href="#SpringTable" class="headerlink" title="SpringTable"></a>SpringTable</h2><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="概述及算法"><a href="#概述及算法" class="headerlink" title="概述及算法"></a>概述及算法</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h1 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h1><h1 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/post/aa55683f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/post/8fe47ff4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JDBC技术概述"><a href="#JDBC技术概述" class="headerlink" title="JDBC技术概述"></a>JDBC技术概述</h1><p>JDBC是(Java Database Connectivity)单词的缩写,翻译为java连接数据库，在Java代码中,使用JDBC提供的方法,可以发送字符串类型的SQL语句到数据库管理软件(MySQL,Oracle等),并且获取语句执行结果，进而实现数据库数据CURD操作的技术</p>
<p>JDBC是java程序连接数据库的技术统称</p>
<p>JDBC由java语言的规范(接口)和各个数据库厂商的实现驱动(jar)组成</p>
<p><strong>JDBC是一种典型的面向接口编程</strong></p>
<p>优势：</p>
<ol>
<li>只需要学习jdbc规范接口的方法,即可操作<strong>所有的数据库软件</strong></li>
<li>项目中期切换数据库软件,只需要更换对应的数据库驱动jar包,不需要更改代码</li>
</ol>
<p>技术组成：</p>
<ol>
<li><p>jdk下jdbc规范接口, 存储在java.sql和javax.sql包中的api</p>
<blockquote>
<p>为了项目代码的可移植性，可维护性，SUN公司从最初就制定了Java程序连接各种数据库的统一<strong>接口规范</strong>。这样的话，不管是连接哪一种DBMS软件，Java代码可以保持一致性。</p>
</blockquote>
</li>
<li><p>各个数据库厂商提供的驱动jar包</p>
<blockquote>
<p>因为各个数据库厂商的DBMS软件各有不同，那么内部如何通过sql实现增、删、改、查等管理数据，只有这个数据库厂商自己更清楚，因此把接口规范的实现交给各个数据库厂商自己实现。</p>
</blockquote>
<p>jar包是什么?</p>
<blockquote>
<p>java程序打成的一种压缩包格式，你可以将这些jar包引入你的项目中，然后你可以使用这个java程序中类和方法以及属性了!</p>
</blockquote>
</li>
</ol>
<p>涉及具体核心类和接口：</p>
<ul>
<li><strong>DriverManager</strong><ol>
<li>将第三方数据库厂商的实现驱动jar注册到程序中</li>
<li>可以根据数据库连接信息获取connection</li>
</ol>
</li>
<li><strong>Connection</strong><ul>
<li>和数据库建立的连接,在连接对象上,可以多次执行数据库curd动作</li>
<li>可以获取statement和 preparedstatement,callablestatement对象</li>
</ul>
</li>
<li><strong>Statement | ==PreparedStatement== | CallableStatement</strong><ul>
<li>具体发送SQL语句到数据库管理软件的对象</li>
<li>不同发送方式稍有不同</li>
</ul>
</li>
<li><strong>Result</strong><ul>
<li><strong>面向对象思维的产物</strong>(抽象成数据库的查询结果表)</li>
<li>存储DQL查询数据库结果的对象</li>
<li>需要我们进行解析,获取具体的数据库数据</li>
</ul>
</li>
</ul>
<p>JDBC API使用路线：</p>
<ul>
<li>静态SQL路线(没有动态值语句)<ul>
<li>DriverManager<ul>
<li>Connection<ul>
<li>Statement<ul>
<li>Result</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>预编译SQL路线(有动态值语句)<ul>
<li>DriverManager<ul>
<li>Connection<ul>
<li>PreparedStatement<ul>
<li>Result</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>执行标准存储过SQL路线<ul>
<li>DriverManager<ul>
<li>Collection<ul>
<li>CallableStatement<ul>
<li>Result</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JDBC核心API"><a href="#JDBC核心API" class="headerlink" title="JDBC核心API"></a>JDBC核心API</h1><h2 id="引入mysql-jdbc驱动"><a href="#引入mysql-jdbc驱动" class="headerlink" title="引入mysql-jdbc驱动"></a>引入mysql-jdbc驱动</h2><ol>
<li>驱动jar版本选择（版本 8.0.27版）</li>
<li>Java工程导入依赖<ol>
<li>项目创建lib文件夹</li>
<li>导入驱动依赖jar包</li>
<li>jar包右键-添加为项目依赖</li>
</ol>
</li>
</ol>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>注册驱动</li>
<li>获取连接</li>
<li>创建发送sql语句对象</li>
<li>发送sql语句，并获取返回结果</li>
<li>结果集解析</li>
<li>资源关闭</li>
</ol>
<h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><h3 id="演示查询"><a href="#演示查询" class="headerlink" title="演示查询"></a>演示查询</h3><h4 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigu;</span><br><span class="line"></span><br><span class="line">USE atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_user(</span><br><span class="line">   id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;用户主键&#x27;</span>,</span><br><span class="line">   account <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">   PASSWORD <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">   nickname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(account,PASSWORD,nickname) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;经理&#x27;</span>),(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;666666&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="实现查询"><a href="#实现查询" class="headerlink" title="实现查询"></a>实现查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *利用jdbc技术,完成用户数据查询工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 步骤总结 (6步)</span></span><br><span class="line"><span class="comment"> *    1. 注册驱动</span></span><br><span class="line"><span class="comment"> *    2. 获取连接</span></span><br><span class="line"><span class="comment"> *    3. 创建statement</span></span><br><span class="line"><span class="comment"> *    4. 发送SQL语句,并获取结果</span></span><br><span class="line"><span class="comment"> *    5. 结果集解析</span></span><br><span class="line"><span class="comment"> *    6. 关闭资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcBasePart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> 注意</span></span><br><span class="line"><span class="comment">         *   Driver -&gt; com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> 注意</span></span><br><span class="line"><span class="comment">         *   面向接口编程</span></span><br><span class="line"><span class="comment">         *   java.sql 接口 = 实现类</span></span><br><span class="line"><span class="comment">         *   connection 使用java.sql.Connection接口接收</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建小车</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.发送SQL语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,account,password,nickname from t_user ;&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span>  statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.结果集解析</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;account&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">nickname</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;nickname&quot;</span>);</span><br><span class="line">            System.out.println(id+<span class="string">&quot;::&quot;</span>+account+<span class="string">&quot;::&quot;</span>+password+<span class="string">&quot;::&quot;</span>+nickname);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭资源，先开后关</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方式问题"><a href="#方式问题" class="headerlink" title="方式问题"></a>方式问题</h3><h4 id="准备数据库-1"><a href="#准备数据库-1" class="headerlink" title="准备数据库"></a>准备数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigu;</span><br><span class="line"></span><br><span class="line">USE atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_user(</span><br><span class="line">   id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;用户主键&#x27;</span>,</span><br><span class="line">   account <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">   PASSWORD <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">   nickname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(account,PASSWORD,nickname) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;经理&#x27;</span>),(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;666666&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="实现模拟登录"><a href="#实现模拟登录" class="headerlink" title="实现模拟登录"></a>实现模拟登录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入账号密码,模拟用户登录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcStatementLoginPart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="comment">//1.输入账号和密码</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.jdbc的查询使用</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 类加载： java文件 -&gt; 编译 -&gt; 【 class字节码文件 --&gt;  类加载 --&gt; jvm虚拟中  --&gt; Class对象】</span></span><br><span class="line"><span class="comment">         * 类加载具体步骤：  加载 【class文件转成对象加载到虚拟机中】-&gt;</span></span><br><span class="line"><span class="comment">         *                连接 【验证（检查类文件） -&gt; 准备 (静态变量赋默认值) -&gt; 解析 (调用静态代码块) 】 -&gt;</span></span><br><span class="line"><span class="comment">         *                初始化 -&gt; (赋真实值)</span></span><br><span class="line"><span class="comment">         * 以下7种方式会触发类加载：</span></span><br><span class="line"><span class="comment">         *    1. new关键字</span></span><br><span class="line"><span class="comment">         *    2. 调用静态属性</span></span><br><span class="line"><span class="comment">         *    3. 调用静态方法</span></span><br><span class="line"><span class="comment">         *    4. 接口 包含1.8 新特性 default关键字</span></span><br><span class="line"><span class="comment">         *    5. 反射 【Class.forName() 类名.class】</span></span><br><span class="line"><span class="comment">         *    6. 子类调用会触发父类的静态代码块</span></span><br><span class="line"><span class="comment">         *    7. 触发类的入口方法main</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//注册一次驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写： 为了子类扩展父类的方法！父类也间接的规范了子类方法的参数和返回！</span></span><br><span class="line"><span class="comment">         * 重载： 重载一般应用在第三方的工具类上，为了方便用户多种方式传递参数形式！简化形式！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 三个参数：</span></span><br><span class="line"><span class="comment">         *    String URL: 连接数据库地址</span></span><br><span class="line"><span class="comment">         *    String user: 连接数据库用户名</span></span><br><span class="line"><span class="comment">         *    String password: 连接数据库用户对应的密码</span></span><br><span class="line"><span class="comment">         * 数据库URL语法：</span></span><br><span class="line"><span class="comment">         *    JDBC:</span></span><br><span class="line"><span class="comment">         *        ip port</span></span><br><span class="line"><span class="comment">         *        jdbc:mysql | jdbc:oracle :// 127.0.0.1 | localhost : 3306 / 数据库名</span></span><br><span class="line"><span class="comment">         *        jdbc:mysql://localhost:3306/day01</span></span><br><span class="line"><span class="comment">         *        192.168.33.45</span></span><br><span class="line"><span class="comment">         *        jdbc:mysql://192.168.33.45/3306/day01</span></span><br><span class="line"><span class="comment">         *        当前电脑的省略写法！ 注意：本机和端口3306</span></span><br><span class="line"><span class="comment">         *        jdbc:mysql://localhost:3306/day01 = jdbc:mysql:///day01</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 两个参数：</span></span><br><span class="line"><span class="comment">         *     String URL : 写法还是jdbc的路径写法！</span></span><br><span class="line"><span class="comment">         *     Properties : 就是一个参数封装容器！至少要包含 user / password key!存储连接账号信息！</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 一个参数：</span></span><br><span class="line"><span class="comment">         *    String URL: URl可以携带目标地址，可以通过?分割，在后面key=value&amp;key=value形式传递参数</span></span><br><span class="line"><span class="comment">         *                jdbc:mysql:///day01?user=root&amp;password=123456</span></span><br><span class="line"><span class="comment">         * 扩展路径参数(了解):</span></span><br><span class="line"><span class="comment">         *    serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//固定方法固定剂</span></span><br><span class="line">        <span class="comment">//创建statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行SQL语句 [动态SQL语句,需要字符串拼接]</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user where account = &#x27;&quot;</span>+account+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+password+<span class="string">&quot;&#x27; ;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  ResultSet 结果集对象 = executeQuery(DQL语句)</span></span><br><span class="line"><span class="comment">         *  int       响应行数  = executeUpdate(非DQL语句)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ResultSet == 小海豚  你必须有面向对象的思维：Java是面向对象编程的语言 OOP！</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span>1.需要理解ResultSet的数据结构和小海豚查询出来的是一样，需要在脑子里构建结果表！</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span>2.有一个光标指向的操作数据行，默认指向第一行的上边！我们需要移动光标，指向行，在获取列即可！</span></span><br><span class="line"><span class="comment">         *        boolean = next()</span></span><br><span class="line"><span class="comment">         *              false: 没有数据，也不移动了！</span></span><br><span class="line"><span class="comment">         *              true:  有更多行，并且移动到下一行！</span></span><br><span class="line"><span class="comment">         *       推荐：推荐使用if 或者 while循环，嵌套next方法，循环和判断体内获取数据！</span></span><br><span class="line"><span class="comment">         *       if(next())&#123;获取列的数据！&#125; ||  while(next())&#123;获取列的数据！&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *TODO：3.获取当前行列的数据！</span></span><br><span class="line"><span class="comment">         *         get类型(int columnIndex | String columnLabel)</span></span><br><span class="line"><span class="comment">         *        列名获取  //lable 如果没有别名，等于列名， 有别名label就是别名，他就是查询结果的标识！</span></span><br><span class="line"><span class="comment">         *        列的角标  //从左到右 从1开始！ 数据库全是从1开始！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行结果集对象解析</span></span><br><span class="line">        <span class="keyword">if</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="comment">//只要向下移动，就是有数据 就是登录成功！</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><ol>
<li><p>SQL语句需要字符串拼接,比较麻烦</p>
</li>
<li><p>只能拼接字符串类型,其他的数据库类型无法处理</p>
</li>
<li><p>可能发生注入攻击</p>
<p>动态值充当了SQL语句结构,影响了原有的查询结果</p>
</li>
</ol>
<h2 id="preparedStatement"><a href="#preparedStatement" class="headerlink" title="preparedStatement"></a>preparedStatement</h2><h3 id="方法优化"><a href="#方法优化" class="headerlink" title="方法优化"></a>方法优化</h3><p>利用preparedStatement解决上述案例注入攻击和SQL语句拼接问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用预编译Statement解决注入攻击问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcPreparedStatementLoginPart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.输入账号和密码</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.jdbc的查询使用</span></span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建preparedStatement</span></span><br><span class="line">        <span class="comment">//connection.createStatement();</span></span><br><span class="line">        <span class="comment">//TODO 需要传入SQL语句结构</span></span><br><span class="line">        <span class="comment">//TODO 要的是SQL语句结构，动态值的部分使用 ? ,  占位符！</span></span><br><span class="line">        <span class="comment">//TODO ?  不能加 &#x27;?&#x27;  ? 只能替代值，不能替代关键字和容器名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_user where account = ? and password = ? ;&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//占位符赋值</span></span><br><span class="line">        <span class="comment">//给占位符赋值！ 从左到右，从1开始！</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  int 占位符的下角标</span></span><br><span class="line"><span class="comment">         *  object 占位符的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        preparedStatement.setObject(<span class="number">2</span>,password);</span><br><span class="line">        preparedStatement.setObject(<span class="number">1</span>,account);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这哥们内部完成SQL语句拼接！</span></span><br><span class="line">        <span class="comment">//执行SQL语句即可</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">//preparedStatement.executeUpdate()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行结果集对象解析</span></span><br><span class="line">        <span class="keyword">if</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="comment">//只要向下移动，就是有数据 就是登录成功！</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="演示curd"><a href="#演示curd" class="headerlink" title="演示curd"></a>演示curd</h3><ul>
<li>数据库数据插入</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入一条用户数据!</span></span><br><span class="line"><span class="comment"> * 账号: test</span></span><br><span class="line"><span class="comment"> * 密码: test</span></span><br><span class="line"><span class="comment"> * 昵称: 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Test</span></span><br><span class="line">public void testInsert() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>注册驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>获取连接</span><br><span class="line">    Connection connection <span class="operator">=</span> DriverManager.getConnection(&quot;jdbc:mysql:///atguigu&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>TODO: 切记, ? 只能代替 值<span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span>  不能代替关键字 特殊符号 容器名</span><br><span class="line">    String <span class="keyword">sql</span> <span class="operator">=</span> &quot;insert into t_user(account,password,nickname) values (?,?,?);&quot;;</span><br><span class="line">    PreparedStatement preparedStatement <span class="operator">=</span> connection.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>占位符赋值</span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, &quot;test&quot;);</span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>, &quot;test&quot;);</span><br><span class="line">    preparedStatement.setString(<span class="number">3</span>, &quot;测试&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>发送<span class="keyword">SQL</span>语句</span><br><span class="line">    <span class="type">int</span> <span class="keyword">rows</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>输出结果</span><br><span class="line">    System.out.println(<span class="keyword">rows</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>关闭资源<span class="keyword">close</span></span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库数据修改</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改一条用户数据!</span></span><br><span class="line"><span class="comment"> * 修改账号: test的用户,将nickname改为tomcat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Test</span></span><br><span class="line">public void testUpdate() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>注册驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>获取连接</span><br><span class="line">    Connection connection <span class="operator">=</span> DriverManager.getConnection(&quot;jdbc:mysql:///atguigu&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>TODO: 切记, ? 只能代替 值<span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span>  不能代替关键字 特殊符号 容器名</span><br><span class="line">    String <span class="keyword">sql</span> <span class="operator">=</span> &quot;update t_user set nickname = ? where account = ? ;&quot;;</span><br><span class="line">    PreparedStatement preparedStatement <span class="operator">=</span> connection.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>占位符赋值</span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, &quot;tomcat&quot;);</span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>发送<span class="keyword">SQL</span>语句</span><br><span class="line">    <span class="type">int</span> <span class="keyword">rows</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>输出结果</span><br><span class="line">    System.out.println(<span class="keyword">rows</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>关闭资源<span class="keyword">close</span></span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库数据删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一条用户数据!</span></span><br><span class="line"><span class="comment"> * 根据账号: test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Test</span></span><br><span class="line">public void testDelete() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>注册驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>获取连接</span><br><span class="line">    Connection connection <span class="operator">=</span> DriverManager.getConnection(&quot;jdbc:mysql:///atguigu&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>TODO: 切记, ? 只能代替 值<span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span>  不能代替关键字 特殊符号 容器名</span><br><span class="line">    String <span class="keyword">sql</span> <span class="operator">=</span> &quot;delete from t_user where account = ? ;&quot;;</span><br><span class="line">    PreparedStatement preparedStatement <span class="operator">=</span> connection.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>占位符赋值</span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>发送<span class="keyword">SQL</span>语句</span><br><span class="line">    <span class="type">int</span> <span class="keyword">rows</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>输出结果</span><br><span class="line">    System.out.println(<span class="keyword">rows</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>关闭资源<span class="keyword">close</span></span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据库数据查询</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询全部数据!</span></span><br><span class="line"><span class="comment"> *   将数据存到List&lt;Map&gt;中</span></span><br><span class="line"><span class="comment"> *   map -&gt; 对应一行数据</span></span><br><span class="line"><span class="comment"> *      map key -&gt; 数据库列名或者别名</span></span><br><span class="line"><span class="comment"> *      map value -&gt; 数据库列的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 思路分析</span></span><br><span class="line"><span class="comment"> *    1.先创建一个List&lt;Map&gt;集合</span></span><br><span class="line"><span class="comment"> *    2.遍历resultSet对象的行数据</span></span><br><span class="line"><span class="comment"> *    3.将每一行数据存储到一个map对象中!</span></span><br><span class="line"><span class="comment"> *    4.将对象存到List&lt;Map&gt;中</span></span><br><span class="line"><span class="comment"> *    5.最终返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment"> *    初体验,结果存储!</span></span><br><span class="line"><span class="comment"> *    学习获取结果表头信息(列名和数量等信息)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Test</span></span><br><span class="line">public void testQueryMap() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>注册驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>获取连接</span><br><span class="line">    Connection connection <span class="operator">=</span> DriverManager.getConnection(&quot;jdbc:mysql:///atguigu&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>TODO: 切记, ? 只能代替 值<span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span><span class="operator">!</span>  不能代替关键字 特殊符号 容器名</span><br><span class="line">    String <span class="keyword">sql</span> <span class="operator">=</span> &quot;select id,account,password,nickname from t_user ;&quot;;</span><br><span class="line">    PreparedStatement preparedStatement <span class="operator">=</span> connection.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>占位符赋值 本次没有占位符,省略</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>发送查询语句</span><br><span class="line">    ResultSet resultSet <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>创建一个集合</span><br><span class="line">    List<span class="operator">&lt;</span>Map<span class="operator">&gt;</span> mapList <span class="operator">=</span> <span class="keyword">new</span> ArrayList<span class="operator">&lt;&gt;</span>();</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>获取列信息对象</span><br><span class="line">    ResultSetMetaData metaData <span class="operator">=</span> resultSet.getMetaData();</span><br><span class="line">    <span class="type">int</span> columnCount <span class="operator">=</span> metaData.getColumnCount();</span><br><span class="line">    while (resultSet.next()) &#123;</span><br><span class="line">        Map map <span class="operator">=</span> <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">1</span>; i <span class="operator">&lt;=</span> columnCount; i<span class="operator">+</span><span class="operator">+</span>) &#123;</span><br><span class="line">            map.put(metaData.getColumnLabel(i), resultSet.getObject(i));</span><br><span class="line">        &#125;</span><br><span class="line">        mapList.add(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(mapList);</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>关闭资源<span class="keyword">close</span></span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">    resultSet.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用方式总结"><a href="#使用方式总结" class="headerlink" title="使用方式总结"></a>使用方式总结</h3><ul>
<li><p>步骤</p>
<ol>
<li>注册驱动</li>
<li>获取连接</li>
<li>编写SQL语句</li>
<li>创建preparedstatement并且传入SQL语句结构</li>
<li>占位符赋值</li>
<li>发送SQL语句,并且获取结果</li>
<li>结果集解析</li>
<li>关闭资源</li>
</ol>
</li>
<li><p>API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动</span></span><br><span class="line"><span class="comment">//方案1: 调用静态方法,但是会注册两次</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">com</span>.mysql.cj.jdbc.Driver());</span><br><span class="line"><span class="comment">//方案2: 反射触发</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"></span><br><span class="line">(String url,String user,String password)</span><br><span class="line">(String url,Properties <span class="title function_">info</span><span class="params">(user password)</span>)</span><br><span class="line">(String url?user=账号&amp;password=密码 )</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建statement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="comment">//预编译</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedstatement</span> <span class="operator">=</span> connection.preparedStatement(sql语句结构);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.占位符赋值</span></span><br><span class="line">preparedstatement.setObject(?的位置 从左到右 从<span class="number">1</span>开始,值)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.发送sql语句获取结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> executeUpdate(); <span class="comment">//非DQL</span></span><br><span class="line">Resultset = executeQuery(); <span class="comment">//DQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.查询结果集解析</span></span><br><span class="line"><span class="comment">//移动光标指向行数据 next();  if(next())  while(next())</span></span><br><span class="line"><span class="comment">//获取列的数据即可   get类型(int 列的下角标 从1开始 | int 列的label (别名或者列名))</span></span><br><span class="line"><span class="comment">//获取列的信息   getMetadata(); ResultsetMetaData对象 包含的就是列的信息</span></span><br><span class="line">                getColumnCount(); | getCloumnLebal(index)</span><br><span class="line"><span class="comment">//7.关闭资源</span></span><br><span class="line">close(); </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JDBC拓展提升"><a href="#JDBC拓展提升" class="headerlink" title="JDBC拓展提升"></a>JDBC拓展提升</h1><h2 id="自增长主键回显实现"><a href="#自增长主键回显实现" class="headerlink" title="自增长主键回显实现"></a>自增长主键回显实现</h2><p>功能需求</p>
<ol>
<li><strong>java程序</strong>获取<strong>插入</strong>数据时mysql维护<strong>自增长</strong>维护的主键<strong>id值</strong>,这就是主键回显</li>
<li>作用: 在多表关联插入数据时,一般主表的主键都是自动生成的,所以在插入数据之前无法知道这条数据的主键,但是从表需要在插入数据之前就绑定主表的主键,这是可以使用主键回显技术:</li>
</ol>
<p>功能实现</p>
<ul>
<li>继续沿用之前的表数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回插入的主键！</span></span><br><span class="line"><span class="comment"> * 主键：数据库帮助维护的自增长的整数主键！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">returnPrimaryKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//2.获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///atguigu?user=root&amp;password=root&quot;</span>);</span><br><span class="line">    <span class="comment">//3.编写SQL语句结构</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_user (account,password,nickname) values (?,?,?);&quot;</span>;</span><br><span class="line">    <span class="comment">//4.创建预编译的statement，传入SQL语句结构</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS</span></span><br><span class="line"><span class="comment">     *       告诉statement携带回数据库生成的主键！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">    <span class="comment">//5.占位符赋值</span></span><br><span class="line">    statement.setObject(<span class="number">1</span>,<span class="string">&quot;towgog&quot;</span>);</span><br><span class="line">    statement.setObject(<span class="number">2</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    statement.setObject(<span class="number">3</span>,<span class="string">&quot;二狗子&quot;</span>);</span><br><span class="line">    <span class="comment">//6.执行SQL语句 【注意：不需要传入SQL语句】 DML</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate();</span><br><span class="line">    <span class="comment">//7.结果集解析</span></span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一行一列的数据！里面就装主键值！</span></span><br><span class="line">      <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.getGeneratedKeys();</span><br><span class="line">    resultSet.next();</span><br><span class="line">    <span class="type">int</span> <span class="variable">anInt</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;anInt = &quot;</span> + anInt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.释放资源</span></span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="批量数据插入性能提升"><a href="#批量数据插入性能提升" class="headerlink" title="批量数据插入性能提升"></a>批量数据插入性能提升</h2><p>功能需求</p>
<ol>
<li>批量数据插入优化</li>
<li>提升大量数据插入效率</li>
</ol>
<p>功能实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 批量细节：</span></span><br><span class="line"><span class="comment"> *    1.url?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="comment"> *    2.insert 语句必须使用 values</span></span><br><span class="line"><span class="comment"> *    3.语句后面不能添加分号;</span></span><br><span class="line"><span class="comment"> *    4.语句不能直接执行，每次需要装货  addBatch() 最后 executeBatch();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 批量插入优化！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">batchInsertYH</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//2.获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///atguigu?rewriteBatchedStatements=true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    <span class="comment">//3.编写SQL语句结构</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_user (account,password,nickname) values (?,?,?)&quot;</span>;</span><br><span class="line">    <span class="comment">//4.创建预编译的statement，传入SQL语句结构</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS</span></span><br><span class="line"><span class="comment">     *       告诉statement携带回数据库生成的主键！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.占位符赋值</span></span><br><span class="line">        statement.setObject(<span class="number">1</span>,<span class="string">&quot;ergouzi&quot;</span>+i);</span><br><span class="line">        statement.setObject(<span class="number">2</span>,<span class="string">&quot;lvdandan&quot;</span>);</span><br><span class="line">        statement.setObject(<span class="number">3</span>,<span class="string">&quot;驴蛋蛋&quot;</span>+i);</span><br><span class="line">        <span class="comment">//6.装车</span></span><br><span class="line">        statement.addBatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发车！ 批量操作！</span></span><br><span class="line">    statement.executeBatch();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;消耗时间：&quot;</span>+(end - start));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.结果集解析</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.释放资源</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jdbc中数据库事务实现"><a href="#jdbc中数据库事务实现" class="headerlink" title="jdbc中数据库事务实现"></a>jdbc中数据库事务实现</h2><p>事务概念回顾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务概念</span></span><br><span class="line">   数据库事务就是一种SQL语句执行的缓存机制,不会单条执行完毕就更新数据库数据,最终根据缓</span><br><span class="line">   存内的多条语句执行结果统一判定!</span><br><span class="line">   一个事务内所有语句都成功及事务成功,我们可以触发commit提交事务来结束事务,更新数据!</span><br><span class="line">   一个事务内任意一条语句失败,及事务失败,我们可以触发rollback回滚结束事务,</span><br><span class="line">   数据回到事务之前状态!</span><br><span class="line">   </span><br><span class="line">   举个例子: </span><br><span class="line">           临近高考,你好吃懒做,偶尔还瞎花钱,父母也只会说<span class="string">&#x27;你等着!&#x27;</span>,待到高考完毕!</span><br><span class="line">           成绩<span class="number">600</span>+,翻篇,庆祝!</span><br><span class="line">           成绩<span class="number">200</span>+,翻旧账,男女混合双打!</span><br><span class="line">           </span><br><span class="line"><span class="comment">//优势</span></span><br><span class="line">   允许我们在失败情况下,数据回归到业务之前的状态! </span><br><span class="line">   </span><br><span class="line"><span class="comment">//场景</span></span><br><span class="line">   **一个业务****涉及****多条修改****数据库语句!**</span><br><span class="line">   例如: 经典的转账案例,转账业务(加钱和减钱)   </span><br><span class="line">         批量删除(涉及多个删除)</span><br><span class="line">         批量添加(涉及多个插入)     </span><br><span class="line">         </span><br><span class="line"><span class="comment">// 事务特性</span></span><br><span class="line">  <span class="number">1.</span> 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </span><br><span class="line"></span><br><span class="line">  <span class="number">2.</span> 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</span><br><span class="line"></span><br><span class="line">  <span class="number">3.</span> 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</span><br><span class="line"></span><br><span class="line">  <span class="number">4.</span> 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务类型</span></span><br><span class="line">  </span><br><span class="line">  自动提交 : 每条语句自动存储一个事务中,执行成功自动提交,执行失败自动回滚! (MySQL)</span><br><span class="line">  手动提交:  手动开启事务,添加语句,手动提交或者手动回滚即可!</span><br><span class="line">  </span><br><span class="line"><span class="comment">// sql开启事务方式</span></span><br><span class="line">   针对自动提交: 关闭自动提交即可,多条语句添加以后,最终手动提交或者回滚! (推荐)</span><br><span class="line">     </span><br><span class="line">      <span class="type">SET</span> <span class="variable">autocommit</span> <span class="operator">=</span> off; <span class="comment">//关闭当前连接自动事务提交方式</span></span><br><span class="line">      # 只有当前连接有效</span><br><span class="line">      # 编写SQL语句即可</span><br><span class="line">      SQL</span><br><span class="line">      SQL</span><br><span class="line">      SQL</span><br><span class="line">      #手动提交或者回滚 【结束当前的事务】</span><br><span class="line">      COMMIT / ROLLBACK ;  </span><br><span class="line">     </span><br><span class="line">   手动开启事务: 开启事务代码,添加SQL语句,事务提交或者事务回滚! (不推荐)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呼应jdbc技术</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>); <span class="comment">//关闭自动提交了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意,只要当前connection对象,进行数据库操作,都不会自动提交事务</span></span><br><span class="line">    <span class="comment">//数据库动作!</span></span><br><span class="line">    <span class="comment">//statement - 单一的数据库动作 c u r d </span></span><br><span class="line">    </span><br><span class="line">    connection.commit();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Execption e)&#123;</span><br><span class="line">    connection.rollback();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>数据库表数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 继续在atguigu的库中创建银行表</span><br><span class="line">CREATE TABLE <span class="title function_">t_bank</span><span class="params">(</span></span><br><span class="line"><span class="params">   id INT PRIMARY KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;账号主键&#x27;</span>,</span></span><br><span class="line"><span class="params">   account VARCHAR(<span class="number">20</span>)</span> NOT NULL UNIQUE COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">   money  INT UNSIGNED COMMENT <span class="string">&#x27;金额,不能为负值&#x27;</span>) ;</span><br><span class="line">   </span><br><span class="line">INSERT INTO <span class="title function_">t_bank</span><span class="params">(account,money)</span> VALUES</span><br><span class="line">  (<span class="string">&#x27;ergouzi&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;lvdandan&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>代码结构设计</p>
<p><img src="https://secure2.wostatic.cn/static/7QeuxBUzVCE95CkyP4sZov/image.png?auth_key=1674826135-gj5MwPoMNXuar8skF2PYmb-0-0fa1d06a1f231dbb56373d22ff61e92a&amp;image_process=resize,w_1423&amp;file_size=79654" alt="img"></p>
<p>jdbc事务实现</p>
<ul>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBank</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BankService</span> <span class="variable">bankService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankService</span>();</span><br><span class="line">        bankService.transfer(<span class="string">&quot;ergouzi&quot;</span>, <span class="string">&quot;lvdandan&quot;</span>,</span><br><span class="line">                <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>BankService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bank表业务类,添加转账业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账业务方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addAccount  加钱账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subAccount  减钱账号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money  金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String addAccount,String subAccount, <span class="type">int</span> money)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;addAccount = &quot;</span> + addAccount + <span class="string">&quot;, subAccount = &quot;</span> + subAccount + <span class="string">&quot;, money = &quot;</span> + money);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用try代码块,调用dao</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启事务(关闭事务自动提交)</span></span><br><span class="line">            connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">BankDao</span> <span class="variable">bankDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankDao</span>();</span><br><span class="line">            <span class="comment">//调用加钱 和 减钱</span></span><br><span class="line">            bankDao.addMoney(addAccount,money,connection);</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">            bankDao.subMoney(subAccount,money,connection);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//不报错,提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//报错回滚事务</span></span><br><span class="line">            connection.rollback();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;转账成功!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;转账失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>BankDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库访问dao类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加钱方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection 业务传递的connection和减钱是同一个! 才可以在一个事务中!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addMoney</span><span class="params">(String account, <span class="type">int</span> money,Connection connection)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money + ? where account = ? ;&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//占位符赋值</span></span><br><span class="line">        preparedStatement.setObject(<span class="number">1</span>, money);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, account);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;加钱执行完毕!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源close</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减钱方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection 业务传递的connection和加钱是同一个! 才可以在一个事务中!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subMoney</span><span class="params">(String account, <span class="type">int</span> money,Connection connection)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money - ? where account = ? ;&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//占位符赋值</span></span><br><span class="line">        preparedStatement.setObject(<span class="number">1</span>, money);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, account);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;减钱执行完毕!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源close</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)。它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个;<br>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。</p>
<p>好处：资源重用。 提升系统响应速度。避免数据库连接遗漏。</p>
<p>数据库连接池实现<br>标准接口:DataSource<br>官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。</p>
<p>功能:获取连接<br>Connection getConnection()<br>常见的数据库连接池:DBCP、C3Po、Druid</p>
<p>Druid连接池是阿里巴巴开源的数据库连接池项目<br>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p>
<p>Driud使用步骤</p>
<ol>
<li><p>导入jar包druid-1.1.12.jar</p>
</li>
<li><p>定义配置文件.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span><br><span class="line">username=root</span><br><span class="line">password=1234</span><br><span class="line"># 初始化连接数量</span><br><span class="line">initialSize=5</span><br><span class="line"># 最大连接数</span><br><span class="line">maxActive=10</span><br><span class="line"># 最大等待时间</span><br><span class="line">maxWait=3000</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载配置文件</p>
</li>
<li><p>获取数据库连接池对象</p>
</li>
<li><p>获取连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.导入jar包druid-1.1.12.jar</span></span><br><span class="line"><span class="comment">//2．定义配置文件.properties</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3．加载配置文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/druid.properties&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4．获取数据库连接池对象</span></span><br><span class="line">DataSource dataSource=DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5．获取连接</span></span><br><span class="line">Connection conn=dataSource.getConnection();</span><br><span class="line">System.out.println(conn);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>数据库连接池作用</p>
<p>缺点：<br>（1）不使用数据库连接池，每次都通过DriverManager获取新连接，用完直接抛弃断开，<br>连接的利用率太低，太浪费。<br>（2）对于数据库服务器来说，压力太大了。我们数据库服务器和Java程序对连接数也无法控制<br>，很容易导致数据库服务器崩溃。</p>
<p>我们就希望能管理连接。</p>
<ul>
<li>我们可以建立一个连接池，这个池中可以容纳一定数量的连接对象，一开始，<br>我们可以先替用户先创建好一些连接对象，等用户要拿连接对象时，就直接从池中拿，<br>不用新建了，这样也可以节省时间。然后用户用完后，放回去，别人可以接着用。</li>
<li>可以提高连接的使用率。当池中的现有的连接都用完了，那么连接池可以向服务器申<br>请新的连接放到池中。</li>
<li>直到池中的连接达到“最大连接数”，就不能在申请新的连接了，如果没有拿到连接的用户只能等待。</li>
</ul>
<p>常见连接池的对比</p>
<p>mock性能数据（单位：ms）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>5</th>
<th>20</th>
<th>50</th>
<th>100</th>
</tr>
</thead>
<tbody>
<tr>
<td>tomcat-jdbc</td>
<td>442</td>
<td>447</td>
<td>1013</td>
<td>1264</td>
</tr>
<tr>
<td>c3p0</td>
<td>4480</td>
<td>5527</td>
<td>7449</td>
<td>10725</td>
</tr>
<tr>
<td>dbcp</td>
<td>676</td>
<td>689</td>
<td>867</td>
<td>1292</td>
</tr>
<tr>
<td>hikari</td>
<td>38</td>
<td>33</td>
<td>38</td>
<td>30</td>
</tr>
<tr>
<td>druid</td>
<td>291</td>
<td>293</td>
<td>562</td>
<td>985</td>
</tr>
</tbody>
</table>
</div>
<p>功能对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>dbcp</th>
<th>druid</th>
<th>c3p0</th>
<th>tomcat-jdbc</th>
<th>HikariCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否支持PSCache</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>监控</td>
<td>jmx</td>
<td>jmx/log/http</td>
<td>jmx，log</td>
<td>jmx</td>
<td>jmx</td>
</tr>
<tr>
<td>拓展性</td>
<td>弱</td>
<td>好</td>
<td>弱</td>
<td>弱</td>
<td>弱</td>
</tr>
<tr>
<td>sql拦截及解析</td>
<td>无</td>
<td>支持</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>代码</td>
<td>简单</td>
<td>中等</td>
<td>复杂</td>
<td>简单</td>
<td>简单</td>
</tr>
<tr>
<td>特点</td>
<td>依赖于common-pool</td>
<td>阿里开源，功能全面</td>
<td>历史久远，逻辑复杂，不易维护</td>
<td></td>
<td>优化力度大,功能简单，起源于boneCP</td>
</tr>
<tr>
<td>连接池管理</td>
<td>LinkedBlockingDeque</td>
<td>数组</td>
<td></td>
<td>FairBlockingQueue</td>
<td>threadlocal+CopyOnWriteArrayList</td>
</tr>
</tbody>
</table>
</div>
<p>总结：</p>
<ol>
<li>性能方面 hikariCP &gt; druid &gt; tomcat-jdbc &gt; dbcp &gt; c3p0 。hikariCP的高性能得益于最大限度的避免锁竞争</li>
<li>druid功能最为全面，sql拦截等功能，统计数据较为全面，具有良好的扩展性</li>
<li>综合性能，扩展性等方面，可考虑使用druid或者hikariCP连接池</li>
<li>可开启prepareStatement缓存，对性能会有大概20%的提升</li>
</ol>
<h2 id="druid连接池的使用"><a href="#druid连接池的使用" class="headerlink" title="druid连接池的使用"></a>druid连接池的使用</h2><p>导入druid工具类jar</p>
<h3 id="硬编码方式"><a href="#硬编码方式" class="headerlink" title="硬编码方式"></a>硬编码方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建druid连接池对象，使用硬编码进行核心参数设置！</span></span><br><span class="line"><span class="comment"> *   必须参数： 账号</span></span><br><span class="line"><span class="comment"> *             密码</span></span><br><span class="line"><span class="comment"> *             url</span></span><br><span class="line"><span class="comment"> *             driverClass</span></span><br><span class="line"><span class="comment"> *   非必须参数：</span></span><br><span class="line"><span class="comment"> *           初始化个数</span></span><br><span class="line"><span class="comment"> *           最大数量等等  不推荐设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">druidHard</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置四个必须参数</span></span><br><span class="line">   dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">   dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">   dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">   dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///day01&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取连接</span></span><br><span class="line">   <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">   <span class="comment">// JDBC的步骤</span></span><br><span class="line">   <span class="comment">//回收连接</span></span><br><span class="line">   connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="软编码方式"><a href="#软编码方式" class="headerlink" title="软编码方式"></a>软编码方式</h3><p>外部声明（存放在src/druid.properties）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># druid连接池需要的配置参数,key固定命名</span><br><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">url=jdbc:mysql:<span class="comment">///atguigu</span></span><br></pre></td></tr></table></figure>
<p>声明代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不直接在java代码编写配置文件！</span></span><br><span class="line"><span class="comment"> * 利用工厂模式，传入配置文件对象，创建连接池！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">druidSoft</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">ips</span> <span class="operator">=</span> DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">    properties.load(ips);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="druid配置"><a href="#druid配置" class="headerlink" title="druid配置"></a>druid配置</h3><div class="table-container">
<table>
<thead>
<tr>
<th>配置</th>
<th>缺省</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this)</td>
</tr>
<tr>
<td>jdbcUrl</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/使用ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody>
</table>
</div>
<h1 id="使用优化及工具类封装"><a href="#使用优化及工具类封装" class="headerlink" title="使用优化及工具类封装"></a>使用优化及工具类封装</h1><h2 id="工具类封装"><a href="#工具类封装" class="headerlink" title="工具类封装"></a>工具类封装</h2><p>封装一个工具类,内部包含连接池对象,同时对外提供连接的方法和回收连接的方法</p>
<p>外部配置文件（位置: src/druid.properties）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># druid连接池需要的配置参数,key固定命名</span><br><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">url=jdbc:mysql:<span class="comment">///atguigu</span></span><br></pre></td></tr></table></figure>
<p>工具类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCToolsVersion1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    <span class="keyword">static</span>&#123;<span class="comment">//静态代码块，JDBCToolsVersion1类初始化执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            pro.load(ClassLoader.getSystemResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();<span class="comment">//这么写，不能保证同一个线程，两次getConnection()得到的是同一个Connection对象</span></span><br><span class="line">                            <span class="comment">//如果不能保证是同一个连接对象，就无法保证事务的管理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        conn.close();<span class="comment">//还给连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal的介绍：</p>
<p>JDK 1.2的版本中就提供java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。<br>使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、<br>Session等</p>
<p>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个<br>ThreadLocalMap<ThreadLocal, object>，其key就是一个ThreadLocal，而Object即为该线程的<br>共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，<br>不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</ThreadLocal,></p>
<p>1、ThreadLocal对象.get: 获取ThreadLocal中当前线程共享变量的值。</p>
<p>2、ThreadLocal对象.set: 设置ThreadLocal中当前线程共享变量的值。</p>
<p>3、ThreadLocal对象.remove: 移除ThreadLocal中当前线程共享变量的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个工具类的作用就是用来给所有的SQL操作提供“连接”，和释放连接。</span></span><br><span class="line"><span class="comment">这里使用ThreadLocal的目的是为了让同一个线程，在多个地方getConnection得到的是同一个连接。</span></span><br><span class="line"><span class="comment">这里使用DataSource的目的是为了（1）限制服务器的连接的上限（2）连接的重用性等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTools</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;<span class="comment">//静态代码块，JDBCToolsVersion1类初始化执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            pro.load(ClassLoader.getSystemResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">         <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> tl.get();</span><br><span class="line">         <span class="keyword">if</span>(connection  == <span class="literal">null</span>)&#123;<span class="comment">//当前线程还没有拿过连接，就给它从数据库连接池拿一个</span></span><br><span class="line">             connection = ds.getConnection();</span><br><span class="line">             tl.set(connection);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">            tl.remove();</span><br><span class="line">            connection.setAutoCommit(<span class="literal">true</span>);<span class="comment">//避免还给数据库连接池的连接不是自动提交模式（建议）</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级应用层封装"><a href="#高级应用层封装" class="headerlink" title="高级应用层封装"></a>高级应用层封装</h2><p>基本上每一个数据表都应该有一个对应的DAO接口及其实现类，发现对所有表的操作（增、删、改、查）代码重复度很高，所以可以抽取公共代码，给这些DAO的实现类可以抽取一个公共的父类，我们称为BaseDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通用的增、删、改的方法</span></span><br><span class="line"><span class="comment">    String sql：sql</span></span><br><span class="line"><span class="comment">    Object... args：给sql中的?设置的值列表，可以是0~n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql,Object... args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="comment">//        创建PreparedStatement对象，对sql预编译</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置?的值</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//?的编号从1开始，不是从0开始，数组的下标是从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">        ps.close();</span><br><span class="line">        <span class="comment">//这里检查下是否开启事务,开启不关闭连接,业务方法关闭!</span></span><br><span class="line">        <span class="comment">//没有开启事务的话,直接回收关闭即可!</span></span><br><span class="line">        <span class="keyword">if</span> (connection.getAutoCommit()) &#123;</span><br><span class="line">            <span class="comment">//回收</span></span><br><span class="line">            JDBCTools.free();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通用的查询多个Javabean对象的方法，例如：多个员工对象，多个部门对象等</span></span><br><span class="line"><span class="comment">    这里的clazz接收的是T类型的Class对象，</span></span><br><span class="line"><span class="comment">    如果查询员工信息，clazz代表Employee.class，</span></span><br><span class="line"><span class="comment">    如果查询部门信息，clazz代表Department.class，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; ArrayList&lt;T&gt; <span class="title function_">query</span><span class="params">(Class&lt;T&gt; clazz,String sql, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//        创建PreparedStatement对象，对sql预编译</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置?的值</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//?的编号从1开始，不是从0开始，数组的下标是从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取结果集的元数据对象。</span></span><br><span class="line"><span class="comment">        元数据对象中有该结果集一共有几列、列名称是什么等信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> res.getMetaData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();<span class="comment">//获取结果集列数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历结果集ResultSet，把查询结果中的一条一条记录，变成一个一个T 对象，放到list中。</span></span><br><span class="line">        <span class="keyword">while</span>(res.next())&#123;</span><br><span class="line">            <span class="comment">//循环一次代表有一行，代表有一个T对象</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();<span class="comment">//要求这个类型必须有公共的无参构造</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把这条记录的每一个单元格的值取出来，设置到t对象对应的属性中。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=columnCount; i++)&#123;</span><br><span class="line">                <span class="comment">//for循环一次，代表取某一行的1个单元格的值</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> res.getObject(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个值应该是t对象的某个属性值</span></span><br><span class="line">                <span class="comment">//获取该属性对应的Field对象</span></span><br><span class="line"><span class="comment">//                String columnName = metaData.getColumnName(i);//获取第i列的字段名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnLabel(i);<span class="comment">//获取第i列的字段名或字段的别名</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);<span class="comment">//这么做可以操作private的属性</span></span><br><span class="line"></span><br><span class="line">                field.set(t, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.close();</span><br><span class="line">        ps.close();</span><br><span class="line">        <span class="comment">//这里检查下是否开启事务,开启不关闭连接,业务方法关闭!</span></span><br><span class="line">        <span class="comment">//没有开启事务的话,直接回收关闭即可!</span></span><br><span class="line">        <span class="keyword">if</span> (connection.getAutoCommit()) &#123;</span><br><span class="line">            <span class="comment">//回收</span></span><br><span class="line">            JDBCTools.free();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">queryBean</span><span class="params">(Class&lt;T&gt; clazz,String sql, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ArrayList&lt;T&gt; list = query(clazz, sql, args);</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="literal">null</span> || list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于CMS项目JDBC实战练习"><a href="#基于CMS项目JDBC实战练习" class="headerlink" title="基于CMS项目JDBC实战练习"></a>基于CMS项目JDBC实战练习</h1><h2 id="cms项目介绍和导入"><a href="#cms项目介绍和导入" class="headerlink" title="cms项目介绍和导入"></a>cms项目介绍和导入</h2><ul>
<li><p><strong>项目介绍</strong></p>
<p>利用JavaSE技术,进行控制台输出的客户管理系统。主要功能让包含<strong>客户展示</strong>,<strong>客户删除</strong>,<strong>客户添加</strong>,<strong>客户修改</strong>,<strong>退出系统</strong>。</p>
</li>
<li><p><strong>项目导入</strong></p>
<ol>
<li>打开项目</li>
<li>配置jdk</li>
</ol>
</li>
</ul>
<h2 id="基于cms项目添加数据库相关配置"><a href="#基于cms项目添加数据库相关配置" class="headerlink" title="基于cms项目添加数据库相关配置"></a>基于cms项目添加数据库相关配置</h2><ul>
<li><p>准备数据库脚本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_customer(</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT COMMENT <span class="string">&#x27;客户主键&#x27;</span>,</span><br><span class="line">  NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)  COMMENT <span class="string">&#x27;客户名称&#x27;</span>,</span><br><span class="line">  gender <span class="type">VARCHAR</span>(<span class="number">4</span>) COMMENT <span class="string">&#x27;客户性别&#x27;</span>,</span><br><span class="line">  age <span class="type">INT</span>  COMMENT <span class="string">&#x27;客户年龄&#x27;</span>,</span><br><span class="line">  salary <span class="keyword">DOUBLE</span>(<span class="number">8</span>,<span class="number">1</span>) COMMENT <span class="string">&#x27;客户工资&#x27;</span>,</span><br><span class="line">  phone <span class="type">VARCHAR</span>(<span class="number">11</span>) COMMENT <span class="string">&#x27;客户电话&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件（位置: src下, druid.properties）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># druid连接池需要的配置参数,key固定命名</span><br><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">url=jdbc:mysql:///atguigu</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入jdbcv2.0工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个工具类的作用就是用来给所有的SQL操作提供“连接”，和释放连接。</span></span><br><span class="line"><span class="comment">这里使用ThreadLocal的目的是为了让同一个线程，在多个地方getConnection得到的是同一个连接。</span></span><br><span class="line"><span class="comment">这里使用DataSource的目的是为了（1）限制服务器的连接的上限（2）连接的重用性等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTools</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;<span class="comment">//静态代码块，JDBCToolsVersion1类初始化执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            pro.load(ClassLoader.getSystemResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">         <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> tl.get();</span><br><span class="line">         <span class="keyword">if</span>(connection  == <span class="literal">null</span>)&#123;<span class="comment">//当前线程还没有拿过连接，就给它从数据库连接池拿一个</span></span><br><span class="line">             connection = ds.getConnection();</span><br><span class="line">             tl.set(connection);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">            tl.remove();</span><br><span class="line">            connection.setAutoCommit(<span class="literal">true</span>);<span class="comment">//避免还给数据库连接池的连接不是自动提交模式（建议）</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入baseDao工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通用的增、删、改的方法</span></span><br><span class="line"><span class="comment">    String sql：sql</span></span><br><span class="line"><span class="comment">    Object... args：给sql中的?设置的值列表，可以是0~n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql,Object... args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//创建PreparedStatement对象，对sql预编译</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置?的值</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//?的编号从1开始，不是从0开始，数组的下标是从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">        ps.close();</span><br><span class="line">        <span class="comment">//这里检查下是否开启事务,开启不关闭连接,业务方法关闭!</span></span><br><span class="line">        <span class="comment">//没有开启事务的话,直接回收关闭即可!</span></span><br><span class="line">        <span class="keyword">if</span> (connection.getAutoCommit()) &#123;</span><br><span class="line">            <span class="comment">//回收</span></span><br><span class="line">            JDBCTools.free();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通用的查询多个Javabean对象的方法，例如：多个员工对象，多个部门对象等</span></span><br><span class="line"><span class="comment">    这里的clazz接收的是T类型的Class对象，</span></span><br><span class="line"><span class="comment">    如果查询员工信息，clazz代表Employee.class，</span></span><br><span class="line"><span class="comment">    如果查询部门信息，clazz代表Department.class，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; ArrayList&lt;T&gt; <span class="title function_">query</span><span class="params">(Class&lt;T&gt; clazz,String sql, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建PreparedStatement对象，对sql预编译</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置?的值</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//?的编号从1开始，不是从0开始，数组的下标是从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取结果集的元数据对象。</span></span><br><span class="line"><span class="comment">        元数据对象中有该结果集一共有几列、列名称是什么等信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> res.getMetaData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();<span class="comment">//获取结果集列数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历结果集ResultSet，把查询结果中的一条一条记录，变成一个一个T 对象，放到list中。</span></span><br><span class="line">        <span class="keyword">while</span>(res.next())&#123;</span><br><span class="line">            <span class="comment">//循环一次代表有一行，代表有一个T对象</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();<span class="comment">//要求这个类型必须有公共的无参构造</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把这条记录的每一个单元格的值取出来，设置到t对象对应的属性中。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=columnCount; i++)&#123;</span><br><span class="line">                <span class="comment">//for循环一次，代表取某一行的1个单元格的值</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> res.getObject(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个值应该是t对象的某个属性值</span></span><br><span class="line">                <span class="comment">//获取该属性对应的Field对象</span></span><br><span class="line">                <span class="comment">//String columnName = metaData.getColumnName(i);//获取第i列的字段名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnLabel(i);<span class="comment">//获取第i列的字段名或字段的别名</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);<span class="comment">//这么做可以操作private的属性</span></span><br><span class="line"></span><br><span class="line">                field.set(t, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.close();</span><br><span class="line">        ps.close();</span><br><span class="line">        <span class="comment">//这里检查下是否开启事务,开启不关闭连接,业务方法关闭!</span></span><br><span class="line">        <span class="comment">//没有开启事务的话,直接回收关闭即可!</span></span><br><span class="line">        <span class="keyword">if</span> (connection.getAutoCommit()) &#123;</span><br><span class="line">            <span class="comment">//回收</span></span><br><span class="line">            JDBCTools.free();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">queryBean</span><span class="params">(Class&lt;T&gt; clazz,String sql, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ArrayList&lt;T&gt; list = query(clazz, sql, args);</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="literal">null</span> || list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基于cms项目实战"><a href="#基于cms项目实战" class="headerlink" title="基于cms项目实战"></a>基于cms项目实战</h2><ul>
<li><p>customerService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.cms.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.cms.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.cms.javabean.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个具有管理功能的功能类. 内部数据不允许外部随意修改, 具有更好的封装性.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CustomerDao</span> <span class="variable">customerDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerDao</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用途：返回所有客户对象</span></span><br><span class="line"><span class="comment">     * 返回：集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Customer&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> customerDao.queryList();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用途：添加新客户</span></span><br><span class="line"><span class="comment">     * 参数：customer指定要添加的客户对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCustomer</span><span class="params">(Customer customer)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            customerDao.insertCustomer(customer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用途：返回指定id的客户对象记录</span></span><br><span class="line"><span class="comment">     * 参数： id 就是要获取的客户的id号.</span></span><br><span class="line"><span class="comment">     * 返回：封装了客户信息的Customer对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">getCustomer</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> customerDao.queryById(id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改指定id号的客户对象的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 客户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cust 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改成功返回true, false表明指定id的客户未找到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyCustomer</span><span class="params">(<span class="type">int</span> id, Customer cust)</span>  &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rows = customerDao.updateCustomer(cust);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用途：删除指定id号的的客户对象记录</span></span><br><span class="line"><span class="comment">     * 参数： id 要删除的客户的id号</span></span><br><span class="line"><span class="comment">     * 返回：删除成功返回true；false表示没有找到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeCustomer</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rows = customerDao.deleteCustomer(id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>customerDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.cms.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.cms.javabean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.cms.utils.BaseDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户进行数据库操作的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Customer&gt; <span class="title function_">queryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ArrayList&lt;Customer&gt; list = query(Customer.class, <span class="string">&quot;select * from t_customer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCustomer</span><span class="params">(Customer customer)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> update(<span class="string">&quot;insert into t_customer(name,gender,age,salary,phone) values (?,?,?,?,?)&quot;</span>,</span><br><span class="line">                customer.getName(), customer.getGender(),customer.getAge(),customer.getSalary(),customer.getPhone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> queryBean(Customer.class, <span class="string">&quot;select * from t_customer where id = ?&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteCustomer</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> update(<span class="string">&quot;delete from t_customer where id =?&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateCustomer</span><span class="params">(Customer cust)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> update(<span class="string">&quot;update t_customer set name = ? , gender = ? , age = ? ,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;salary = ? , phone = ? where id = ? ;&quot;</span>, cust.getName(), cust.getGender(),</span><br><span class="line">                cust.getAge(), cust.getSalary(), cust.getPhone(), cust.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/post/99720b1c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>web开发：</p>
<ul>
<li>web，网页的意思，www.baidu.com·</li>
<li>静态web<ul>
<li>html,css</li>
<li>提供给所有人看的数据始终不会发生变化！</li>
</ul>
</li>
<li>动态web<ul>
<li>淘宝，几乎是所有的网站；</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！</li>
<li>技术栈：Servlet/JSP，ASP，PHP</li>
</ul>
</li>
</ul>
<h3 id="web应用程序web应用程序"><a href="#web应用程序web应用程序" class="headerlink" title="web应用程序web应用程序"></a>web应用程序web应用程序</h3><p>可以提供浏览器访问的程序；</p>
<ul>
<li>a.html、b.html.….多个web资源，这些web资源可以被外界访问，对外界提供服务</li>
<li>能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上</li>
<li>URL</li>
<li>这个统一的web资源会被放在同一个文件夹下，web应用程序&gt;Tomcat：服务器</li>
<li>一个web应用由多部分组成（静态web，动态web)<ul>
<li>html,css,js</li>
<li>jsp,servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件（Properties)</li>
</ul>
</li>
</ul>
<p>Web应用程序编写完毕后，若想提供给外界访问；需要一服务器来统一管理</p>
<h4 id="静态web"><a href="#静态web" class="headerlink" title="静态web"></a>静态web</h4><ul>
<li><em>.htm， </em>.html这些都是网员的后缀、如果服务器上一直存在这些东西，就可以直接进行读取、需要网络</li>
<li><img src="https://img-blog.csdnimg.cn/20200506174751665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt></li>
<li>静态web存在的缺点<ul>
<li>Web页面无法动态更新，所有用户看到都是同一个页面<ul>
<li>轮播图，点击特效：伪动态</li>
<li>JavaScript[实际开发中，它用的最多]</li>
<li>VBScript</li>
</ul>
</li>
<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>
</ul>
</li>
</ul>
<h4 id="动态web"><a href="#动态web" class="headerlink" title="动态web"></a>动态web</h4><p>浏览器发送 HTTP 请求，服务器 Tomcat 接收请求，Servlet 容器从磁盘加载 Servlet 程序处理请求 request ，处理结束返回 response</p>
<p><img src="https://img-blog.csdnimg.cn/20200506175025436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt></p>
<p>缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布；</li>
<li>停机维护</li>
</ul>
<p>优点：</p>
<ul>
<li>Web页面可以动态更新，所有用户看到都不是同一个页面</li>
<li>它可以与数据库交互（数据持久化：注册，商品信息，用户信息………）</li>
</ul>
<h1 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h1><h3 id="技术讲解"><a href="#技术讲解" class="headerlink" title="技术讲解"></a>技术讲解</h3><p><strong>ASP:</strong></p>
<ul>
<li>微软：国内最早流行的就是ASP；</li>
<li>·在HTML中嵌入了VB的脚本，ASP+COM；</li>
<li>·在ASP开发中，基本一个页面都有几干行的业务代码，页面极其换乱</li>
<li>·维护成本高！</li>
<li>C#</li>
<li>IIS</li>
</ul>
<p><strong>php:</strong></p>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码很简单（70%，WP）</li>
<li>·无法承载大访问量的情况（局限性）</li>
</ul>
<p><strong>jSP/Servlet:</strong><br>B/S；浏览和服务器C/S：客户端和服务器</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言的（所有的大公司，或者一些开源的组件，都是用Java写的）</li>
<li>可以承载三高问题带来的影响；</li>
<li>语法像ASP，ASP-&gt;JSP，加强市场强度；</li>
</ul>
<h4 id="web服务器-1"><a href="#web服务器-1" class="headerlink" title="web服务器"></a>web服务器</h4><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；<br><strong>lIS</strong><br>微软的；ASP.,Windows中自带的<br><strong>Tomcat</strong><img src="https://img-blog.csdnimg.cn/20200423183331323.png" alt></p>
<p>面向百度编程：</p>
<p>Tomcat是Apache 软件基金会（Apache Software Foundation)的jakarta项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受lava爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。<br>​ Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。对于一个Java初学web的人来说，它是最佳的选择</p>
<p><strong>Tomcat</strong> 实际上运行JSP页面和Serlet。</p>
<p><strong>工作3-5年之后，可以尝试手写Tomcat服务器；</strong></p>
<p>下载tomcat：</p>
<ol>
<li>安装or解压</li>
<li>了解配置文件及目录结构</li>
<li>这个东西的作用</li>
</ol>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>安装：官网：<a href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a></p>
<p>启动配置：文件夹：<br><img src="https://img-blog.csdnimg.cn/2020102921535868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTg4MTI3,size_16,color_FFFFFF,t_70#pic_center" alt></p>
<p>启动和关闭 Tomcat：<br><img src="https://img-blog.csdnimg.cn/2020102921543768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTg4MTI3,size_16,color_FFFFFF,t_70#pic_center" alt><br>访问测试：<a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p>可能遇到的问题：</p>
<ol>
<li>Java 环境变量没有配置导致闪退</li>
<li>乱码问题：可在配置文件中配置</li>
</ol>
<p>配置</p>
<p>Servlet 核心配置文件目录：</p>
<p><img src="https://img-blog.csdnimg.cn/20201029215639475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTg4MTI3,size_16,color_FFFFFF,t_70#pic_center" alt><br>可以配置启动的端口号</p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8081&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>可配置主机名称</p>
<ul>
<li>默认的主机名为：localhost-&gt;127.0.0.1</li>
<li>默认网站应用存放的位置为：webapps</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>面试题：</strong></p>
<p>请你谈谈网站是如何进行访问的</p>
<ol>
<li><p>在浏览器输入一个域名，回车；</p>
</li>
<li><p>本机查看 C:\Windows\System32\drivers\etc\hosts 配置文件是否有相应域名的映射。</p>
<p>case1: 若有，则直接映射到对应的 IP 地址，进行访问。</p>
<p>case2: 若无，则去 DNS 服务器上查找对应的 IP ，找到就返回相应的 IP，找不到就不返回。</p>
<p><img src="https://img-blog.csdnimg.cn/20201025183516937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTg4MTI3,size_16,color_FFFFFF,t_70#pic_center" alt><br><img src="https://img-blog.csdnimg.cn/20201025184035890.png#pic_center" alt></p>
</li>
</ol>
</blockquote>
<h3 id="发布一个-Web-网站"><a href="#发布一个-Web-网站" class="headerlink" title="发布一个 Web 网站"></a>发布一个 Web 网站</h3><ul>
<li>将自己写的网站，放到服务器（Tomcat)中指定的web应用的文件夹（webapps)下，就可以访问了</li>
</ul>
<p>网站程序的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--webapps ：Tomcat服务器的web目录</span><br><span class="line">	-ROOT</span><br><span class="line">	-kuangstudy ：网站的目录名</span><br><span class="line">		- WEB-INF</span><br><span class="line">			-classes : java程序</span><br><span class="line">			-lib：web应用所依赖的jar包</span><br><span class="line">			-web.xml ：网站配置文件</span><br><span class="line">		- index.html 默认的首页</span><br><span class="line">		- static </span><br><span class="line">            -css</span><br><span class="line">            	-style.css</span><br><span class="line">            -js</span><br><span class="line">            -img</span><br><span class="line">         -.....</span><br></pre></td></tr></table></figure>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，通常运行在TCP之上。指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式</p>
<ul>
<li>文本：html，字符串，…</li>
<li>超文本：图片，音乐，视频，定位，地图.……</li>
<li>端口:80</li>
</ul>
<p>Https:安全的</p>
<ul>
<li>443</li>
</ul>
<h2 id="两个时代："><a href="#两个时代：" class="headerlink" title="两个时代："></a>两个时代：</h2><ul>
<li>http1.0<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接，加入某个页面有多个图片资源需要加载，那么需要连接多次，影响服务器和客户端的性能</li>
</ul>
</li>
<li>http2.0<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源</li>
</ul>
</li>
</ul>
<h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><p>客户端 -&gt; 发请求（Request）-&gt; 服务器</p>
<p>百度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Request URL:https://www.baidu.com/   请求地址</span><br><span class="line">Request Method:GET    get方法/post方法</span><br><span class="line">Status Code:200 OK    状态码：200</span><br><span class="line">Remote（远程） Address:14.215.177.39:443</span><br><span class="line"></span><br><span class="line">Accept:text/html  </span><br><span class="line">Accept-Encoding:gzip, deflate, br</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.9    语言</span><br><span class="line">Cache-Control:max-age=0</span><br><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：<strong>Get</strong>,<strong>Post</strong>,HEAD,DELETE,PUT,TRACT.…<ul>
<li>get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</li>
</ul>
</li>
</ul>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept：告诉浏览器，它所支持的数据类型</span><br><span class="line">Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1</span><br><span class="line">Accept-Language：告诉浏览器，它的语言环境</span><br><span class="line">Cache-Control：缓存控制</span><br><span class="line">Connection：告诉浏览器，请求完成是断开还是保持连接</span><br><span class="line">HOST：主机..../.</span><br></pre></td></tr></table></figure>
<h2 id="Http响应"><a href="#Http响应" class="headerlink" title="Http响应"></a>Http响应</h2><ul>
<li>服务器 -&gt; 响应 -&gt; 客户端</li>
</ul>
<p>百度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control:private    缓存控制</span><br><span class="line">Connection:Keep-Alive    连接</span><br><span class="line">Content-Encoding:gzip    编码</span><br><span class="line">Content-Type:text/html   类型  </span><br></pre></td></tr></table></figure>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept：告诉浏览器，它所支持的数据类型</span><br><span class="line">Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1</span><br><span class="line">Accept-Language：告诉浏览器，它的语言环境</span><br><span class="line">Cache-Control：缓存控制</span><br><span class="line">Connection：告诉浏览器，请求完成是断开还是保持连接</span><br><span class="line">HOST：主机..../.</span><br><span class="line">Refresh：告诉客户端，多久刷新一次；</span><br><span class="line">Location：让网页重新定位；</span><br></pre></td></tr></table></figure>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>200：请求响应成功   200</p>
<p>3xx:请求重定向</p>
<ul>
<li>重定向：你重新到我给你新位置去；</li>
</ul>
<p>4xx:找不到资源    404</p>
<ul>
<li>资源不存在；</li>
</ul>
<p>5xx:服务器代码错误    500    502:网关错误</p>
<blockquote>
<p><strong>面试题</strong></p>
<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p>
<p>1.（域名解析）在客户端，浏览器输入地址后，首先会在windows系统文件的hosts中查找是否有对应的ip地址，如果没有则需要向DNS域名解析服务器询问该域名对应的ip地址。</p>
<p>2.（TCP三次握手）获取相应的ip地址后，客户端与服务器端建立TCP连接（三次握手），（网络层，数据链路层，物理层）</p>
<p>三次握手—&gt;</p>
<p>第一次握手：客户端向服务器端发送一个SYN段，该段中包含客户端的初始序列号。</p>
<p>第二次握手：服务器端返回客户端SYN+ACK，该端中包含服务器端的初始序列号，ACK表示，已经确定收到客户端的SYN段。</p>
<p>第三次握手：客户端向服务器端响应一个ACK端，ACK表示，已经确定接受到服务器端的SYN段。</p>
<p>3.（建立起TCP连接后发起http请求）客户端向服务器端发送请求，包含请求行，请求头。主要的两种请求方式（GET与POST）</p>
<p>—&gt;GET:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据的内容，不安全，但高效。</p>
<p>—&gt;POST:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</p>
<p>4.（服务器响应http请求）服务器处理请求，并返回响应，包含状态码，响应头，响应体。</p>
<p>5（浏览器解析http代码）浏览器收到响应，解析http代码渲染页面，并在浏览器页面展示出来。</p>
<p>6.（断开连接）http1.0短连接，http1.1长连接</p>
</blockquote>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；maven自动导入和配置这个jar包</p>
<p>Maven项目架构管理工具：</p>
<p>Maven 的核心思想：约定大于配置</p>
<ul>
<li>有约束，不能违反<br>Maven 会规定好你该如何去编写我们的 Java 代码，必须要按照这个规范</li>
</ul>
<p>Maven下载安装：官网：<a href="https://maven.apache.org/">Maven – Welcome to Apache Maven</a><img src="https://img-blog.csdnimg.cn/20200506180036622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbGxfbG92ZQ==,size_16,color_FFFFFF,t_70" alt></p>
<p>环境配置：在我们的系统环境变量中配置如下配置：</p>
<ul>
<li>M2_HOME maven目录下的bin目录</li>
<li>MAVEN_HOME maven的目录</li>
<li>在系统的path中配置%MAVEN_HOME%\bin</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200423213124579.png" alt></p>
<ul>
<li>测试Maven是否安装成功，保证必须配置完毕！</li>
</ul>
<p>阿里云镜像</p>
<ul>
<li>镜像：mirrors</li>
<li>作用：加速我们的下载</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">原始的：</span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-default-http-blocker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:http:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pseudo repository to mirror external repositories initially using HTTP.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://0.0.0.0/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">修改的：</span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>本地仓库</p>
<p>在本地的仓库，远程仓库； 建立一个本地仓库：localRepository</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\environment\Maven\apache-maven-3.8.6\maven-repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>idea中maven的操作</p>
<p>1、启动 IDEA<br>2、 创建一个 MavenWeb 项目<br>3、等待项目初始化完毕<br>4、观察 maven 仓库中多了什么东西？<br>5、 IDEA 中的 Maven 设置<br>注意：IDEA 项目创建成功后，看一眼 Maven 的配置</p>
<p><img src="https://z3.ax1x.com/2021/07/27/W4hm0H.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/W44CDg.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/W447R0.png" alt></p>
<p>看到Enable Auto-Import就点自动导包</p>
<p><img src="https://z3.ax1x.com/2021/07/27/W4T1OK.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/W4oPbD.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/W4TBOf.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/W4HYRA.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/W4bPSA.png" alt></p>
<p>在build中配置resources，来防止我们资源导出失败的问题</p>
<p><a href="https://www.cnblogs.com/pixy/p/4798089.html">https://www.cnblogs.com/pixy/p/4798089.html</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-xmls<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>process-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;basedir&#125;/target/classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>pom文件</p>
<p>pow.xml 是Maven的核心配置文件</p>
<p>（百度）在maven仓库中想要什么就下载什么依赖即可</p>
<p>解决遇到的问题<br>Maven 3.6.2<br>解决方法：降级为 3.6.1<br>Tomcat 闪退<br>IDEA中每次都要重复配置Maven<br>在IDEA中的全局默认配置中去配置</p>
<p>Maven 默认 Web 项目中的 web.xml 版本问题</p>
<p>替换为 webapp4.0 版本和 Tomcat 一致</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="line"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span></span><br><span class="line">         metadata-complete=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些APi中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：<ul>
<li>编写一个类，实现Serlet接口</li>
<li>把开发好java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h2 id="Hello-Servlet"><a href="#Hello-Servlet" class="headerlink" title="Hello Servlet"></a>Hello Servlet</h2><p>Serlvet 接口 Sun 公司有两个默认的实现类：HttpServlet，GenericServlet</p>
<p>构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程（建一个WebApp Maven项目，勾选模板）；</p>
<p>关于Maven父子工程的理解：</p>
<ul>
<li>父项目中会有：</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;<span class="keyword">module</span>&gt;servlet-<span class="number">01</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>子项目会有：</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;javaweb-<span class="number">02</span>-servlet&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.lt&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<p>父项目的java子项目也可以用</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">son <span class="keyword">extends</span> <span class="title class_">father</span></span><br></pre></td></tr></table></figure>
<p>Maven环境优化</p>
<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整</li>
</ol>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="line"><span class="string">         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span></span><br><span class="line">         metadata-complete=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p>编写一个Servlet程序</p>
<p>1.编写一个普通类<br>​ 2.实现Servlet接口，这里我们直接继承HttpServlet</p>
<p><img src="https://img-blog.csdnimg.cn/f9206552660a4711994146e1f175cda5.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">//由于get或者post只是请求实现的方式不同，可以相互调用，业务逻辑都一样！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//ServletOutputStream outputStream = response.getOutputStream();</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();<span class="comment">//响应流</span></span><br><span class="line">        writer.println(<span class="string">&quot;Hello Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写Servlet的映射<br>为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lt.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置Tomcat 注意：配置项目发布的路径</p>
<p>启动测试</p>
<ul>
<li><p>问题1</p>
<ul>
<li>500错误，tomcat10版本不兼容问题，服务降级就好（tomcat9）</li>
<li><a href="https://blog.csdn.net/qq_43682690/article/details/109364514">https://blog.csdn.net/qq_43682690/article/details/109364514</a></li>
</ul>
</li>
<li><p>问题2</p>
<ul>
<li><p>确定操作无误，没有target目录</p>
<p><img src="https://z3.ax1x.com/2021/07/27/WIZPDP.png" alt></p>
</li>
</ul>
</li>
<li><p>问题3</p>
<ul>
<li><p>没有lib</p>
<p>去吧<strong>工程</strong>下的pom.xml里面依赖的<code>&lt;scope&gt;provided&lt;/scope&gt;</code>（作用域）删掉</p>
</li>
</ul>
</li>
</ul>
<h2 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h2><p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后</p>
<p><img src="https://z3.ax1x.com/2021/07/27/WIuGe1.png" alt></p>
<p><img src="https://z3.ax1x.com/2021/07/27/WIubkV.png" alt></p>
<h2 id="Mapping问题"><a href="#Mapping问题" class="headerlink" title="Mapping问题"></a>Mapping问题</h2><ol>
<li><p>一个Servlet可以指定一个映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个Servlet可以指定多个映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello4<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello5<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个Servlet可以指定用的的普通路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认的请求路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认请求路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些前缀后缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以自定义后缀实现请求映射</span></span><br><span class="line"><span class="comment">    注意点，*前面不能加项目映射的路径</span></span><br><span class="line"><span class="comment">    hello/sajdlkajda.zty</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.zty<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优先级问题<br>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--404--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.lt.servlet.ErrorServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/post/53d0684b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>centOS：</p>
<p>官网：<a href="https://www.centos.org/download/">Download (centos.org)</a></p>
<p>VMware：</p>
<p>官网：<a href="https://www.vmware.com/cn.html">VMware 中国 - 交付面向企业的数字化基础 | CN</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础篇</title>
    <url>/post/c7ac62d6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux是一个开源、免费的操作系统，其稳定性，安全性，处理多并发已得到业界认可</p>
<p>Linux的主要发行版本有：RedHat、CentOS、Ubuntu、Debian、Fedora、SUSE等</p>
<h2 id="Linux与Unix"><a href="#Linux与Unix" class="headerlink" title="Linux与Unix"></a>Linux与Unix</h2><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="Linux-文件与目录结构"><a href="#Linux-文件与目录结构" class="headerlink" title="Linux 文件与目录结构"></a>Linux 文件与目录结构</h1><p>Linux的文件系统采用了层级式的树状目录结构，这种目录结构的好处是可以方便的管理文件，以及对文件进行扩展和维护。<br>在此结构中的最上层是根目录“/”，所有的其他目录都是从根目录开始的，<strong>Linux中，一切皆文件</strong></p>
<p>具体目录结构（了解即可）：</p>
<ul>
<li>/bin：bin 是 Binary 的缩写, 这个目录存放着最经常使用的命令。</li>
<li>/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li>/dev ：dev 是 Device(设备)的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</li>
<li>/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li>
<li>/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li>/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li>/media：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</li>
<li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</li>
<li>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</li>
<li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器：</li>
<li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li>/sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li>/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</li>
<li>/srv：该目录存放一些服务启动之后需要提取的数据。</li>
<li>/sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li>
<li>/tmp：这个目录是用来存放一些临时文件的。</li>
<li>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。</li>
<li>/usr/bin：系统用户使用的应用程序。</li>
<li>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li>/usr/src：内核源代码默认的放置目录。</li>
<li>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li>
<li>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li>
<li>/lock：该目录主要是系统提供的对外锁定目录，当系统上有程序在运行时，我们使用 ls 会看到这个目录。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux定制篇</title>
    <url>/post/152f43aa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaEE定制篇"><a href="#JavaEE定制篇" class="headerlink" title="JavaEE定制篇"></a>JavaEE定制篇</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>安装步骤：</p>
<ol>
<li>mkdir /opt/java</li>
<li>通过xftp上传到/opt/java目录下</li>
<li>cd /opt/jdk</li>
<li>解压tar -zxvf jdk-8u221-linux-x64.tar.gz</li>
<li>mkdir /usr/local/java</li>
<li>mv /opt/java/jdk1.8.0_221 /usr/local/java</li>
<li>配置环境变量的配置文件 vim /etc/profile</li>
<li>export JAVA_HOME=/usr/local/java/jdk1.8.0_221<br>9.export PATH=$JAVA_HOME/bin:$PATH</li>
<li>source /etc/profile     【让新的环境变量生效】</li>
</ol>
<p>测试：<br>编写一个hello.java程序，使用JAVA命令行工具，在终端上显示“Hello World!”。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac Hello.java</span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure><br>运行时环境：将/etc/profile文件中的JAVA_HOME变量设置为/usr/local/java/jdk1.8.0_221/jre<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_221/jre</span><br></pre></td></tr></table></figure><br>将JAVA_HOME环境变量加入到PATH环境变量中，如果系统提供了java命<br>令的软链接，那么可以不用设置PATH环境变量。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/java/jdk1.8.0_221/bin</span><br></pre></td></tr></table></figure></p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>步骤：</p>
<ol>
<li>上传安装文件到/opt/apache-tomcat-8.5.51/bin目录下</li>
<li>解压缩文件到/opt/apache-tomcat-8.5.51/webapps目录下</li>
<li>进入解压缩目录，启动tomcat<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/apache-tomcat-8.5.51/bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></li>
<li>测试tomcat是否启动成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>下载地址：<a href="https://www.jetbrains.com/idea/download/#section=linux">https://www.jetbrains.com/idea/download/#section=linux</a></p>
<ol>
<li>上传安装文件到/opt/idea目录下</li>
<li>解压缩文件到/opt/idea目录下</li>
<li>进入解压缩目录，启动idea<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/idea/bin</span><br><span class="line">./idea.sh</span><br></pre></td></tr></table></figure></li>
<li>测试idea是否启动成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep idea</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h1 id="大数据定制篇（shell）"><a href="#大数据定制篇（shell）" class="headerlink" title="大数据定制篇（shell）"></a>大数据定制篇（shell）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至是编写一些程序。</p>
<h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><p>脚本格式要求：</p>
<ol>
<li>以#!/bin/bash开头</li>
<li>脚本要有可执行权限</li>
</ol>
<p>执行方式：</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Linux shell中的变量分为系统变量和用户自定义变量，系统变量是系统定义好的，用户自定义变量是用户自己定义的变量。</p>
<p>shell变量的定义：<br>基本语法：<br>定义变量：变量名=变量值<br>撤销变量：unset 变量名<br>声明变量：declare -a 变量名 或 declare -x 变量名<br>声明静态变量：readonly 变量名，注意不能unset<br>查看变量：echo $变量名 或 echo ${变量名}<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>规则：</p>
<ol>
<li>变量名称只能是英文字母、数字和下划线，且不能以数字开头</li>
<li>等号两边不能有空格</li>
<li>变量名称一般习惯使用大写字母，系统变量使用大写字母，用户自定义变量使用小写字母</li>
</ol>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><h2 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h2><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h2 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h1 id="Python定制篇"><a href="#Python定制篇" class="headerlink" title="Python定制篇"></a>Python定制篇</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>官网：<a href="https://cn.ubuntu.com/download">https://cn.ubuntu.com/download</a></p>
<p>介绍：<br>Ubuntu一个以桌面应用为主的Linux操作系统，</p>
<h3 id="设置为中文"><a href="#设置为中文" class="headerlink" title="设置为中文"></a>设置为中文</h3><h3 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h3><h3 id="python开发"><a href="#python开发" class="headerlink" title="python开发"></a>python开发</h3><h2 id="APT软件管理和远程登录"><a href="#APT软件管理和远程登录" class="headerlink" title="APT软件管理和远程登录"></a>APT软件管理和远程登录</h2><h3 id="APT介绍"><a href="#APT介绍" class="headerlink" title="APT介绍"></a>APT介绍</h3><h3 id="软件操作相关命令"><a href="#软件操作相关命令" class="headerlink" title="软件操作相关命令"></a>软件操作相关命令</h3><h3 id="更新Ubuntu软件"><a href="#更新Ubuntu软件" class="headerlink" title="更新Ubuntu软件"></a>更新Ubuntu软件</h3><h3 id="Ubuntu安装卸载"><a href="#Ubuntu安装卸载" class="headerlink" title="Ubuntu安装卸载"></a>Ubuntu安装卸载</h3><h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实操篇</title>
    <url>/post/57eecc24.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="为什么要远程登录"><a href="#为什么要远程登录" class="headerlink" title="为什么要远程登录"></a>为什么要远程登录</h3><h1 id="VI和VIM编辑器"><a href="#VI和VIM编辑器" class="headerlink" title="VI和VIM编辑器"></a>VI和VIM编辑器</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Linux内置VI编辑器，VIM是VI的升级版，功能更强大，但是使用方法一样。<br>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。<br>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜 色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容</p>
<h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>以vim打开一个档案就直接进入了正常模式，<br>在这个模式中，可以用上下左右键移动光标，也可以用hjkl键移动光标，也可以用鼠标移动光标，但是不能输入文字，也不能删除文字，也不能保存退出。</p>
<h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>按下i,o,a,I,O,A等键进入插入模式，此时可以输入文字，也可以删除文字，也可以保存退出。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>输入esc再输入冒号进入命令行模式，此时可以输入命令，比如保存退出，比如查找替换等等。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>拷贝当前行yy，拷贝当前行向下的5行5yy，并粘贴（输入p）</li>
<li>删除当前行dd，删除当前行向下的5行5dd</li>
<li>在文件中查找某个单词【命令行下输入/单词】，查找下一个【n】，查找上一个【N】</li>
<li>设置文件的行号，取消文件的行号【命令行下输入：set nu】，【命令行下输入：set nonu】</li>
<li>编辑/etc/profile文件，在一般模式下，使用快捷键到该文档的最末行[G]和最前行[gg]</li>
<li>在一个文件中输入”hello“，在一般模式下，再撤销这个操作【u】</li>
<li>编辑/etc/profile文件，在一般模式下，并将光标移动到，输入20，再输入shift+g</li>
</ol>
<h1 id="开机，重启，用户注销"><a href="#开机，重启，用户注销" class="headerlink" title="开机，重启，用户注销"></a>开机，重启，用户注销</h1><h2 id="关机和重启命令"><a href="#关机和重启命令" class="headerlink" title="关机和重启命令"></a>关机和重启命令</h2><p>基本介绍：</p>
<ul>
<li>shutdown -h now 立即关机</li>
<li>shutdown -h 20:25 在20:25关机</li>
<li>shutdown -h +10 10分钟后关机</li>
<li>shutdown -r now 立即重启</li>
<li>shutdown -r 20:25 在20:25重启</li>
<li>shutdown -r +10 10分钟后重启</li>
<li>shutdown -c 取消关机或重启</li>
<li>halt 立即关机</li>
<li>reboot 立即重启</li>
<li>sync 立即同步磁盘数据</li>
</ul>
<p>注意细节：</p>
<ol>
<li>shutdown命令需要root权限</li>
<li>无论是重启系统还是关闭系统，都需要同步磁盘数据，避免数据丢失，所以在关机或重启之前，一定要执行sync命令</li>
</ol>
<h2 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h2><p>基本介绍：<br>登录时，需要输入用户名和密码，注销时，只需要输入logout命令即可。<br>尽量少使用root级别登录系统，因为root级别登录系统，可以做任何事情，包括删除系统文件，导致系统无法启动。</p>
<p>注意细节：</p>
<ol>
<li>logout命令只能注销当前用户，不能注销其他用户</li>
<li>运行级别</li>
</ol>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Linux是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd [选项] 用户名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd zhangsan</span><br></pre></td></tr></table></figure><br>细节说明：</p>
<ol>
<li>useradd命令只有root用户才能执行</li>
<li>当创建用户成功后，会自动在/home目录下创建一个和用户名同名的目录，作为用户的家目录，该目录中存放着用户的私有文件</li>
<li>可以使用useradd -D命令查看默认的用户创建信息</li>
</ol>
<h2 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a>指定/修改密码</h2><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd zhangsan</span><br></pre></td></tr></table></figure></p>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel [选项] 用户名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel zhangsan</span><br></pre></td></tr></table></figure></p>
<h2 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h2><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> 用户名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> zhangsan</span><br></pre></td></tr></table></figure><br>如果用户不存在，会提示id: zhangsan: no such user</p>
<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>在Linux中，如果当前用户权限不够，可以切换到权限更高的用户，切换用户后，可以执行更多的操作。<br>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su zhangsan</span><br></pre></td></tr></table></figure><br>细节说明：</p>
<ol>
<li>从权限高的用户切换到权限低的用户，不需要输入密码，反之，需要输入密码</li>
<li>切换用户后，会自动切换到该用户的家目录</li>
<li>当前用户切换到原来的用户，只需要输入exit/logout命令即可</li>
</ol>
<h2 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h2><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>基本介绍：<br>Linux是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<h3 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd group1</span><br></pre></td></tr></table></figure></p>
<h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel group1</span><br></pre></td></tr></table></figure></p>
<h3 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod [选项] 组名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod -n group2 group1</span><br></pre></td></tr></table></figure></p>
<h3 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -g 组名 用户名</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -g group2 zhangsan</span><br></pre></td></tr></table></figure></p>
<h2 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h2><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>用户（user）的配置文件，记录用户的各种信息<br>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure></p>
<h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>口令的配置文件<br>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:$6<span class="variable">$1QJQX1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>组（group）的配置文件，记录组的各种信息<br>每行的含义：组名:口令:组标识号:组内用户列表<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:</span><br></pre></td></tr></table></figure></p>
<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p>基本介绍：<br>Linux系统中，有7个运行级别，分别是0-6，每个运行级别代表着不同的系统状态，可以切换到不同的运行级别，以达到不同的目的。<br>0：关机<br>1：单用户模式<br>2：无网络服务<br>3：有网络服务<br>4：未分配<br>5：图形界面<br>6：重启</p>
<p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 运行级别</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 3</span><br></pre></td></tr></table></figure></p>
<h3 id="CentOS7后级别说明"><a href="#CentOS7后级别说明" class="headerlink" title="CentOS7后级别说明"></a>CentOS7后级别说明</h3><p>CentOS7后，/etc/inittab文件中，进行了如下修改：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inittab is no longer used when using systemd.</span></span><br></pre></td></tr></table></figure><br>CentOS7后，使用systemd管理系统，所以，切换运行级别的命令，也发生了变化，如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl isolate 运行级别.target</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure></p>
<h2 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h2><p>找回root密码的指令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></p>
<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul>
<li>man获得帮助信息<br>基本语法：man [选项] [命令]<br>应用案例：man ls<br>注意事项：<ol>
<li>man命令的帮助信息，非常全面，但是，需要知道具体的命令，才能查看帮助信息</li>
<li>man命令的帮助信息，需要翻页查看</li>
<li>man命令的帮助信息，需要按q键退出</li>
</ol>
</li>
<li>help指令<br>基本语法：help [命令]<br>应用案例：help cd<br>注意事项：<ol>
<li>如果指定的命令不存在，则应显示帮助信息</li>
<li>如果指定的命令存在，则应显示该命令的简介信息</li>
</ol>
</li>
</ul>
<h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><ul>
<li>pwd：显示当前所在的目录</li>
<li>ls：列出当前目录下的所有文件和目录名称</li>
<li>cd：切换目录</li>
<li>mkdir：创建目录</li>
<li>rmdir：删除目录（不允许删除空目录）</li>
<li>rm：删除文件或目录</li>
<li>cp：复制文件或目录</li>
<li>mv：移动文件或目录</li>
<li>touch：创建空文件</li>
<li>cat：查看文件内容</li>
<li>more：分页显示文件内容</li>
<li>less：分页显示文件内容</li>
<li>echo：输出内容到控制台  </li>
<li>head：显示文件头部内容</li>
<li>tail：显示文件尾部内容</li>
<li>ln：创建链接文件</li>
<li>”&gt;“：输出重定向</li>
<li>“&gt;&gt;”：在文件末尾追加内容</li>
</ul>
<h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><h3 id="date指令-显示当前时间"><a href="#date指令-显示当前时间" class="headerlink" title="date指令-显示当前时间"></a>date指令-显示当前时间</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> [选项] [+指定的格式]</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> 显示当前时间</span><br><span class="line"><span class="built_in">date</span> +%Y 显示当前年份</span><br><span class="line"><span class="built_in">date</span> +%m 显示当前月份</span><br><span class="line"><span class="built_in">date</span> +%d 显示当前哪一天</span><br><span class="line"><span class="built_in">date</span> +%H 显示当前小时</span><br><span class="line"><span class="built_in">date</span> +%M 显示当前分钟</span><br><span class="line"><span class="built_in">date</span> +%S 显示当前秒</span><br><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span> 显示当前时间(年月日时分秒)</span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure></p>
<h3 id="date指令-设置日期"><a href="#date指令-设置日期" class="headerlink" title="date指令-设置日期"></a>date指令-设置日期</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;日期时间&quot;</span></span><br></pre></td></tr></table></figure><br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2019-01-01 12:00:00&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cal [选项] [月份] [年份]</span><br></pre></td></tr></table></figure><br>功能描述：不加任何参数，显示当前月份的日历<br>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cal 2019</span><br></pre></td></tr></table></figure></p>
<h2 id="搜素查找类"><a href="#搜素查找类" class="headerlink" title="搜素查找类"></a>搜素查找类</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><p>find指令将从指定目录向下递归遍历其各个子目录，查找符合条件的文件或目录，显示在终端<br>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find [搜索范围] [选项] [匹配条件]</span><br></pre></td></tr></table></figure><br>选项说明：<br>-name：按照文件名查找<br>-type：按照文件类型查找<br>-size：按照文件大小查找<br>-user：按照文件属主查找<br>-group：按照文件属组查找<br>-mtime：按照文件的更改时间查找</p>
<p>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">&quot;test.txt&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h3><p>locate指令可以快速定位文件路径。locate利用事先建立的系统中所有文件名称及路径的数据库实现快速定位。locate无需遍历整个文件系统，查询速度较快。<br>但是为了保证查询结果的准确性，需要定期更新数据库，因为系统中的文件会不断的增加和删除，如果不更新数据库，就会导致查询结果不准确。</p>
<p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate [选项] [匹配条件]</span><br></pre></td></tr></table></figure><br>注意：<br>由于locate基于数据库查询，所以第一次运行前，必须使用updatedb命令，建立数据库</p>
<p>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate test.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="grep指令和管道符号“-”"><a href="#grep指令和管道符号“-”" class="headerlink" title="grep指令和管道符号“|”"></a>grep指令和管道符号“|”</h3><p>grep过滤查找，管道符号“|”将前一个命令的输出结果，作为后一个命令的输入内容<br>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [选项] [匹配条件] [文件]</span><br></pre></td></tr></table></figure><br>常用选项：<br>-i：忽略大小写<br>-v：反向选择，显示不匹配的内容<br>-n：显示行号<br>-c：统计匹配到的行数<br>-A：显示匹配到的内容以及后面的n行</p>
<p>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i <span class="string">&quot;test&quot;</span> test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h2><h3 id="gzip-gunzip指令"><a href="#gzip-gunzip指令" class="headerlink" title="gzip/gunzip指令"></a>gzip/gunzip指令</h3><p>gzip指令用于压缩文件，压缩后的文件名称为原文件名称后面加上.gz后缀名，原文件会被删除<br>gunzip指令用于解压缩文件，解压缩后的文件名称为原文件名称去掉.gz后缀名，原文件会被删除</p>
<p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip [选项] [文件]</span><br><span class="line">gunzip [选项] [文件]</span><br></pre></td></tr></table></figure></p>
<p>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip test.txt</span><br><span class="line">gunzip test.txt.gz</span><br></pre></td></tr></table></figure></p>
<h3 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip/unzip指令"></a>zip/unzip指令</h3><p>zip指令用于压缩文件，压缩后的文件名称为原文件名称后面加上.zip后缀名，原文件不会被删除<br>unzip指令用于解压缩文件，解压缩后的文件名称为原文件名称去掉.zip后缀名，原文件不会被删除</p>
<p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip [选项] [压缩包名称] [文件]</span><br><span class="line">unzip [选项] [压缩包名称]</span><br></pre></td></tr></table></figure><br>常用选项：</p>
<ul>
<li>zip<br>-r：递归压缩目录下的所有文件</li>
<li>unzip<br>-d：指定解压缩目录</li>
</ul>
<p>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip test.zip test.txt</span><br><span class="line">unzip test.zip</span><br></pre></td></tr></table></figure></p>
<h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p>tar是打包命令，最后打包的文件是.tar.gz格式的，也就是说，tar命令会先打包，然后再压缩</p>
<p>基本语法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar [选项] [压缩包名称] [文件]</span><br></pre></td></tr></table></figure><br>选项说明：<br>-c：产生.tar打包文件<br>-z：打包同时压缩<br>-x：解压缩.tar.gz文件<br>-v：显示详细信息<br>-f：指定压缩包名称</p>
<p>应用案例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf test.tar.gz test.txt</span><br><span class="line">tar -xzvf test.tar.gz</span><br></pre></td></tr></table></figure></p>
<h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Linux中的每个用户必须属于一个组，一个用户可以属于多个组，但是一个组只能有一个组长，组长一般是创建组的用户，组长可以将组中的其他用户踢出组，也可以将组中的其他用户提升为组长</p>
<ul>
<li>所有者</li>
<li>所在组</li>
<li>其他组</li>
<li>改变用户所在组</li>
</ul>
<h2 id="文件-目录所有者"><a href="#文件-目录所有者" class="headerlink" title="文件/目录所有者"></a>文件/目录所有者</h2><p>一般为文件的创造者</p>
<h3 id="查看文件所有者"><a href="#查看文件所有者" class="headerlink" title="查看文件所有者"></a>查看文件所有者</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>
<h3 id="改变文件所有者"><a href="#改变文件所有者" class="headerlink" title="改变文件所有者"></a>改变文件所有者</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [新所有者] [文件]</span><br></pre></td></tr></table></figure>
<h2 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd [组名]</span><br></pre></td></tr></table></figure>
<h2 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a>文件/目录所在组</h2><p>当用户创建一个文件或目录时，该文件或目录的所在组默认为用户的所在组</p>
<h3 id="查看文件所在组"><a href="#查看文件所在组" class="headerlink" title="查看文件所在组"></a>查看文件所在组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>
<h3 id="改变文件所在组"><a href="#改变文件所在组" class="headerlink" title="改变文件所在组"></a>改变文件所在组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [新所在组] [文件]</span><br></pre></td></tr></table></figure>
<h2 id="其他组"><a href="#其他组" class="headerlink" title="其他组"></a>其他组</h2><p>除了文件的所有者和所在组之外，其他用户都属于其他组</p>
<h2 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -g [新所在组] [用户]</span><br><span class="line">usermod -d [新家目录] [用户]</span><br></pre></td></tr></table></figure>
<h2 id="权限基本介绍"><a href="#权限基本介绍" class="headerlink" title="权限基本介绍"></a>权限基本介绍</h2><p>ls -l命令显示的文件信息中，第一个字符代表文件类型，后面的字符代表文件权限</p>
<p>0-9位说明：<br>第0位确定文件类型</p>
<ul>
<li>l：链接文件</li>
<li>d：目录文件</li>
<li>-：普通文件</li>
<li>c：字符设备文件</li>
<li>b：块设备文件<br>第1-3位确定所有者权限 -User<br>第4-6位确定所在组权限 -Group<br>第7-9位确定其他组权限 -Other</li>
</ul>
<h2 id="rwx权限（难点）"><a href="#rwx权限（难点）" class="headerlink" title="rwx权限（难点）"></a><strong><em>rwx权限</em></strong>（难点）</h2><ul>
<li>r：读权限</li>
<li>w：写权限</li>
<li>x：执行权限</li>
</ul>
<h3 id="作用到目录"><a href="#作用到目录" class="headerlink" title="作用到目录"></a>作用到目录</h3><ul>
<li>r：可以查看目录中的文件列表</li>
<li>w：可以在目录中创建、删除、重命名文件</li>
<li>x：可以进入目录</li>
</ul>
<h2 id="文件-目录权限案例"><a href="#文件-目录权限案例" class="headerlink" title="文件/目录权限案例"></a>文件/目录权限案例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 0 6月  10 11:00 test.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>第0位：-，代表普通文件</li>
<li>第1-3位：rw-，代表所有者权限，可以读写，不能执行</li>
<li>第4-6位：r—，代表所在组权限，可以读，不能写和执行</li>
<li>第7-9位：r—，代表其他组权限，可以读，不能写和执行</li>
</ul>
<h2 id="修改权限chmod指令"><a href="#修改权限chmod指令" class="headerlink" title="修改权限chmod指令"></a>修改权限chmod指令</h2><p>通过chmod指令可以修改文件或目录的权限</p>
<h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><p><strong>通过”+“，”-“和“=”来修改权限</strong><br>u：所有者<br>g：所在组<br>o：其他组<br>a：所有人<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [u/g/o/a] [+/=/-] [r/w/x] [文件]</span><br></pre></td></tr></table></figure></p>
<h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p><strong>通过数字来修改权限</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [数字] [文件]</span><br></pre></td></tr></table></figure><br>数字说明：</p>
<ul>
<li>r：4</li>
<li>w：2</li>
<li>x：1</li>
</ul>
<h2 id="修改所有者chown指令"><a href="#修改所有者chown指令" class="headerlink" title="修改所有者chown指令"></a>修改所有者chown指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> newuser [文件/目录] 改变所有者</span><br><span class="line"><span class="built_in">chown</span> newuser:newgroup [文件/目录] 改变所有者和所在组</span><br><span class="line">-R 递归修改</span><br></pre></td></tr></table></figure>
<h2 id="修改所在组chgrp指令"><a href="#修改所在组chgrp指令" class="headerlink" title="修改所在组chgrp指令"></a>修改所在组chgrp指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> newgroup [文件/目录] 改变所在组</span><br></pre></td></tr></table></figure>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h1 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h1><h1 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h1><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h1 id="进程管理（重点）"><a href="#进程管理（重点）" class="headerlink" title="进程管理（重点）"></a>进程管理（重点）</h1><h1 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高级篇</title>
    <url>/post/52e8d5e4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/post/1bff3c65.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus</title>
    <url>/post/8086094.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/post/d8a440d1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle</title>
    <url>/post/f145fed6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/post/41e00c03.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://imlql.cn/categories/设计模式/">分类: 设计模式 | 风祈的时光录 (imlql.cn)</a></p>
<p>面试题：</p>
<ul>
<li><p>原型设计模式问题：</p>
<ol>
<li>有请使用UML类图画出原型模式核心角色</li>
<li>原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码(重写 clone方法实现深拷贝、使用序列化来实现深拷贝)</li>
<li>在Spring框架中哪里使用到原型模式，并对源码进行分析 beans.xml  Java设计模式内容介绍</li>
<li>Spring中原型bean的创建，就是原型模式的应用</li>
<li>代码分析+Debug源码</li>
</ol>
</li>
<li><p>设计模式的七大原则：</p>
<ol>
<li>七大设计原则核心思想</li>
<li>能够以类图的说明设计原则</li>
<li>在项目实际开发中，你在哪里使用到了ocp原则</li>
</ol>
</li>
<li><p>解释器设计模式：</p>
<ol>
<li>介绍解释器设计模式是什么？</li>
<li>画出解释器设计模式的UML类图, 分析设计模式中的各个角色是什 么?</li>
<li>请说明Spring的框架中，哪里使用到了解释器设计模式，并做源码级别的分析</li>
</ol>
</li>
<li><p>解释器模式在Spring框架应用的源码剖析：</p>
<ol>
<li>Spring框架中 SpelExpressionParser就使用到解释器模式</li>
<li>代码分析+Debug源码+模式角色分析说明</li>
</ol>
</li>
<li><p>单例设计模式一共有几种实现方式？请分别用代码实现，并说明各个实现方式的 优点和缺点?</p>
</li>
<li><p>设计模式的重要性：</p>
<p>①软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人 在1990年代从建筑设计领域引入到计算机科学的</p>
<p>②大厦 VS 简易房</p>
<p>③拿实际工作经历来说, 当一个项目开发完后，如果客户提出增新功能，怎么办?</p>
<p>④如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? （维护性【可读性、 规范性】）</p>
<p>⑤目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中使用过什么 设计模式，怎样使用的，解决了什么问题。</p>
<p>⑥设计模式在软件中哪里？面向对象(oo)=&gt;功能模块[设计模式+算法(数据结构)]=&gt;框 架[使用到多种设计模式]=&gt;架构 [服务器集群]</p>
<p>⑦如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的</p>
</li>
</ul>
<p>单例模式：独一无二，全局唯一</p>
<p>工厂方法：创建产品，子类定制</p>
<p>抽象工厂：产品族，创建系列</p>
<p>建造者模式：一步一步，构建复杂</p>
<p>原型模式：复制粘贴，一模一样</p>
<p>适配器模式：接口不同，转换器</p>
<p>组合模式：树状结构，递归遍历</p>
<p>代理模式：控制访问，增强安全</p>
<p>享元模式：共享对象，节省内存</p>
<p>外观模：统一接口，简化调用</p>
<p>桥接模式：抽象和实现，解耦合</p>
<p>装饰器模式：包装对象，增强功能</p>
<p>模板方法：抽象父类，子类实现</p>
<p>中介者模式：统一协调，对象解耦</p>
<p>责任链模式：链式处理，一环接一环</p>
<p>观察者模式：一对多，消息通知</p>
<p>策略模式：算法替换，灵活变化</p>
<p>命令模式：请求封装，解耦合</p>
<p>状态模式：状态切换，行为变化</p>
<p>访问者模式：操作对象，分离算法</p>
<p>迭代器模式：遍历集合，无需暴露</p>
<p>解释器模式：语法解析，执行操作</p>
<p>备忘录模式：状态保存，恢复原状</p>
<h1 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h1><p>设计模式的目的：编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：①代码重用性 (相同功能的代码，不用多次编写)②可读性 (编程规范性, 便于其他程序员的阅读和理解) ③可扩展性 (当需要增加新的功能时，非常的方便，称为可维护) ④可靠性 (当我们增加新的功能后，对原来的功能没有影响) ⑤使程序呈现高内聚，低耦合的特性</p>
<p>设计模式常用的七大原则有：</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转(倒置)原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<p>设计原则核心思想：</p>
<ol>
<li>找出应用中可能需要变化之处，将其独立出来</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>交互对象间的松耦合设计</li>
</ol>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.singleresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 交通工具类</span></span><br><span class="line"><span class="comment"> * 方式一</span></span><br><span class="line"><span class="comment"> * run方法中违反了单一职责原则（根据工具运行方法不同，分成不同的类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span> &#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.singleresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RoadVehicle</span> <span class="variable">roadVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoadVehicle</span>();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">AirVehicle</span> <span class="variable">airVehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirVehicle</span>();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方案二</span></span><br><span class="line"><span class="comment"> * 遵守单一职责原则</span></span><br><span class="line"><span class="comment"> * 改动较大，类分解即修改客户端</span></span><br><span class="line"><span class="comment"> * 改进：直接修改Vehcle类，改动较少-&gt;方案三</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoadVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;空中运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterVehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.singleresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleResponsibility3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle2</span> <span class="variable">vehicle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vehicle2</span>();</span><br><span class="line">        vehicle2.runRoad(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在类上未遵守单一职责原则。但在方法上遵守单一职责原则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runRoad</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAir</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在空中运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runWater</span><span class="params">(String vehicle)</span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在水中运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>降低类的复杂度，一个类只负责一项职责</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该依赖它不需要的接 口，即一个类对另一个类的依赖 应该建立在最小的接口上</p>
<p>应用实例：类A通过接口Interface1依赖类B， 类C通过接口Interface1依赖类D， 请编写代码完成此应用实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.segregation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Segregation1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.operation1();</span><br><span class="line">        b.operation2();</span><br><span class="line">        b.operation3();</span><br><span class="line">        b.operation4();</span><br><span class="line">        b.operation5();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.depend1(b);</span><br><span class="line">        a.depend2(b);</span><br><span class="line">        a.depend3(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">        d.operation1();</span><br><span class="line">        d.operation2();</span><br><span class="line">        d.operation3();</span><br><span class="line">        d.operation4();</span><br><span class="line">        d.operation5();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.depend1(d);</span><br><span class="line">        c.depend4(d);</span><br><span class="line">        c.depend5(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="comment">//A类通过接口Interface依赖（使用）B类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;<span class="comment">//C类通过接口Interface依赖（使用）D类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应传统方法的问题和使用接口隔离原则改进 1) 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不 需要的方法 2) 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立 依赖关系。也就是采用接口隔离原则 3) 接口Interface1中出现的方法，根据实际情况拆分为三个接口 4) 代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.segregation.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Segregation1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> <span class="title class_">B</span>());<span class="comment">//A类通过接口依赖B类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.depend1(<span class="keyword">new</span> <span class="title class_">D</span>());<span class="comment">//C类通过接口依赖D类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> <span class="title class_">D</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口1</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口2</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口3</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Interface3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>,Interface2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B中实现了operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">implements</span> <span class="title class_">Interface1</span>,Interface3 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D中实现了operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="comment">//A类通过接口Interface依赖（使用）B类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend2</span><span class="params">(Interface2 interface2)</span>&#123;</span><br><span class="line">        interface2.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend3</span><span class="params">(Interface2 interface2)</span>&#123;</span><br><span class="line">        interface2.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;<span class="comment">//C类通过接口Interface依赖（使用）D类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend1</span><span class="params">(Interface1 interface1)</span>&#123;</span><br><span class="line">        interface1.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend4</span><span class="params">(Interface3 interface3)</span>&#123;</span><br><span class="line">        interface3.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">depend5</span><span class="params">(Interface3 interface3)</span>&#123;</span><br><span class="line">        interface3.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖倒转-倒置-原则"><a href="#依赖倒转-倒置-原则" class="headerlink" title="依赖倒转(倒置)原则"></a>依赖倒转(倒置)原则</h2><p>依赖倒转原则(Dependence Inversion Principle)是指： 1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象 2) 抽象不应该依赖细节，细节应该依赖抽象 3) 依赖倒转(倒置)的中心思想是面向接口编程 4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的 多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象 指的是接口或抽象类，细节就是具体的实现类 5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p>
<p>应用实例：请编程完成Person接收消息的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependecyInversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.recevie(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件：hello world！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进：引入一个抽象的接口，表示接收者，使Person类和接口发生依赖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recevie</span><span class="params">(Email email)</span> &#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖倒转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependecyInversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.recevie(<span class="keyword">new</span> <span class="title class_">Email</span>());</span><br><span class="line">        person.recevie(<span class="keyword">new</span> <span class="title class_">Wechat</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRecevie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">IRecevie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电子邮件：hello world！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wechat</span> <span class="keyword">implements</span> <span class="title class_">IRecevie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信信息：hello， ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//对接口的依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recevie</span><span class="params">(IRecevie iRecevie)</span> &#123;</span><br><span class="line">        System.out.println(iRecevie.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖关系传递的三种方式</p>
<ol>
<li><p>接口传递</p>
</li>
<li><p>构造方法传递</p>
</li>
<li><p>setter方式传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyPass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChangHong</span> <span class="variable">changHong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangHong</span>();</span><br><span class="line">        <span class="type">Switch1</span> <span class="variable">switch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch1</span>();</span><br><span class="line">        switch1.open(changHong);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChangHong2</span> <span class="variable">changHong2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangHong2</span>();</span><br><span class="line">        <span class="type">Switch2</span> <span class="variable">switch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch2</span>(changHong2);</span><br><span class="line">        switch2.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ChangHong3</span> <span class="variable">changHong3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangHong3</span>();</span><br><span class="line">        <span class="type">Switch3</span> <span class="variable">switch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Switch3</span>();</span><br><span class="line">        switch3.setTV3(changHong3);</span><br><span class="line">        switch3.open();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式一：通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">//开关的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwitch</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV TV)</span>;<span class="comment">//抽象方法，抽象接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangHong</span> <span class="keyword">implements</span> <span class="title class_">ITV</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch1</span> <span class="keyword">implements</span> <span class="title class_">ISwitch</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(ITV TV)</span> &#123;</span><br><span class="line">        TV.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过构造方法传递依赖</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwitch2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangHong2</span> <span class="keyword">implements</span> <span class="title class_">ITV2</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机2打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch2</span> <span class="keyword">implements</span> <span class="title class_">ISwitch2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV2 itv2;<span class="comment">//成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Switch2</span><span class="params">(ITV2 itv2)</span>&#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="built_in">this</span>.itv2 = itv2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itv2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：setter方式传递</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ISwitch3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTV3</span><span class="params">(ITV3 itv3)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Switch3</span> <span class="keyword">implements</span> <span class="title class_">ISwitch3</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV3 itv3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTV3</span><span class="params">(ITV3 itv3)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itv3 = itv3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.itv3.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangHong3</span> <span class="keyword">implements</span> <span class="title class_">ITV3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机3打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：</p>
<ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li>
<li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契 约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实 现的方法任意修改，就会对整个继承体系造成破坏。 2) 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵 入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子 类的功能都有可能产生故障 3) 问题提出：在编程中，如何正确的使用继承 =&gt; 里氏替换原则</p>
<p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。 3) 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 4) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可 以通过聚合，组合，依赖 来解决问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.liskov;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span>+a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span>+a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span>+b.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span>+b.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span>+b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B类继承了A类</span></span><br><span class="line"><span class="comment">//增加了一个新功能：完成两个数相加，然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//这里重写了A类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b)+<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.liskov.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Liskov</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span>+a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1-8=&quot;</span>+a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//B类不再继承A类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11+3=&quot;</span>+b.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;1+8=&quot;</span>+b.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;11+3+9=&quot;</span>+b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//使用组合仍可以使用A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;11-3=&quot;</span>+b.func3(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="comment">//返回两个数的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1-num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="comment">//这里重写了A类的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b)+<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用A的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</p>
<p>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。</p>
<p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类【使用方】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shape.m_type == <span class="number">1</span>)</span><br><span class="line">            drawRectangle(shape);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shape.m_type == <span class="number">2</span>)</span><br><span class="line">            drawCircle(shape);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (shape.m_type == <span class="number">3</span>)</span><br><span class="line">            drawTriangle(shape);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    Rectangle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    Circle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    Triangle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>优点：比较好理解，简单易操作</li>
<li>缺点：违反了设计模式的ocp原则，即对扩展开放(提供方)，对修改关闭(使用方)。 即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码</li>
</ul>
<p>改进：创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可， 这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可， 使用方的代码就不需要修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.ocp.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">OtherGraphic</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类【使用方】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span>&#123;</span><br><span class="line">    <span class="comment">//接受Shape对象，调用draw方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> m_type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Rectangle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Circle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    Triangle()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherGraphic</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    OtherGraphic()&#123;</span><br><span class="line">        <span class="built_in">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制其他图形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>一个对象应该对其他对象保持最少的了解</p>
<p>类与类关系越密切，耦合度越大</p>
<p>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息</p>
<p>更简单的定义：只与直接的朋友通信【直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部】</p>
<p>应用实例：有一个学校，下属有各个学院和 总部，现要求打印出学校总部员 工ID和学院员工的id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.demeter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建了一个SchoolManager对象</span></span><br><span class="line">        <span class="type">SchoolManager</span> <span class="variable">schoolManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolManager</span>();</span><br><span class="line">        <span class="comment">//输出学院的员工id和学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManager</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//这里我们增加了10个员工到list</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析SchoolManager类的直接朋友类：Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee不是直接朋友而是一个陌生类，这样违背了迪米特法则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;<span class="comment">//这里我们增加了5个员工到list</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 这里的CollegeEmployee不是SchoolManager的直接朋友</span></span><br><span class="line">        <span class="comment">//2. CollegeEmployee是以局部变量方式出现在SchoolManager</span></span><br><span class="line">        <span class="comment">//3. 违反了迪米特法则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进：1) 前面设计的问题在于SchoolManager中，CollegeEmployee类并不是 SchoolManager类的直接朋友 (分析) 2) 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合 3) 对代码按照迪米特法则 进行改进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.demeter.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demeter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~~~使用迪米特法则的改进~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//创建了一个SchoolManager对象</span></span><br><span class="line">        <span class="type">SchoolManager</span> <span class="variable">schoolManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolManager</span>();</span><br><span class="line">        <span class="comment">//输出学院的员工id和学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> <span class="title class_">CollegeManager</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollegeManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//这里我们增加了10个员工到list</span></span><br><span class="line">            <span class="type">CollegeEmployee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeEmployee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析SchoolManager类的直接朋友类：Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee不是直接朋友 而是一个陌生类，这样违背了迪米特法则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SchoolManager</span> &#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getAllEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;<span class="comment">//这里我们增加了5个员工到list</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllEmployee</span><span class="params">(CollegeManager sub)</span> &#123;</span><br><span class="line">        <span class="comment">//分析问题</span></span><br><span class="line">        <span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">        sub.printEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="built_in">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>迪米特法则的核心是降低类之间的耦合</li>
<li>由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低 类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>UML——Unified modeling language UML  (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软 件开发人员进行思考和记录思路的结果 2) UML本身是一套符号的规定，就像数学 符号和化学符号一样，这些符号用于描 述软件模型中的各个元素和他们之间的 关系，比如类、接口、实现、泛化、依 赖、组合、聚合等，如右图: 3) 使用UML来建模，常用的工具有 Rational  Rose , 也可以使用一些插件来建模</p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>分类：</p>
<ol>
<li>用例图(use case)</li>
<li>静态结构图：类图、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li>
</ol>
<p>说明：</p>
<ol>
<li>类图是描述类与类之间的关系的，是UML图中最核心的</li>
<li>在讲解设计模式时，我们必然会使用类图</li>
</ol>
<h2 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h2><p>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系</p>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，无法通过编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IDCard <span class="title function_">getIDCard</span><span class="params">(Integer personid)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDao</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系实际上就是继承关系，是依赖关系的特例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DaoSupport</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Object entity)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Object id)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceBean</span> <span class="keyword">extends</span> <span class="title class_">Daosupport</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系实际上就是A类实现B接口，是依赖关系的特例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Interger id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceBean</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Interger id)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系实际上就是类与类之间的联系，他是依赖关系的特例，关联具有导航性：即双向关系或单向关系 关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个）， “0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m 个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单向一对一关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双向一对一关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，具有关联的导航性与多重性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">    <span class="keyword">private</span> Monitor monitor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系也是整体与部分的关系，但是整体与部分不可以分开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Head</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Head</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDCard</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式分为三种类型，共23种：</p>
<ol>
<li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享 元模式、代理模式</li>
<li>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者 模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)</li>
</ol>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)</p>
<p>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p>
<p>使用场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等</p>
<h3 id="饿汉式（静态变量）"><a href="#饿汉式（静态变量）" class="headerlink" title="饿汉式（静态变量）"></a>饿汉式（静态变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤：</span></span><br><span class="line"><span class="comment">//构造器私有化 (防止new)</span></span><br><span class="line"><span class="comment">//类的内部创建对象</span></span><br><span class="line"><span class="comment">//向外暴露一个静态的公共方法getInstance</span></span><br><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式（静态变量）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化，外部可以new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>优点：写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题</li>
<li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费</li>
<li>基于classloder机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到lazy loading的效果</li>
</ul>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式（静态代码块）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化，外部可以new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//在静态代码块中，创建单例对象</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点相同</li>
<li>结论：这种单例模式可用，但是可能造成内存浪费</li>
</ul>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式1，线程不安全&quot;</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式（线程不安全）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance（即懒汉式）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li>
<li>如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式</li>
<li>结论：在实际开发中，不要使用这种方式</li>
</ul>
<h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式2，线程安全&quot;</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式（线程安全，同步方法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题（即懒汉式）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>优点：解决了线程不安全问题</li>
<li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低</li>
<li>结论：在实际开发中，不推荐使用这种方式</li>
</ul>
<h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式3，线程安全&quot;</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式（线程安全，同步代码块）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>是对第四种实现方式的改进，因为前面同步方法效率太低， 改为同步产生实例化的的代码块</li>
<li>但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一 致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行， 另一个线程也通过了这个判断语句，这时便会产生多个实例</li>
<li>结论：在实际开发中，不能使用这种方式</li>
</ul>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;双重检查&quot;</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了</li>
<li>实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步</li>
<li>线程安全；延迟加载；效率较高</li>
<li>结论：在实际开发中，推荐使用这种单例设计模式</li>
</ul>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用静态内部类完成单例模式&quot;</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()=&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()=&quot;</span>+singleton2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类完成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//写一个静态内部类，类中含有一个静态属性singleton</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>采用了类装载的机制来保证初始化实例时只有一个线程</li>
<li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化</li>
<li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的</li>
<li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li>
<li>推荐使用</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atuguigu.singleton.type8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(singleton1 == singleton2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;singleton1.hashCode()&quot;</span>+singleton1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton2.hashCode()&quot;</span>+singleton2.hashCode());</span><br><span class="line">        singleton1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用枚举，实现单例</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;枚举实现单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</li>
<li>推荐使用</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的 依赖关系的解耦。从而提高项目的扩展和维护性</p>
<p>设计模式的依赖抽象原则：</p>
<ul>
<li>创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。变量不要直接持有具体类的引用。</li>
<li>不要让类继承具体类，而是继承抽象类或者是实现interface(接口)</li>
<li>不要覆盖基类中已经实现的方法</li>
</ul>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式属于创建型模式，是工厂模式的一种，是由一个工厂对象决定创建出哪一种产品类的实例。是工厂模式中最简单实用的模式。简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码) 。在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式</p>
<p>完成披萨店订购功能</p>
<ul>
<li><p>传统方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">				pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">				pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">				pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">				pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">				pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出pizza 制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：好理解，简单易操作</li>
<li><p>缺点：违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增 加新功能的时候，尽量不修改代码，或者尽可能少修改代码</p>
</li>
<li><p>简单工厂模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个可以实例化Pizaa对象的类，封装创建对象的代码</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.factory.simplefactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.simplefactory.pizzastore.pizza.CheesePizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.simplefactory.pizzastore.pizza.GreekPizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.simplefactory.pizzastore.pizza.PepperPizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="comment">//增加orderType返回对应的Pizza对象</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">creatPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;希腊披萨&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;奶酪披萨&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//简单工厂模式，也叫静态工厂模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title function_">creatPizza2</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;希腊披萨&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;奶酪披萨&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OrderPizza.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.factory.simplefactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">    SimpleFactory simpleFactory;</span><br><span class="line">    <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line">        setFactory(simpleFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入的</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = <span class="built_in">this</span>.simpleFactory.creatPizza(orderType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出pizza</span></span><br><span class="line">            <span class="keyword">if</span>(pizza != <span class="literal">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购披萨失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类</p>
<p>客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、 北京的胡椒pizza 或者是伦敦的奶酪pizza、伦敦的胡椒pizza</p>
<ul>
<li>使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、 LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是很好</li>
<li>使用工厂方法模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OrderPizza.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.factory.factorymethod.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line">    <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line">            <span class="comment">//输出pizza 制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BJOrderPizza.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.factory.factorymethod.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。可以根据创建对象类型使用对应的工厂子类。将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.factory.absfactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line">    <span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LDFactory.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.factory.absfactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.absfactory.pizzastore.pizza.LDCheesePizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.absfactory.pizzastore.pizza.LDPepperPizza;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;~使用的是抽象工厂模式~&quot;</span>);</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OrderPizza.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.factory.absfactory.pizzastore.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    AbsFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(AbsFactory factory)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span></span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123; <span class="comment">// 订购ok</span></span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>JDK中Calendar中使用了简单工厂模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节</p>
<p>工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p>
<p>注意：</p>
<ol>
<li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时能够提高效率</li>
<li>不用重新初始化对象，而是动态地获得对象运行时的状态</li>
<li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化， 无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
<li>缺点：需要为每一个类配备一个克隆方法，对已有的类进行改造时，需要修改其源代码，违背了ocp原则</li>
</ol>
<p>克隆羊问题：现在有一只羊tom，姓名为:tom, 年龄为1，颜色为白色，请编写程序创建和tom羊属性完全相同的10只羊</p>
<ul>
<li><p>传统方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传统的方法</span></span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line"></span><br><span class="line">        System.out.println(sheep);</span><br><span class="line">        System.out.println(sheep2);</span><br><span class="line">        System.out.println(sheep3);</span><br><span class="line">        System.out.println(sheep4);</span><br><span class="line">        System.out.println(sheep5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sheep</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>优点：较好理解，简单易操作</li>
<li>缺点：在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂 时，效率较低。总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li>
</ul>
</li>
<li><p>原型模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改进：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt; 原型模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;模型原型完成对象的创建&quot;</span>);</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        sheep.friend = <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> (Sheep)sheep.clone(); <span class="comment">//克隆</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sheep3 =&quot;</span> + sheep3 + <span class="string">&quot;sheep3.friend=&quot;</span> + sheep3.friend.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sheep4 =&quot;</span> + sheep4 + <span class="string">&quot;sheep4.friend=&quot;</span> + sheep4.friend.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;sheep5 =&quot;</span> + sheep5 + <span class="string">&quot;sheep5.friend=&quot;</span> + sheep5.friend.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sheep</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;蒙古羊&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> Sheep friend; <span class="comment">//是对象，克隆羊如果处理，默认是深拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆该实例，使用默认的clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep)<span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p><a href="https://blog.csdn.net/baiye_xing/article/details/71788741">(21条消息) 【Java深入】深拷贝与浅拷贝详解_白夜行515的博客-CSDN博客</a></p>
<ul>
<li><p>浅拷贝</p>
<p>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将 该属性值复制一份给新的对象。对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个 实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
<p>浅拷贝是使用默认的<code>clone</code>()方法来实现</p>
</li>
<li><p>深拷贝</p>
<p>复制对象的所有基本数据类型的成员变量值。为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。即，对象进行深拷贝要对整个对象进行拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现方法：</span></span><br><span class="line"><span class="comment">//1.重写clone方法来实现深拷贝</span></span><br><span class="line"><span class="comment">//2.通过对象序列化实现深拷贝(推荐)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DeepCloneableTarget</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype.deepclone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span><span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="built_in">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该类属性均为String，使用默认的clone完成</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DeepProtoType</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype.deepclone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepProtoType</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepProtoType</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝--方式一，使用clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//完成对基本数据类型（属性）和String的克隆</span></span><br><span class="line">        deep = <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//对引用类型的属性进行单独处理</span></span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">deepProtoType</span> <span class="operator">=</span> (DeepProtoType) deep;</span><br><span class="line">        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();</span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝--方式二，通过对象的序列化实现</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            byteArrayOutputStream = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            objectOutputStream = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">            objectOutputStream.writeObject(<span class="built_in">this</span>);<span class="comment">//当前对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            byteArrayInputStream = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">            objectInputStream = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">            <span class="type">DeepProtoType</span> <span class="variable">copyObj</span> <span class="operator">=</span> (DeepProtoType) objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">                byteArrayInputStream.close();</span><br><span class="line">                objectOutputStream.close();</span><br><span class="line">                objectInputStream.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.priototype.deepclone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">deepProtoType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepProtoType</span>();</span><br><span class="line">        deepProtoType.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        deepProtoType.deepCloneableTarget = <span class="keyword">new</span> <span class="title class_">DeepCloneableTarget</span>(<span class="string">&quot;大牛&quot;</span>,<span class="string">&quot;小牛&quot;</span>);</span><br><span class="line">        <span class="comment">//方式一，完成深拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方式一：&quot;</span>);</span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">deepProtoType1</span> <span class="operator">=</span> (DeepProtoType) deepProtoType.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;deepProtoType.name=&quot;</span>+deepProtoType.name+<span class="string">&quot;  deepProtoType.deepCloneableTarget=&quot;</span>+deepProtoType.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;deepProtoType1.name=&quot;</span>+deepProtoType.name+<span class="string">&quot;  deepProtoType1.deepCloneableTarget=&quot;</span>+deepProtoType1.deepCloneableTarget.hashCode());</span><br><span class="line">        <span class="comment">//方式二，完成深拷贝</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方式二：&quot;</span>);</span><br><span class="line">        <span class="type">DeepProtoType</span> <span class="variable">deepProtoType2</span> <span class="operator">=</span> (DeepProtoType) deepProtoType.deepClone();</span><br><span class="line">        System.out.println(<span class="string">&quot;deepProtoType.name=&quot;</span>+deepProtoType.name+<span class="string">&quot;  deepProtoType.deepCloneableTarget=&quot;</span>+deepProtoType.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;deepProtoType1.name=&quot;</span>+deepProtoType.name+<span class="string">&quot;  deepProtoType1.deepCloneableTarget=&quot;</span>+deepProtoType1.deepCloneableTarget.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码分析（Spring）"><a href="#源码分析（Spring）" class="headerlink" title="源码分析（Spring）"></a>源码分析（Spring）</h3><p>Spring中原型bean的创建就是原型模式的应用</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</p>
<p>四个角色:</p>
<ol>
<li><p>Product（产品角色）： 一个具体的产品对象</p>
</li>
<li><p>Builder（抽象建造者）： 创建一个Product对象的各个部件指定的接口/抽象类</p>
</li>
<li><p>ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件</p>
</li>
<li><p>Director（指挥者）： 构建一个使用Builder接口的对象，主要用于创建一个复杂的对象。</p>
<p>作用：①隔离了客户与对象的生产过程；②负责控制产品对象的生产过程</p>
</li>
</ol>
<p>盖房子项目：</p>
<ul>
<li><p>传统方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractHouse.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHouse</span> &#123;</span><br><span class="line">    <span class="comment">//打地基</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//砌墙</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CommonHouse.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">AbstractHouse</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子打地基&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子砌墙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子封顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>优点：比较好理解，简单易操作</li>
<li>缺点：设计的程序结构过于简单，没有设计缓存层对象，程序的扩展和维护不好。即，这种设计方案，把产品和创建产品的过程封装在一起，耦合性增强</li>
</ul>
</li>
<li><p>建造者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.builder.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//普通房子</span></span><br><span class="line">        <span class="type">CommonHouse</span> <span class="variable">commonHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonHouse</span>();</span><br><span class="line">        <span class="comment">//准备房子的指挥者</span></span><br><span class="line">        <span class="type">HouseDirector</span> <span class="variable">houseDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>(commonHouse);</span><br><span class="line">        <span class="comment">//完成房子，返回产品</span></span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> houseDirector.constructHouse();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//盖高楼</span></span><br><span class="line">        <span class="type">HighBuilding</span> <span class="variable">highBuilding</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">HighBuilding</span>();</span><br><span class="line">        <span class="comment">//重置建造者</span></span><br><span class="line">        houseDirector.setHouseBuilder(highBuilding);</span><br><span class="line">        <span class="comment">//完成房子，返回产品</span></span><br><span class="line">        houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//HouseBuilder.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.builder.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象的制造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将制造的流程写好，抽象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//HouseDirector.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.builder.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者，动态的指挥制造流程，返回产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;</span><br><span class="line">    <span class="type">HouseBuilder</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器传入houseBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter传入housBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理建造房子的流程，交给指挥者</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">constructHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码分析（JDK）"><a href="#源码分析（JDK）" class="headerlink" title="源码分析（JDK）"></a>源码分析（JDK）</h3><p>java.lang.StringBuilder中的建造者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>,  CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建 造者, 定义了抽象方法</p>
<p>AbstractStringBuilder 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化</p>
<p>StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的 实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder</p>
<p>注意：</p>
<ul>
<li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程， 系统扩展方便，符合 “开闭原则”</li>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化， 导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式</li>
<li>抽象工厂模式VS建造者模式 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</li>
</ul>
<h2 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h2><p>适配器模式(Adapter Pattern，别名为包装器(Wrapper))，属于结构性模型，将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作</p>
<p>工作原理：</p>
<ul>
<li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li>
<li>从用户的角度看不到被适配者，是解耦的</li>
<li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li>
<li>用户收到反馈结果，感觉只是和目标接口交互</li>
</ul>
<p>注意：</p>
<ul>
<li><p>类适配器：以类给到，在Adapter里，就是将src当做类，继承</p>
<p>对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有</p>
<p>接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现</p>
</li>
<li><p>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作</p>
</li>
</ul>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>Adapter类，通过继承src类，实现dst类接口，完成src-&gt;dst的适配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IVoltage5V.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Phone.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Voltage220V.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voltage220V</span> &#123;</span><br><span class="line">    <span class="comment">//输出220V的电压</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output220V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//VoltageAdapter.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title class_">Voltage220V</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取到220V电压</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> output220V();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dstV</span> <span class="operator">=</span> srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.classadapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst必须是接口，有一定局限性</li>
<li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本</li>
<li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了</li>
</ul>
<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。 即：持有src类，实现dst类接口，完成src-&gt;dst的适配 ，在系统中尽量使用关联关系（聚合，组合）来替代继承关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=== 对象适配器 ===&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>(<span class="keyword">new</span> <span class="title class_">Voltage220V</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//VoltageAdapter.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.objectadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;<span class="comment">//关联关系中的聚合关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器，传入Voltage220V实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != voltage220V)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> voltage220V.output220V();<span class="comment">//获取220v的电压</span></span><br><span class="line">            System.out.println(<span class="string">&quot;使用对象适配器进行适配&quot;</span>);</span><br><span class="line">            dst = src/<span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;适配完成，电压为：&quot;</span> + dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口</li>
<li>使用成本更低，更灵活</li>
</ul>
<h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，适用于一个接口不想使用其所有的方法的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbsAdapter</span> <span class="variable">absAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbsAdapter</span>() &#123;</span><br><span class="line">            <span class="comment">//只需要覆盖需要使用的接口方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        absAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Interface4.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AbsAdapter.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.adapter.interfaceadapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AbsAdapter将Interface4的方法默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsAdapter</span> <span class="keyword">implements</span> <span class="title class_">Interface4</span> &#123;</span><br><span class="line">    <span class="comment">//默认实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码刨析（SpringMVC）"><a href="#源码刨析（SpringMVC）" class="headerlink" title="源码刨析（SpringMVC）"></a>源码刨析（SpringMVC）</h3><p>SpringMvc中的HandlerAdapter, 就使用了适配器模式</p>
<p>SpringMVC处理请求的流程回顾</p>
<p>使用HandlerAdapter 的原因：处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么 如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line"><span class="comment">// 通过HandlerMapping来映射Controller</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="comment">//获取适配器</span></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="comment">// 通过适配器调用controller的方法并返回ModelAndView</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明：</span></span><br><span class="line"><span class="comment">//Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</span></span><br><span class="line"><span class="comment">//适配器代替controller执行相应的方法</span></span><br><span class="line"><span class="comment">//扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了</span></span><br></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式(Bridge模式)是结构性数据模型，指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。其主要特点是把抽象(Abstraction)与行为实现 (Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</p>
<p>注意：</p>
<ul>
<li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统</li>
<li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成</li>
<li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li>
<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层， 要求开发者针对抽象进行设计和编程</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景</li>
</ul>
<p>应用场景：对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用，例如：JDBC驱动程序(银行转账系统[转账分类: 网上转账，柜台转账，AMT转账 转账用户类型：普通用户，银卡用户，金卡用户]),消息管理(消息类型：即时消息，延时消息 消息分类：手机短信，邮件消息，QQ消息)</p>
<p>手机操作</p>
<ul>
<li><p>传统方法</p>
<p>分析：</p>
</li>
<li><p>扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加</p>
<ul>
<li>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，增加了代码维护成本</li>
</ul>
</li>
<li><p>桥接模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取折叠样式手机(样式+品牌)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=== 折叠样式手机 ===&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());</span><br><span class="line">        phone1.open();</span><br><span class="line">        phone1.close();</span><br><span class="line">        phone1.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">Vivo</span>());</span><br><span class="line">        phone2.open();</span><br><span class="line">        phone2.close();</span><br><span class="line">        phone2.call();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取折叠样式手机(样式+品牌)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=== 直立样式手机 ===&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());</span><br><span class="line">        phone3.open();</span><br><span class="line">        phone3.close();</span><br><span class="line">        phone3.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">Vivo</span>());</span><br><span class="line">        phone4.open();</span><br><span class="line">        phone4.close();</span><br><span class="line">        phone4.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Brand.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Brand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//FoldedPhone.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折叠样式手机类，，继承抽象类Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoldedPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FoldedPhone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠手机开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠手机关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//UpRightPhone</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直立样式手机类，，继承抽象类Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpRightPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UpRightPhone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">        System.out.println(<span class="string">&quot;直立手机开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;直立手机关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;直立手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Phone.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//组合品牌</span></span><br><span class="line">    <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vivo.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vivo</span> <span class="keyword">implements</span> <span class="title class_">Brand</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vivo手机开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vivo手机关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vivo手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//XiaoMi.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMi</span> <span class="keyword">implements</span> <span class="title class_">Brand</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi手机开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi手机关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码刨析（JDBC）"><a href="#源码刨析（JDBC）" class="headerlink" title="源码刨析（JDBC）"></a>源码刨析（JDBC）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.注册驱动</span></span><br><span class="line">            <span class="comment">//2. 调用DriverManager中的getConnection</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionImpl</span> <span class="keyword">extends</span> <span class="title class_">ConnectionPropertiesImpl</span> <span class="keyword">implements</span> <span class="title class_">MySQLConnection</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明：</span></span><br><span class="line"><span class="comment">//1. MySQL有自己的ConnectionImpl类，同样Oracle也有对应的实现类</span></span><br><span class="line"><span class="comment">//2. Driver和Connection之间是通过DriverManager类进行桥连接的</span></span><br><span class="line"><span class="comment">//3. 简单示意图[待]</span></span><br></pre></td></tr></table></figure>
<h2 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h2><p>装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p>
<p>原理：</p>
<ul>
<li>装饰者模式就像打包一个快递<ul>
<li>主体：比如：陶瓷、衣服 (Component) // 被装饰者</li>
<li>包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)</li>
</ul>
</li>
<li>Component 主体：比如类似前面的Drink</li>
<li>ConcreteComponent和Decorator ConcreteComponent：具体的主体， 比如前面的各个单品咖啡 Decorator: 装饰者，比如各调料</li>
<li>在如图的Component与ConcreteComponent之间，如果 ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来， 抽象层一个类。</li>
</ul>
<p>星巴克咖啡订单项目</p>
<ul>
<li><p>方式一</p>
</li>
<li><p>方式二</p>
</li>
<li><p>装饰者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CoffeeBar.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeBar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//装饰者模式下的订单：2份巧克力+1杯牛奶的LongBlack</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.点1份LongBlack</span></span><br><span class="line">        <span class="type">Drink</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongBlack</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;费用1 = &quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述  = &quot;</span> + order.getDes());</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//2.order加入一份牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> <span class="title class_">Milk</span>(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 费用 = &quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//3.order加入一份巧克力</span></span><br><span class="line">        order = <span class="keyword">new</span> <span class="title class_">Chocolate</span>(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力 费用 = &quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4.order加入一份巧克力</span></span><br><span class="line">        order = <span class="keyword">new</span> <span class="title class_">Chocolate</span>(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力 费用 = &quot;</span> + order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n\n=================================================&quot;</span>);</span><br><span class="line">        <span class="type">Drink</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeCaf</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;order2 无因咖啡 费用 = &quot;</span> + order2.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order2 无因咖啡 描述 = &quot;</span> + order2.getDes());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        order2 = <span class="keyword">new</span> <span class="title class_">Milk</span>(order2);</span><br><span class="line">        System.out.println(<span class="string">&quot;order 无因咖啡 加入一份牛奶 费用 = &quot;</span> + order2.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;order 无因咖啡 加入一份牛奶 描述 = &quot;</span> + order2.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Drink.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String des;<span class="comment">//描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span><span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算费用的抽象方法</span></span><br><span class="line">    <span class="comment">//子类来实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Coffee.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Decorator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Drink obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//obj.getDes()输出被装饰者的信息</span></span><br><span class="line">        <span class="keyword">return</span> des + <span class="string">&quot; &quot;</span> + getPrice() + <span class="string">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DeCaf.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeCaf</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeCaf</span><span class="params">()</span>&#123;</span><br><span class="line">        setDes(<span class="string">&quot;无因咖啡&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LongBlack</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongBlack</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongBlack</span><span class="params">()</span> &#123;</span><br><span class="line">        setDes(<span class="string">&quot;longblack&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">5.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码分析（JDK）-1"><a href="#源码分析（JDK）-1" class="headerlink" title="源码分析（JDK）"></a>源码分析（JDK）</h3><p>Java的IO结构，FilterInputStream就是一个装饰者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. InputStream 是抽象类, 类似我们前面讲的 Drink</span></span><br><span class="line">		<span class="comment">//2. FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</span></span><br><span class="line">		<span class="comment">//3. FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</span></span><br><span class="line">		<span class="comment">//4. DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</span></span><br><span class="line">		<span class="comment">//5. FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</span></span><br><span class="line">		<span class="comment">//6. 分析得出在jdk 的io体系中，就是使用装饰者模式</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\abc.txt&quot;</span>));</span><br><span class="line">		System.out.println(dis.read());</span><br><span class="line">		dis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，属于结构性模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。 依据树形结构来组合对象，用来表示部分以及整体层次。使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象</p>
<p>学校院系展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OrganizationComponent.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> String des;<span class="comment">//说明</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span>&#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span>&#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationComponent</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法print，做成抽象的，子类都需要实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//University.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//University就是Composite，可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">University</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span>&#123;</span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">University</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写add方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写remove方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print方法，输出University包含的学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span> + getName() + <span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent: organizationComponents)&#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//College.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">College</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span>&#123;</span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrganizationComponent&gt;();</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">College</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写add方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写remove方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> &#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span> + getName() + <span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历organizationComponents</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent: organizationComponents)&#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Department.java</span></span><br><span class="line">ackage com.atguigu.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name, String des)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//叶子结点，不需要重写add和remove方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从大到小创建对象</span></span><br><span class="line">        <span class="comment">//学校</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">university</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">University</span>(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot;大学&quot;</span>);</span><br><span class="line">        <span class="comment">//学院</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">computerCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot;计算机学院&quot;</span>);</span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">infoEngineerCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">College</span>(<span class="string">&quot;通信工程学院&quot;</span>, <span class="string">&quot;通信工程学院&quot;</span>);</span><br><span class="line">        <span class="comment">//创建各个学院下的系，专业</span></span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot;软件工程专业&quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot;网络工程专业&quot;</span>));</span><br><span class="line">        computerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot;计算机科学与技术专业&quot;</span>));</span><br><span class="line"></span><br><span class="line">        infoEngineerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot;通信工程&quot;</span>));</span><br><span class="line">        infoEngineerCollege.add(<span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot;信息工程&quot;</span>));</span><br><span class="line">        <span class="comment">//将学院加入到学校</span></span><br><span class="line">        university.add(computerCollege);</span><br><span class="line">        university.add(infoEngineerCollege);</span><br><span class="line"></span><br><span class="line">        computerCollege.print();</span><br><span class="line">        infoEngineerCollege.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析（JDK）-2"><a href="#源码分析（JDK）-2" class="headerlink" title="源码分析（JDK）"></a>源码分析（JDK）</h3><p>Java的集合类-HashMap就使用了组合模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapComp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Integer,String&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line">        hashMap.put(<span class="number">0</span>, <span class="string">&quot;东游记&quot;</span>);<span class="comment">//直接存放叶子节点</span></span><br><span class="line">        Map&lt;Integer,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;红楼梦&quot;</span>); <span class="comment">//..</span></span><br><span class="line">        hashMap.putAll(map);</span><br><span class="line">        System.out.println(hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//add, remover..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供 一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，通过定义一个一致的接口，用以屏蔽内部子系统的细节，使调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p>
<p>影院管理项目</p>
<ul>
<li><p>传统方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClientTest &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建相关的对象</span></span><br><span class="line">        <span class="comment">//2. 调用创建的各个对象的一系列方法</span></span><br><span class="line">        <span class="comment">// 3. 调用DVDPlayer 对象的play方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面,用来访问子系统中的一群接口</span></span><br></pre></td></tr></table></figure>
<p>在ClientTest 的main方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程不利于在ClientTest 中，去维护对子系统的操作</p>
</li>
<li><p>外观模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HomeTheaterFacade</span> <span class="variable">homeTheaterFacade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeTheaterFacade</span>();</span><br><span class="line">        homeTheaterFacade.ready();</span><br><span class="line">        homeTheaterFacade.play();</span><br><span class="line">        homeTheaterFacade.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//HomeTheaterFacade.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line">    <span class="comment">//定义各个子系统对象</span></span><br><span class="line">    <span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> Stereo stereo;</span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> Screen screen;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeTheaterFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.projector = Projector.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.screen = Screen.getInstance();</span><br><span class="line">        <span class="built_in">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ready</span><span class="params">()</span> &#123;</span><br><span class="line">        popcorn.on();</span><br><span class="line">        popcorn.pop();</span><br><span class="line">        screen.down();</span><br><span class="line">        projector.on();</span><br><span class="line">        stereo.on();</span><br><span class="line">        dVDPlayer.on();</span><br><span class="line">        theaterLight.dim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        dVDPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">        dVDPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        popcorn.off();</span><br><span class="line">        theaterLight.bright();</span><br><span class="line">        screen.up();</span><br><span class="line">        projector.off();</span><br><span class="line">        stereo.off();</span><br><span class="line">        dVDPlayer.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DVDPlayer.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVDPlayer</span> &#123;</span><br><span class="line">    <span class="comment">//使用单例模式，饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DVDPlayer</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVDPlayer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DVDPlayer <span class="title function_">getInstanc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DVD on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DVD off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DVD is playing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DVD pause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码分析（MyBatis）"><a href="#源码分析（MyBatis）" class="headerlink" title="源码分析（MyBatis）"></a>源码分析（MyBatis）</h3><p>MyBatis 中的Configuration 去创建MetaObject 对象使用到外观模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ReflectorFactory</span> <span class="variable">reflectorFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultReflectorFactory</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ObjectFactory</span> <span class="variable">objectFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultObjectFactory</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ObjectWrapperFactory</span> <span class="variable">objectWrapperFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultObjectWrapperFactory</span>();</span><br><span class="line">    <span class="keyword">public</span> MetaObject <span class="title function_">newMetaObject</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MetaObject.forObject(object, objectFactory, objectWrapperFactory, reflectorFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetaObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.originalObject = object;</span><br><span class="line">        <span class="built_in">this</span>.objectFactory = objectFactory;</span><br><span class="line">        <span class="built_in">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">        <span class="built_in">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">            <span class="built_in">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="built_in">this</span>, object);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            <span class="built_in">this</span>.objectWrapper = <span class="keyword">new</span> <span class="title class_">MapWrapper</span>(<span class="built_in">this</span>, (Map) object);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">            <span class="built_in">this</span>.objectWrapper = <span class="keyword">new</span> <span class="title class_">CollectionWrapper</span>(<span class="built_in">this</span>, (Collection) object);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.objectWrapper = <span class="keyword">new</span> <span class="title class_">BeanWrapper</span>(<span class="built_in">this</span>, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象，常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。享元模式能够解决重复对象的内存浪费的问题， 当系统中有大量相似对象，需要缓冲池时。不需要总是创建新对象，可以从缓冲池里拿。可以降低系统内存，同时提高效率</p>
<p>应用场景：池技术了，String常量池、数据库连接池、缓冲池等，享元模式是池技术的重要实现方式</p>
<p>展示网站项目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WebSite.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebSiteFactory.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网站工厂类，，根据需要返回一个网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteFactory</span> &#123;</span><br><span class="line">    <span class="comment">//集合，充当池的作用</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//根据网站类型，返回一个网站，如果没有就创建一个网站，并放入池中，返回</span></span><br><span class="line">    <span class="keyword">public</span> WebSite <span class="title function_">getWebSiteCetegory</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pool.containsKey(type))&#123;</span><br><span class="line">            <span class="comment">//创建网站并放入池中</span></span><br><span class="line">            pool.put(type, <span class="keyword">new</span> <span class="title class_">ConcreteWebSite</span>(type));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (WebSite) pool.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据网站分类的池数（池中有多少个网站类型）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWebSiteCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteWebSite.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title class_">WebSite</span>&#123;</span><br><span class="line">    <span class="comment">//共享部分，内部状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;<span class="comment">//网站发布形式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteWebSite</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;网站发布形式为：&quot;</span> + type +<span class="string">&quot;    在使用中的使用者是：&quot;</span> + user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个工厂类</span></span><br><span class="line">        <span class="type">WebSiteFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSiteFactory</span>();</span><br><span class="line">        <span class="comment">//客户要一个以新闻形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite1</span> <span class="operator">=</span> factory.getWebSiteCetegory(<span class="string">&quot;新闻&quot;</span>);</span><br><span class="line">        webSite1.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        <span class="comment">//客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite2</span> <span class="operator">=</span> factory.getWebSiteCetegory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite2.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">        <span class="comment">//客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite3</span> <span class="operator">=</span> factory.getWebSiteCetegory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite3.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;smith&quot;</span>));</span><br><span class="line">        <span class="comment">//客户要一个以博客形式发布的网站</span></span><br><span class="line">        <span class="type">WebSite</span> <span class="variable">webSite4</span> <span class="operator">=</span> factory.getWebSiteCetegory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">        webSite4.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;king&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;网站的分类共：&quot;</span> + factory.getWebSiteCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部状态和外部状态</strong></p>
<p>享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态 了，即将对象的信息分为两个部分：内部状态和外部状态</p>
<ul>
<li>内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变</li>
<li>外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态</li>
</ul>
<h3 id="源码分析（JDK-Interger）"><a href="#源码分析（JDK-Interger）" class="headerlink" title="源码分析（JDK-Interger）"></a>源码分析（JDK-Interger）</h3><p>Integer中的享元模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyWeight</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//如果Integer.valueOf(x)x在-128~127之间，使用享元模式返回，否则不在范围内，仍然使用new</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.在valueOf方法中首先判断值是否在IntegerCache中，如果不在，就创建新的Integer(new)，否则从缓存池返回</span></span><br><span class="line">        <span class="comment">//2.valueOf方法使用到享元模式</span></span><br><span class="line">        <span class="comment">//3.如果使用valueOf方法得到应该Integer实例，范围在-128~127之间，比new快</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="comment">//得到x实例，类型为Integer</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">        System.out.println(x.equals(y)); <span class="comment">//大小，true</span></span><br><span class="line">        System.out.println(x == y ); <span class="comment">//false</span></span><br><span class="line">        System.out.println(x == z ); <span class="comment">//true</span></span><br><span class="line">        System.out.println(w == x ); <span class="comment">//false</span></span><br><span class="line">        System.out.println(w == y ); <span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;x1 == x2&quot;</span> + (x1 == x2)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能</p>
<p>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一 起实现相同的接口或者是继承相同父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ITeacherDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//授课方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TeacherDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TeacherDaoProxy.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理对象，静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDao target;<span class="comment">//目标对象，通过接口来聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始代理，完成操作&quot;</span>);<span class="comment">//方法</span></span><br><span class="line">        target.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;提交&quot;</span>);<span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象（被代理对象）</span></span><br><span class="line">        <span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line">        <span class="comment">//创建代理对象，同时将被代理对象传递给代理对象</span></span><br><span class="line">        <span class="type">TeacherDaoProxy</span> <span class="variable">teacherDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDaoProxy</span>(teacherDao);</span><br><span class="line">        <span class="comment">//通过代理对象，调用到被代理对象的方法，即执行的是代理对象的方法，代理对象再去调用目标对象的方法</span></span><br><span class="line">        teacherDaoProxy.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优缺点：</p>
<ul>
<li>优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展</li>
<li>缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li>
<li>一旦接口增加方法,目标对象与代理对象都要维</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>基本介绍：</p>
<ul>
<li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li>
<li>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</li>
<li>动态代理也叫做：JDK代理、接口代理</li>
</ul>
<p>JDK中生成代理对象的API：</p>
<ol>
<li>代理类所在包：<code>java.lang.reflect.Proxy</code></li>
<li>JDK实现代理只需要使用<code>newProxyInstance</code>方法,但是该方法需要接收三个参数,完整的写法是:  <code>static Object newProxyInstance(ClassLoader loader, Class[]  interfaces,InvocationHandler h )</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ITeacherDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;<span class="comment">//授课方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ProxyFactory.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">                        <span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> returnVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TeacherDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">ITeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">        <span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao)<span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">        <span class="comment">//proxyInstance.teach();</span></span><br><span class="line"></span><br><span class="line">        proxyInstance.sayHello(<span class="string">&quot; tom &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展，(有些书也将Cglib代理归属到动态代理)Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口，广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截</p>
<p>在AOP编程中如何选择代理模式： 1. 目标对象需要实现接口，用JDK代理 2. 目标对象不需要实现接口，用Cglib代理</p>
<p>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤：</span></span><br><span class="line"><span class="comment">//1.引入cglib的jar文件</span></span><br><span class="line"><span class="comment">//2.在内存中动态构建子类，注意代理的类不能为final，否则报错java.lang.IllegalArgumentException: </span></span><br><span class="line"><span class="comment">//3.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TeacherDao.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;cglib代理，不需要实现接口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ProxyFactory.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建一个工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2. 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理模式~~   开始&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理模式~~   提交&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.proxy.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        <span class="type">TeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();</span><br><span class="line">        <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        <span class="type">TeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDao)<span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行代理对象的方法，出发intecept方法，从而实现对目标对象的调用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> proxyInstance.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理模式-Proxy-的变体"><a href="#代理模式-Proxy-的变体" class="headerlink" title="代理模式(Proxy)的变体"></a>代理模式(Proxy)的变体</h3><ol>
<li>防火墙代理：内网通过代理穿透防火墙，实现对公网的访问</li>
<li>缓存代理：比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源， 再到公网或者数据库取，然后缓存</li>
<li>远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息</li>
<li>同步代理：主要使用在多线程编程中，完成多线程间同步工作</li>
</ol>
<h2 id="模块方法模式"><a href="#模块方法模式" class="headerlink" title="模块方法模式"></a>模块方法模式</h2><p>模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，属于行为型模式，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤</p>
<p>注意：</p>
<ul>
<li>基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改</li>
<li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用</li>
<li>既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不 变，同时由子类提供部分步骤的实现</li>
<li>不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加， 使得系统更加庞大</li>
<li>一般模板方法都加上final关键字， 防止子类重写模板方法</li>
<li>模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一 系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模 式来处</li>
</ul>
<p>豆浆制作问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		select(); </span><br><span class="line">		addCondiments();</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选材料</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//浸泡</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第三步，黄豆和配料开始浸泡，需要3小时 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">beat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//PeanutSoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;   加入上好的花生&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RedBeanSoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;   加入上好的红豆&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//制作红豆豆浆</span></span><br><span class="line">		System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">redBeanSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBeanSoyaMilk</span>();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">peanutSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilk</span>();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板方法模式的钩子方法 1) 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以 视情况要不要覆盖它，该方法称为“钩子”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		select(); </span><br><span class="line">		<span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">			addCondiments();</span><br><span class="line">		&#125;</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选材料</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//浸泡</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第三步，黄豆和配料开始浸泡，需要3小时 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">beat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">customerWantCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RedBeanSoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;   加入上好的红豆 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//PureSoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//空实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">customerWantCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//PeanutSoyaMilk.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeanutSoyaMilk</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilk</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;   加入上好的花生 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.template.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//制作红豆豆浆</span></span><br><span class="line">		System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">redBeanSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBeanSoyaMilk</span>();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">peanutSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilk</span>();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作纯豆浆----&quot;</span>);</span><br><span class="line">		<span class="type">SoyaMilk</span> <span class="variable">pureSoyaMilk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PureSoyaMilk</span>();</span><br><span class="line">		pureSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析（Spring）-1"><a href="#源码分析（Spring）-1" class="headerlink" title="源码分析（Spring）"></a>源码分析（Spring）</h3><p>Spring IOC容器初始化时运用到的模板方法模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> </span><br><span class="line"><span class="title class_">ConfigurableApplicationContext</span> <span class="keyword">extends</span> </span><br><span class="line"><span class="title class_">ApplicationContext</span>, Lifecycle, Closeable &#123;</span><br><span class="line"><span class="comment">//声明了一个模板方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, </span><br><span class="line">IllegalStateException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultResourceLoaderimplements</span> ConfigurableApplicationContext, DisposableBean &#123;</span><br><span class="line">    <span class="comment">//模板方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            prepareRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    refreshBeanFactory();<span class="comment">//抽象的</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistry</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;<span class="comment">//子类实现了refreshBeanFactory</span></span><br><span class="line">    <span class="comment">// 实现交给子类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractApplicationContext</span> &#123;</span><br><span class="line">    <span class="comment">//也实现了 refreshBeanFactory 和 getBeanFactory</span></span><br><span class="line">    <span class="comment">//它的子类，就可以按它的实现方式来getBeanFactory </span></span><br><span class="line">    <span class="comment">//比如 ClassPathXmlApplicationContext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）：使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作</p>
<p>注意：</p>
<ul>
<li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，命令对象会负责让接收者执行请求的动作，也就是说，” 请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用</li>
<li>容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令</li>
<li>容易实现对请求的撤销和重做</li>
<li>不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这 点在在使用的时候要注意</li>
<li>空命令也是一种设计模式，它为我们省去了判空的操作。</li>
<li>应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令）订单的撤销/恢复、触发-反馈机制</li>
</ul>
<p>智能生活项目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Mediator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//将给中介者对象，加入到集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Register</span><span class="params">(String colleagueName, Colleague colleague)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息, 具体的同事对象发出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">GetMessage</span><span class="params">(<span class="type">int</span> stateChange, String colleagueName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Colleague.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同事抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mediator <span class="title function_">GetMediator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CoffeeMachine.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CoffeeMachine</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StartCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to startcoffee!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FinishCoffee</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;After 5 minutes!&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Coffee is ok!&quot;</span>);</span><br><span class="line">		SendMessage(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteMediator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">()</span> &#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> &#123;</span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Alarm&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;CoffeeMachine&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;TV&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Curtains&quot;</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GetMessage</span><span class="params">(<span class="type">int</span> stateChange, String colleagueName)</span> &#123;</span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">&quot;CoffeeMachine&quot;</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">&quot;Curtains&quot;</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Curtains.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Curtains</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Curtains</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UpCurtains</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am holding Up Curtains!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TV.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TV</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StartTv</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to StartTv!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StopTv</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;StopTv!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Alarm.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alarm</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Alarm</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">//在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]</span></span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendAlarm</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		SendMessage(stateChange);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="comment">//调用的中介者对象的getMessage</span></span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个中介者对象</span></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Alarm 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">        <span class="type">Alarm</span> <span class="variable">alarm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alarm</span>(mediator, <span class="string">&quot;alarm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建了CoffeeMachine 对象，并且加入到ConcreteMediator 对象的HashMap</span></span><br><span class="line">        <span class="type">CoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>(mediator,</span><br><span class="line">                <span class="string">&quot;coffeeMachine&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 Curtains , 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">        <span class="type">Curtains</span> <span class="variable">curtains</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Curtains</span>(mediator, <span class="string">&quot;curtains&quot;</span>);</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>(mediator, <span class="string">&quot;TV&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让闹钟发出消息</span></span><br><span class="line">        alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">        coffeeMachine.FinishCoffee();</span><br><span class="line">        alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析（Spring）-2"><a href="#源码分析（Spring）-2" class="headerlink" title="源码分析（Spring）"></a>源码分析（Spring）</h3><p>Spring框架的JdbcTemplate就使用到了命令模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplate</span> <span class="keyword">extends</span> <span class="title class_">JdbcAccessor</span> <span class="keyword">implements</span> <span class="title class_">JdbcOperations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">        <span class="keyword">return</span> query(sql, <span class="keyword">new</span> <span class="title class_">RowMapperResultSetExtractor</span>&lt;T&gt;(rowMapper));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> action.doInStatement(stmtToUse);</span><br><span class="line">        handleWarnings(stmt);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title class_">StatementCallback</span>&lt;T&gt;, SqlProvider &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="comment">//....&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> <span class="title class_">QueryStatementCallback</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StatementCallback</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException, </span><br><span class="line">    DataAccessException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StatementCallback 接口 ,类似命令接口(Command)</p>
<p>class QueryStatementCallback implements StatementCallback, SqlProvider , 匿名内 部类， 实现了命令接口， 同时也充当命令接收者</p>
<p>命令调用者 是 JdbcTemplate , 其中execute(StatementCallback action) 方法中，调 用action.doInStatement 方法. 不同的 实现 StatementCallback 接口的对象，对应不同 的doInStatemnt 实现逻辑</p>
<p>另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作， 它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题</p>
<p>基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口</p>
<p>应用场景是：需要对一个对象结构中的对象进行很多不同操作 (这些操作彼此没有关联)，同时需要避免让这些操作”污染”这些对象的类，可以用访问者模式解决</p>
<p>测评系统</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="comment">//提供一个方法，让访问者可以访问</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Action action)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Man.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">		action.getManResult(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Woman.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)</span></span><br><span class="line"><span class="comment">//2. 然后Woman 类调用作为参数的 &quot;具体方法&quot; 中方法getWomanResult, 同时将自己(this)作为参数传入，完成第二次的分派</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">		action.getWomanResult(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Action.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//得到男性的测评</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getManResult</span><span class="params">(Man man)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//得到女的测评</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getWomanResult</span><span class="params">(Woman woman)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Wait.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wait</span> <span class="keyword">extends</span> <span class="title class_">Action</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getManResult</span><span class="params">(Man man)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;男人给的评价是该歌手待定&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getWomanResult</span><span class="params">(Woman woman)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;女人给的评价是该歌手待定&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Success.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Success</span> <span class="keyword">extends</span> <span class="title class_">Action</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getManResult</span><span class="params">(Man man)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;男人给的评价该歌手很成功!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getWomanResult</span><span class="params">(Woman woman)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;女人给的评价该歌手很成功!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Fail.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fail</span> <span class="keyword">extends</span> <span class="title class_">Action</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getManResult</span><span class="params">(Man man)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;男人给的评价该歌手失败!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getWomanResult</span><span class="params">(Woman woman)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;女人给的评价该歌手失败!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ObjectStructure.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构，管理很多人（Man , Woman）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;</span><br><span class="line">    <span class="comment">//维护了一个集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加到list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        persons.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">        persons.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示测评情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Action action)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Person p: persons) &#123;</span><br><span class="line">            p.accept(action);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.visitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectStructure</span> <span class="variable">objectStructure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStructure</span>();</span><br><span class="line">        objectStructure.attach(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br><span class="line">        objectStructure.attach(<span class="keyword">new</span> <span class="title class_">Woman</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//成功</span></span><br><span class="line">        <span class="type">Success</span> <span class="variable">success</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Success</span>();</span><br><span class="line">        objectStructure.display(success);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Fail</span> <span class="variable">fail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fail</span>();</span><br><span class="line">        objectStructure.display(fail);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Wait</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wait</span>();</span><br><span class="line">        objectStructure.display(wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高</li>
<li>可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li>
</ul>
<p>缺点：</p>
<ul>
<li>具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，造成了具体元素变更比较困难</li>
<li>违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素</li>
</ul>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）属于行为型模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素， 不需要知道集合对象的底层表示，即，不暴露其内部的结构</p>
<p>编写程序展示一个学校院系结构：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//College.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">College</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//增加系的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(String name, String desc)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回一个迭代器,遍历</span></span><br><span class="line">	<span class="keyword">public</span> Iterator  <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ComputerCollege.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerCollege</span> <span class="keyword">implements</span> <span class="title class_">College</span> &#123;</span><br><span class="line"></span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="type">int</span> <span class="variable">numOfDepartment</span> <span class="operator">=</span> <span class="number">0</span> ;<span class="comment">// 保存当前数组的对象个数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ComputerCollege</span><span class="params">()</span> &#123;</span><br><span class="line">		departments = <span class="keyword">new</span> <span class="title class_">Department</span>[<span class="number">5</span>];</span><br><span class="line">		addDepartment(<span class="string">&quot;Java专业&quot;</span>, <span class="string">&quot; Java专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;PHP专业&quot;</span>, <span class="string">&quot; PHP专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;大数据专业&quot;</span>, <span class="string">&quot; 大数据专业 &quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;计算机学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">		<span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(name, desc);</span><br><span class="line">		departments[numOfDepartment] = department;</span><br><span class="line">		numOfDepartment += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComputerCollegeIterator</span>(departments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ComputerCollegeIterator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerCollegeIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">	<span class="comment">//这里我们需要Department 是以怎样的方式存放=&gt;数组</span></span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//遍历的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ComputerCollegeIterator</span><span class="params">(Department[] departments)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.departments = departments;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(position &gt;= departments.length || departments[position] == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> departments[position];</span><br><span class="line">		position += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> department;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除的方法，默认空实现</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Department.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String desc;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//InfoColleageIterator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfoColleageIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">	List&lt;Department&gt; departmentList; <span class="comment">// 信息工程学院是以List方式存放系</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//索引</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">InfoColleageIterator</span><span class="params">(List&lt;Department&gt; departmentList)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.departmentList = departmentList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断list中还有没有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(index &gt;= departmentList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			index += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> departmentList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//空实现remove</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//InfoCollege.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfoCollege</span> <span class="keyword">implements</span> <span class="title class_">College</span> &#123;</span><br><span class="line"></span><br><span class="line">	List&lt;Department&gt; departmentList;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">InfoCollege</span><span class="params">()</span> &#123;</span><br><span class="line">		departmentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Department&gt;();</span><br><span class="line">		addDepartment(<span class="string">&quot;信息安全专业&quot;</span>, <span class="string">&quot; 信息安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;网络安全专业&quot;</span>, <span class="string">&quot; 网络安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;服务器安全专业&quot;</span>, <span class="string">&quot; 服务器安全专业 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;信息工程学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">		<span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(name, desc);</span><br><span class="line">		departmentList.add(department);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InfoColleageIterator</span>(departmentList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//OutPutImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutPutImpl</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//学院集合</span></span><br><span class="line">	List&lt;College&gt; collegeList;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">OutPutImpl</span><span class="params">(List&lt;College&gt; collegeList)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">this</span>.collegeList = collegeList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有学院,然后调用printDepartment 输出各个学院的系</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCollege</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从collegeList 取出所有学院, Java 中的 List 已经实现Iterator</span></span><br><span class="line">		Iterator&lt;College&gt; iterator = collegeList.iterator();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			<span class="comment">//取出一个学院</span></span><br><span class="line">			<span class="type">College</span> <span class="variable">college</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;=== &quot;</span>+college.getName() +<span class="string">&quot;=====&quot;</span> );</span><br><span class="line">			printDepartment(college.createIterator()); <span class="comment">//得到对应迭代器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输出学院,输出系</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDepartment</span><span class="params">(Iterator iterator)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			<span class="type">Department</span> <span class="variable">d</span> <span class="operator">=</span> (Department)iterator.next();</span><br><span class="line">			System.out.println(d.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建学院</span></span><br><span class="line">		List&lt;College&gt; collegeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;College&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="type">ComputerCollege</span> <span class="variable">computerCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerCollege</span>();</span><br><span class="line">		<span class="type">InfoCollege</span> <span class="variable">infoCollege</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InfoCollege</span>();</span><br><span class="line">		</span><br><span class="line">		collegeList.add(computerCollege);</span><br><span class="line">		<span class="comment">//collegeList.add(infoCollege);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">OutPutImpl</span> <span class="variable">outPutImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutPutImpl</span>(collegeList);</span><br><span class="line">		outPutImpl.printCollege();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法即可遍历对象</li>
<li>隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成</li>
<li>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（单一责任原则）。在聚合类中，把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，此时如果集合改变的话，只影响到聚合对象。如果遍历方式改变的话，只影响到了迭代器</li>
<li>当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式</li>
</ul>
<p>缺点：每个聚合对象都要一个迭代器，会生成多个迭代器不好管理</p>
<h3 id="源码分析（JDK-ArrayList）"><a href="#源码分析（JDK-ArrayList）" class="headerlink" title="源码分析（JDK-ArrayList）"></a>源码分析（JDK-ArrayList）</h3><p>JDK的ArrayList 集合中就使用了迭代器模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorPattern</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(<span class="string">&quot;jack&quot;</span>);<span class="comment">//..</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">Itr</span> <span class="operator">=</span> a.iterator();</span><br><span class="line">        <span class="keyword">while</span> (Itr.hasNext()) &#123;</span><br><span class="line">            System.out.println(Itr.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;<span class="comment">//ArrayList 聚合实现类，实现了聚合接口List</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123; <span class="comment">//内部类Itr 实现了Iterator 接口,是具体的接口实现类。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;&#125;<span class="comment">//省略 &#125;</span></span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>(); &#125; <span class="comment">// 聚合实现类，得到一个迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>; <span class="comment">//聚合接口，返回迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类Itr 充当具体实现迭代器Iterator 的类， 作为ArrayList 内部类</p>
<p>List 就是充当了聚合接口，含有一个iterator() 方法，返回一个迭代器对象</p>
<p>ArrayList 是实现聚合接口List 的子类，实现了iterator()</p>
<p>Iterator 接口系统提供</p>
<p>迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式：对象之间一对多依赖的一种设计方案，被依赖的对象为Subject， 依赖的对象为Observer，Subject通知Observer变化,比如这里的奶站是 Subject，是一的一方。用户时Observer，是多的一方</p>
<p>天气预报项目</p>
<ul>
<li><p>传统方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CurrentConditions.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示当前天气情况（可以理解成是气象站自己的网站）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditions</span> &#123;</span><br><span class="line">    <span class="comment">//温度，气压，湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> pressure, <span class="type">float</span> humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//WeatherDate.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类是核心</span></span><br><span class="line"><span class="comment"> * 1. 包含最新的天气情况信息</span></span><br><span class="line"><span class="comment"> * 2. 含有 CurrentConditions 对象</span></span><br><span class="line"><span class="comment"> * 3. 当数据有更新时，就主动的调用   CurrentConditions对象update方法(含 display), 这样他们（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherDate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperatrue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> CurrentConditions currentConditions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入新的第三方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherDate</span><span class="params">(CurrentConditions currentConditions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentConditions = currentConditions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperatrue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataChange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用 接入方的 update</span></span><br><span class="line">        currentConditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDate</span><span class="params">(<span class="type">float</span> temperatrue, <span class="type">float</span> pressure, <span class="type">float</span> humidity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperatrue = temperatrue;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">//调用dataChange， 将最新的信息推送给接入方 currentConditions</span></span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建接入方 currentConditions</span></span><br><span class="line">        <span class="type">CurrentConditions</span> <span class="variable">currentConditions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditions</span>();</span><br><span class="line">        <span class="comment">//创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中</span></span><br><span class="line">        <span class="type">WeatherDate</span> <span class="variable">weatherDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherDate</span>(currentConditions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新天气情况</span></span><br><span class="line">        weatherDate.setDate(<span class="number">30</span>, <span class="number">150</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//天气情况变化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;============天气情况变化=============&quot;</span>);</span><br><span class="line">        weatherDate.setDate(<span class="number">40</span>, <span class="number">160</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>观察者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Observer.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口，有观察者来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> pressure, <span class="type">float</span> humidity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Subject.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口, 让WeatherData来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//WeatherData.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperatrue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入新的第三方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperatrue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataChange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用接入方的 update</span></span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> pressure, <span class="type">float</span> humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperatrue = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="comment">//调用dataChange， 将最新的信息推送给接入方 currentConditions</span></span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册一个观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除一个观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(observers.contains(o)) &#123;</span><br><span class="line">            observers.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的观察者，并通知</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">            observers.get(i).update(<span class="built_in">this</span>.temperatrue, <span class="built_in">this</span>.pressure, <span class="built_in">this</span>.humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CurrentConditions.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditions</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> pressure, <span class="type">float</span> humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//BaiduSite.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaiduSite</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="comment">// 温度，气压，湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> pressure, <span class="type">float</span> humidity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===百度网站====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***百度网站 气温 : &quot;</span> + temperature + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***百度网站 气压: &quot;</span> + pressure + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***百度网站 湿度: &quot;</span> + humidity + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个WeatherData</span></span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建观察者</span></span><br><span class="line">        <span class="type">CurrentConditions</span> <span class="variable">currentConditions</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditions</span>();</span><br><span class="line">        <span class="type">BaiduSite</span> <span class="variable">baiduSite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaiduSite</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册到weatherData</span></span><br><span class="line">        weatherData.registerObserver(currentConditions);</span><br><span class="line">        weatherData.registerObserver(baiduSite);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">        weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">        weatherData.removeObserver(currentConditions);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">        weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="源码分析（JDK）-3"><a href="#源码分析（JDK）-3" class="headerlink" title="源码分析（JDK）"></a>源码分析（JDK）</h3><p>Jdk的Observable类就使用了观察者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> vector&lt;Observer&gt; obs;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> <span class="title class_">vector</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Observable 的作用和地位等价于 我们前面讲过Subjec</p>
<p>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理Observer 的方法 add.. delete .. notify…</p>
<p>Observer 的作用和地位等价于我们前面讲过的 Observer, 有update</p>
<p>Observable 和 Observer 的使用方法和前面讲过的一样，只是Observable 是 类，通过继承来实现观察者模式</p>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）属于行为型模式，用一个中介对象来封装一系列的对象交互。 中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互，使代码易于维护</p>
<p>智能家庭项目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Mediator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//将给中介者对象，加入到集合中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Register</span><span class="params">(String colleagueName, Colleague colleague)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息, 具体的同事对象发出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">GetMessage</span><span class="params">(<span class="type">int</span> stateChange, String colleagueName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Colleague.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同事抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mediator <span class="title function_">GetMediator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CoffeeMachine.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CoffeeMachine</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StartCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to startcoffee!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FinishCoffee</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;After 5 minutes!&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Coffee is ok!&quot;</span>);</span><br><span class="line">		SendMessage(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Alarm.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alarm</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Alarm</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">//在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]</span></span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendAlarm</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		SendMessage(stateChange);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="comment">//调用的中介者对象的getMessage</span></span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Curtains.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Curtains</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Curtains</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UpCurtains</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am holding Up Curtains!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TV.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TV</span><span class="params">(Mediator mediator, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">(<span class="type">int</span> stateChange)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.GetMediator().GetMessage(stateChange, <span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StartTv</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to StartTv!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StopTv</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;StopTv!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteMediator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">()</span> &#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> &#123;</span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Alarm&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;CoffeeMachine&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;TV&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Curtains&quot;</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GetMessage</span><span class="params">(<span class="type">int</span> stateChange, String colleagueName)</span> &#123;</span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">&quot;CoffeeMachine&quot;</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">&quot;Curtains&quot;</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SendMessage</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.mediator.smarthouse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个中介者对象</span></span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Alarm 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">        <span class="type">Alarm</span> <span class="variable">alarm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alarm</span>(mediator, <span class="string">&quot;alarm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建了CoffeeMachine 对象，并且加入到ConcreteMediator 对象的HashMap</span></span><br><span class="line">        <span class="type">CoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>(mediator,</span><br><span class="line">                <span class="string">&quot;coffeeMachine&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 Curtains , 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">        <span class="type">Curtains</span> <span class="variable">curtains</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Curtains</span>(mediator, <span class="string">&quot;curtains&quot;</span>);</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>(mediator, <span class="string">&quot;TV&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让闹钟发出消息</span></span><br><span class="line">        alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">        coffeeMachine.FinishCoffee();</span><br><span class="line">        alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）属于行为型模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Memento.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.theory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Originator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.theory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;<span class="comment">//状态信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，可以保存一个状态对象 Memento</span></span><br><span class="line">    <span class="comment">//因此编写一个方法，返回 Memento</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">saveStateMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过备忘录对象，恢复状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getStateFromMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Caretaker.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.theory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="comment">//在List 集合中会有很多的备忘录对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Memento&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.theory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot; 状态#1 攻击力 100 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存了当前的状态</span></span><br><span class="line">        caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot; 状态#2 攻击力 80 &quot;</span>);</span><br><span class="line"></span><br><span class="line">        caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot; 状态#3 攻击力 50 &quot;</span>);</span><br><span class="line">        caretaker.add(originator.saveStateMemento());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//希望得到状态 1, 将 originator 恢复到状态1</span></span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复到状态1 , 当前的状态是&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>游戏角色状态恢复问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Caretaker.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.game;</span><br><span class="line"></span><br><span class="line"><span class="comment">//守护者对象, 保存游戏角色的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="comment">//如果只保存一次状态</span></span><br><span class="line">    <span class="keyword">private</span> Memento  memento;</span><br><span class="line">    <span class="comment">//对GameRole 保存多次状态</span></span><br><span class="line">    <span class="comment">//private ArrayList&lt;Memento&gt; mementos;</span></span><br><span class="line">    <span class="comment">//对多个游戏角色保存多个状态</span></span><br><span class="line">    <span class="comment">//private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GameRole.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Memento ,即根据当前的状态得到Memento</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(vit, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从备忘录对象，恢复GameRole的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverGameRoleFromMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = memento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.def = memento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示当前游戏角色的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏角色当前的攻击力：&quot;</span> + <span class="built_in">this</span>.vit + <span class="string">&quot; 防御力: &quot;</span> + <span class="built_in">this</span>.def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Memento.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">    <span class="comment">//防御力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.memento.game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建游戏角色</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.setVit(<span class="number">100</span>);</span><br><span class="line">        gameRole.setDef(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;和boss大战前的状态&quot;</span>);</span><br><span class="line">        gameRole.display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前状态保存caretaker</span></span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line">        caretaker.setMemento(gameRole.createMemento());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;和boss大战~~~&quot;</span>);</span><br><span class="line">        gameRole.setDef(<span class="number">30</span>);</span><br><span class="line">        gameRole.setVit(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        gameRole.display();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;大战后，使用备忘录对象恢复到站前&quot;</span>);</span><br><span class="line"></span><br><span class="line">        gameRole.recoverGameRoleFromMemento(caretaker.getMemento());</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的状态&quot;</span>);</span><br><span class="line">        gameRole.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节</li>
<li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存</li>
<li>应用场景：1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理</li>
<li>为了节约内存，备忘录模式可以和原型模式配合使用</li>
</ul>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法 单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这 里的词法分析器和语法分析器都可以看做是解释器</p>
<p>解释器模式（Interpreter Pattern）：是指给定一个语言(表达式)，定义它的文法 的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)</p>
<p>应用场景：应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；一些重复出现的问题可以用一种简单的语言来表达；一个简单语法需要解释的场景</p>
<p>四则运算问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Expression.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类表达式，通过HashMap 键值对, 可以获取到变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="comment">// a + b - c</span></span><br><span class="line">    <span class="comment">// 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value就是就是具体值</span></span><br><span class="line">    <span class="comment">// HashMap &#123;a=10, b=20&#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SubExpression.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubExpression</span> <span class="keyword">extends</span> <span class="title class_">SymbolExpression</span>&#123;</span><br><span class="line">    <span class="comment">//求出left 和 right 表达式相减后的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.left.interpreter(<span class="keyword">var</span>) - <span class="built_in">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SymbolExpression.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，</span></span><br><span class="line"><span class="comment"> * 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression类的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SymbolExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Expression left;</span><br><span class="line">    <span class="keyword">protected</span> Expression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SymbolExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//VarExpression.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的解释器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key; <span class="comment">// key=a,key=b,key=c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VarExpression</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// var 就是&#123;a=10, b=20&#125;</span></span><br><span class="line">    <span class="comment">// interpreter 根据 变量名称，返回对应值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.get(<span class="built_in">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AddExpression.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法解释器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">extends</span> <span class="title class_">SymbolExpression</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理相加</span></span><br><span class="line">    <span class="comment">//var 仍然是 &#123;a=10,b=20&#125;..</span></span><br><span class="line">    <span class="comment">//一会我们debug 源码,就ok</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10</span></span><br><span class="line">        <span class="comment">//super.right.interpreter(var): 返回right 表达式对应值 b = 20</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.left.interpreter(<span class="keyword">var</span>) + <span class="built_in">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Calculator.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 定义表达式</span></span><br><span class="line">    <span class="keyword">private</span> Expression expression;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数传参，并解析</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">(String expStr)</span> &#123; <span class="comment">// expStr = a+b</span></span><br><span class="line">        <span class="comment">// 安排运算先后顺序</span></span><br><span class="line">        Stack&lt;Expression&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 表达式拆分成字符数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray = expStr.toCharArray();<span class="comment">// [a, +, b]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//遍历我们的字符数组， 即遍历  [a, +, b]</span></span><br><span class="line">        <span class="comment">//针对不同的情况，做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (charArray[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">//</span></span><br><span class="line">                    left = stack.pop();<span class="comment">// 从stack取出left =&gt; &quot;a&quot;</span></span><br><span class="line">                    right = <span class="keyword">new</span> <span class="title class_">VarExpression</span>(String.valueOf(charArray[++i]));<span class="comment">// 取出右表达式 &quot;b&quot;</span></span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">AddExpression</span>(left, right));<span class="comment">// 然后根据得到left 和 right 构建 AddExpresson加入stack</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">//</span></span><br><span class="line">                    left = stack.pop();</span><br><span class="line">                    right = <span class="keyword">new</span> <span class="title class_">VarExpression</span>(String.valueOf(charArray[++i]));</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">SubExpression</span>(left, right));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//如果是一个 Var 就创建要给 VarExpression 对象，并push到 stack</span></span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">VarExpression</span>(String.valueOf(charArray[i])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当遍历完整个 charArray 数组后，stack 就得到最后Expression</span></span><br><span class="line">        <span class="built_in">this</span>.expression = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//最后将表达式a+b和 var = &#123;a=10,b=20&#125;</span></span><br><span class="line">        <span class="comment">//然后传递给expression的interpreter进行解释执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.expression.interpreter(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line">ackage com.atguigu.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expStr</span> <span class="operator">=</span> getExpStr(); <span class="comment">// a+b</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; <span class="keyword">var</span> = getValue(expStr);<span class="comment">// var &#123;a=10, b=20&#125;</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>(expStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;运算结果：&quot;</span> + expStr + <span class="string">&quot;=&quot;</span> + calculator.run(<span class="keyword">var</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得表达式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getExpStr</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入表达式：&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in))).readLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得值映射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title function_">getValue</span><span class="params">(String expStr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : expStr.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(String.valueOf(ch))) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入&quot;</span> + String.valueOf(ch) + <span class="string">&quot;的值：&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">in</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in))).readLine();</span><br><span class="line">                    map.put(String.valueOf(ch), Integer.valueOf(in));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interpreter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpelExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;100 * (2 + 400) * 1 + 66&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (Integer) expression.getValue();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExpressionParser</span> &#123;</span><br><span class="line">    Expression <span class="title function_">parseExpression</span><span class="params">(String expressionString)</span> <span class="keyword">throws</span> ParseException;</span><br><span class="line">    Expression <span class="title function_">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParseException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TemplateAwareExpressionParser</span> <span class="keyword">implements</span> <span class="title class_">ExpressionParser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Expression <span class="title function_">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> &#123; <span class="comment">// 不同情况返回不同的Express. </span></span><br><span class="line">    &#125; <span class="comment">//看源码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpelExpressionParser</span> <span class="keyword">extends</span> <span class="title class_">TemplateAwareExpressionParser</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InternalSpelExpressionParser</span> <span class="keyword">extends</span> <span class="title class_">TemplateAwareExpressionParser</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*说明</span></span><br><span class="line"><span class="comment">Expression 接口 表达式接口</span></span><br><span class="line"><span class="comment">下面有不同的实现类，比如SpelExpression, 或者CompositeStringExpression。</span></span><br><span class="line"><span class="comment">使用时候，根据你创建的不同的Parser 对象，返回不同的 Expression 对象</span></span><br><span class="line"><span class="comment">public Expression parseExpression(String expressionString, ParserContext context)</span></span><br><span class="line"><span class="comment">throws ParseException &#123;</span></span><br><span class="line"><span class="comment">if (context == null) &#123;</span></span><br><span class="line"><span class="comment">context = NON_TEMPLATE_PARSER_CONTEXT;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (context.isTemplate()) &#123;</span></span><br><span class="line"><span class="comment">return parseTemplate(expressionString, context); //返回的就是 CompositeStringExpression</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment">return doParseExpression(expressionString, context); //返回的就是 SpelExpression</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">- 使用得当 Expression对象，调用getValue 解释执行 表达式，最后得到结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式（State Pattern）：主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换，当一个对象的内在状态改变时，允许改变其行为</p>
<p>APP抽奖活动问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//State.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 扣除积分 - 50</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否抽中奖品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">raffle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发放奖品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">dispensePrize</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RaffleActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽奖活动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaffleActivity</span> &#123;</span><br><span class="line">    <span class="comment">// state 表示活动当前的状态，是变化</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 奖品数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 四个属性，表示四种状态</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">noRafflleState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoRaffleState</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">State</span> <span class="variable">canRaffleState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CanRaffleState</span>(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">State</span> <span class="variable">dispenseState</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">DispenseState</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">State</span> <span class="variable">dispensOutState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispenseOutState</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）</span></span><br><span class="line">    <span class="comment">//2. 初始化奖品的数量 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RaffleActivity</span><span class="params">( <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = getNoRafflleState();</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扣分, 调用当前状态的 deductMoney</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debuctMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        state.deductMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽奖 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raffle</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="comment">// 如果当前的状态是抽奖成功</span></span><br><span class="line">        <span class="keyword">if</span>(state.raffle())&#123;</span><br><span class="line">        	<span class="comment">//领取奖品</span></span><br><span class="line">            state.dispensePrize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里请大家注意，每领取一次奖品，count--</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">curCount</span> <span class="operator">=</span> count; </span><br><span class="line">    	count--;</span><br><span class="line">        <span class="keyword">return</span> curCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getNoRafflleState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNoRafflleState</span><span class="params">(State noRafflleState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.noRafflleState = noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getCanRaffleState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCanRaffleState</span><span class="params">(State canRaffleState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.canRaffleState = canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getDispenseState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDispenseState</span><span class="params">(State dispenseState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dispenseState = dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getDispensOutState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDispensOutState</span><span class="params">(State dispensOutState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dispensOutState = dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NoRaffleState.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能抽奖状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoRaffleState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化时传入活动引用，扣除积分后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoRaffleState</span><span class="params">(RaffleActivity activity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣除50积分成功，您可以抽奖了&quot;</span>);</span><br><span class="line">        activity.setState(activity.getCanRaffleState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前状态不能抽奖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">raffle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣了积分才能抽奖喔！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前状态不能发奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispensePrize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DispenseState.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发放奖品的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispenseState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化时传入活动引用，发放奖品后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispenseState</span><span class="params">(RaffleActivity activity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能扣除积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">raffle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能抽奖&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispensePrize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(activity.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜中奖了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾，奖品发送完了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为奖品发送完毕, 后面我们就不可以抽奖</span></span><br><span class="line">            activity.setState(activity.getDispensOutState());</span><br><span class="line">            <span class="comment">//System.out.println(&quot;抽奖活动结束&quot;);</span></span><br><span class="line">            <span class="comment">//System.exit(0);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DispenseOutState.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖品发放完毕状态</span></span><br><span class="line"><span class="comment"> * 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispenseOutState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化时传入活动引用</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DispenseOutState</span><span class="params">(RaffleActivity activity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">raffle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispensePrize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CanRaffleState.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以抽奖的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanRaffleState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CanRaffleState</span><span class="params">(RaffleActivity activity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已经扣除了积分，不能再扣</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经扣取过了积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以抽奖, 抽完奖后，根据实际情况，改成新的状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">raffle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在抽奖，请稍等！&quot;</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10%中奖机会</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 改变活动状态为发放奖品 context</span></span><br><span class="line">            activity.setState(activity.getDispenseState());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾没有抽中奖品！&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispensePrize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没中奖，不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态模式测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建活动对象，奖品有1个奖品</span></span><br><span class="line">        <span class="type">RaffleActivity</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RaffleActivity</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们连续抽300次奖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次抽奖----------&quot;</span>);</span><br><span class="line">            <span class="comment">// 参加抽奖，第一步点击扣除积分</span></span><br><span class="line">            activity.debuctMoney();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步抽奖</span></span><br><span class="line">            activity.raffle();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际应用：借贷平台</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractState.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state.money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RuntimeException</span> <span class="variable">EXCEPTION</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作流程不允许&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//抽象类，默认实现了 State 接口的所有方法</span></span><br><span class="line">	<span class="comment">//该类的所有方法，其子类(具体的状态类)，可以有选择的进行重写</span></span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFailEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePriceEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptOrderEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notPeopleAcceptEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrderEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderFailureEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feedBackEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//State.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state.money;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">	<span class="comment">//电审</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电审失败</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkFailEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定价发布</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makePriceEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接单</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">acceptOrderEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无人接单失效</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notPeopleAcceptEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//付款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">payOrderEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接单有人支付失效</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">orderFailureEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反馈</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feedBackEvent</span><span class="params">(Context context)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getCurrentState</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//StateEnum.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state.money;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StateEnum</span> &#123;</span><br><span class="line">	 <span class="comment">//订单生成</span></span><br><span class="line">    GENERATE(<span class="number">1</span>, <span class="string">&quot;GENERATE&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已审核</span></span><br><span class="line">    REVIEWED(<span class="number">2</span>, <span class="string">&quot;REVIEWED&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已发布</span></span><br><span class="line">    PUBLISHED(<span class="number">3</span>, <span class="string">&quot;PUBLISHED&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//待付款</span></span><br><span class="line">    NOT_PAY(<span class="number">4</span>, <span class="string">&quot;NOT_PAY&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已付款</span></span><br><span class="line">    PAID(<span class="number">5</span>, <span class="string">&quot;PAID&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已完结</span></span><br><span class="line">    FEED_BACKED(<span class="number">6</span>, <span class="string">&quot;FEED_BACKED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    StateEnum(<span class="type">int</span> key, String value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKey</span><span class="params">()</span> &#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Context.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state.money;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span>&#123;</span><br><span class="line">	<span class="comment">//当前的状态 state, 根据我们的业务流程处理，不停的变化</span></span><br><span class="line">	<span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.checkEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFailEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.checkFailEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePriceEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.makePriceEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptOrderEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.acceptOrderEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notPeopleAcceptEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.notPeopleAcceptEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrderEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.payOrderEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderFailureEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.orderFailureEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feedBackEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        state.feedBackEvent(<span class="built_in">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态 : &quot;</span> + state.getCurrentState());</span><br><span class="line">        <span class="keyword">return</span> state.getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//FeedBackState.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state.money;</span><br><span class="line"></span><br><span class="line"><span class="comment">//各种具体状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeedBackState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.FEED_BACKED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenerateState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">ReviewState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFailEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">FeedBackState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.GENERATE.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotPayState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrderEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">PaidState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feedBackEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">FeedBackState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.NOT_PAY.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaidState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feedBackEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">FeedBackState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PAID.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublishState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptOrderEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		<span class="comment">//把当前状态设置为  NotPayState。。。</span></span><br><span class="line">		<span class="comment">//至于应该变成哪个状态，有流程图来决定</span></span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">NotPayState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notPeopleAcceptEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">FeedBackState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PUBLISHED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReviewState</span> <span class="keyword">extends</span> <span class="title class_">AbstractState</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makePriceEvent</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">PublishState</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getCurrentState</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.REVIEWED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ClientTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.state.money;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建context 对象</span></span><br><span class="line">		<span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="comment">//将当前状态设置为 PublishState</span></span><br><span class="line">		context.setState(<span class="keyword">new</span> <span class="title class_">PublishState</span>());</span><br><span class="line">        System.out.println(context.getCurrentState());</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        //publish --&gt; not pay</span></span><br><span class="line">        context.acceptOrderEvent(context);</span><br><span class="line"><span class="comment">//        //not pay --&gt; paid</span></span><br><span class="line">        context.payOrderEvent(context);</span><br><span class="line"><span class="comment">//        // 失败, 检测失败时，会抛出异常</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//        	context.checkFailEvent(context);</span></span><br><span class="line"><span class="comment">//        	System.out.println(&quot;流程正常..&quot;);</span></span><br><span class="line"><span class="comment">//		&#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//			// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line"><span class="comment">//			System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中</li>
<li>方便维护。</li>
<li>符合“开闭原则”。容易增删状态</li>
<li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</li>
<li>应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为可以考虑使用状态模式</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户</p>
<p>鸭子问题</p>
<ul>
<li><p>传统方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Duck.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;<span class="comment">//显示鸭子信息</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会飞~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//WildDuck.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;这是野鸭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ToyDuck.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//需要重写父类的所有方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭不能叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭不会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭不会飞~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//PekingDuck.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PekingDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;~~北京鸭~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//因为北京鸭不能飞翔，因此需要重写fly</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;北京鸭不能飞&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		<span class="type">WildDuck</span> <span class="variable">wildDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildDuck</span>();</span><br><span class="line">		wildDuck.display();</span><br><span class="line"></span><br><span class="line">		<span class="type">PekingDuck</span> <span class="variable">pekingDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PekingDuck</span>();</span><br><span class="line">		pekingDuck.display();</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line"></span><br><span class="line">		<span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToyDuck</span>();</span><br><span class="line">		duck.display();</span><br><span class="line">		duck.quack();</span><br><span class="line">		duck.swim();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应</p>
<p>可以通过覆盖fly 方法来解决 =&gt; 覆盖解决</p>
</li>
<li><p>策略模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Duck.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性, 策略接口</span></span><br><span class="line">	FlyBehavior flyBehavior;</span><br><span class="line">	<span class="comment">//其它属性&lt;-&gt;策略接口</span></span><br><span class="line">	QuackBehavior quackBehavior;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;<span class="comment">//显示鸭子信息</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子嘎嘎叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//改进</span></span><br><span class="line">		<span class="keyword">if</span>(flyBehavior != <span class="literal">null</span>) &#123;</span><br><span class="line">			flyBehavior.fly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//FlyBehavior.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 子类具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//QuackBehavior.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;<span class="comment">//子类实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ToyDuck.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyDuck</span> <span class="keyword">extends</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ToyDuck</span><span class="params">()</span> &#123;</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> <span class="title class_">NoFlyBehavior</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//需要重写父类的所有方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭不能叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;玩具鸭不会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GoodFlyBehavior.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodFlyBehavior</span> <span class="keyword">implements</span> <span class="title class_">FlyBehavior</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;飞翔技术高超~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.strategy.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">WildDuck</span> <span class="variable">wildDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildDuck</span>();</span><br><span class="line">		wildDuck.fly();<span class="comment">//</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">ToyDuck</span> <span class="variable">toyDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToyDuck</span>();</span><br><span class="line">		toyDuck.fly();</span><br><span class="line">		</span><br><span class="line">		<span class="type">PekingDuck</span> <span class="variable">pekingDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PekingDuck</span>();</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//动态改变某个对象的行为, 北京鸭 不能飞</span></span><br><span class="line">		pekingDuck.setFlyBehavior(<span class="keyword">new</span> <span class="title class_">NoFlyBehavior</span>());</span><br><span class="line">		System.out.println(<span class="string">&quot;北京鸭的实际飞翔能力&quot;</span>);</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：</p>
<ul>
<li>关键：分析项目中变化部分与不变部分</li>
<li>核心思想：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性</li>
<li>体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句</li>
<li>提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得 你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展</li>
<li>每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大</li>
</ul>
<h3 id="源码分析（JDK-Arrays）"><a href="#源码分析（JDK-Arrays）" class="headerlink" title="源码分析（JDK-Arrays）"></a>源码分析（JDK-Arrays）</h3><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链模式（Chain of Responsibility Pattern）,  又叫责任链模式，属于行为型模式，为请求创建了一个接收者对象的链(简单示意图)。对请求的发送者和接收者进行解耦。 通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求， 那么它会把相同的请求传给下一个接收者，依此类推</p>
<p>OA系统采购审批</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Approver.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">	Approver approver;  <span class="comment">//下一个处理者</span></span><br><span class="line">	String name; <span class="comment">// 名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Approver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下一个处理者</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApprover</span><span class="params">(Approver approver)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.approver = approver;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ViceSchoolMasterApprover.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViceSchoolMasterApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ViceSchoolMasterApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &lt; <span class="number">10000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">30000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SchoolMasterApprover.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchoolMasterApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SchoolMasterApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &gt; <span class="number">30000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//PurchaseRequest.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="comment">//请求金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PurchaseRequest</span><span class="params">(<span class="type">int</span> type, <span class="type">float</span> price, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DepartmentApprover.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DepartmentApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CollegeApprover.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollegeApprover</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CollegeApprover</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &lt; <span class="number">5000</span> &amp;&amp; purchaseRequest.getPrice() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Client.java</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.responsibilitychain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建一个请求</span></span><br><span class="line">		<span class="type">PurchaseRequest</span> <span class="variable">purchaseRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PurchaseRequest</span>(<span class="number">1</span>, <span class="number">31000</span>, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建相关的审批人</span></span><br><span class="line">		<span class="type">DepartmentApprover</span> <span class="variable">departmentApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentApprover</span>(<span class="string">&quot;张主任&quot;</span>);</span><br><span class="line">		<span class="type">CollegeApprover</span> <span class="variable">collegeApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CollegeApprover</span>(<span class="string">&quot;李院长&quot;</span>);</span><br><span class="line">		<span class="type">ViceSchoolMasterApprover</span> <span class="variable">viceSchoolMasterApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViceSchoolMasterApprover</span>(<span class="string">&quot;王副校&quot;</span>);</span><br><span class="line">		<span class="type">SchoolMasterApprover</span> <span class="variable">schoolMasterApprover</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchoolMasterApprover</span>(<span class="string">&quot;赵校长&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//需要将各个审批级别的下一个设置好 (处理人构成环形: )</span></span><br><span class="line">		departmentApprover.setApprover(collegeApprover);</span><br><span class="line">		collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">		viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">		schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line"></span><br><span class="line">		departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">		viceSchoolMasterApprover.processRequest(purchaseRequest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
<li>性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阀值， 超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器</li>
</ul>
<h3 id="源码分析（SpringMVC）"><a href="#源码分析（SpringMVC）" class="headerlink" title="源码分析（SpringMVC）"></a>源码分析（SpringMVC）</h3><p>SpringMVC-HandlerExecutionChain 类就使用到职责链模式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/post/bae4ff13.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis 是一款高性能的 NoSQL 系列的非关系型数据库<br>优点：</p>
<ol>
<li>速度快</li>
<li>支持丰富的数据类型</li>
<li>持久化</li>
<li>支持集群</li>
<li>支持事务</li>
<li>支持 Lua 脚本</li>
<li>支持多种语言</li>
</ol>
<p>缺点：</p>
<ol>
<li>单线程</li>
<li>内存消耗大</li>
<li>持久化效率低</li>
<li>集群规模有限</li>
</ol>
<p>应用场景：</p>
<ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等）</li>
<li>计数器</li>
<li>消息队列</li>
<li>分布式锁</li>
<li>排行榜</li>
<li>社交网络</li>
<li>实时系统</li>
</ul>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>官网：<a href="https://redis.io/">https://redis.io/</a><br>中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a><br>Windows版本：</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Redis 的数据结构：<br>Redis 存储的是 key-value 格式的数据，其中 key 都是字符串，value 有 5 种不同的数据结构：</p>
<ul>
<li>字符串类型 String </li>
<li>哈希类型 Hash：map 格式 </li>
<li>列表类型 List：LinkedList 格式（支持重复元素） </li>
<li>集合类型 Set：HashSet 格式（不允许重复元素） </li>
<li>有序集合类型 SortedSet：不允许重复元素，且元素有顺序</li>
</ul>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h2 id="无分类"><a href="#无分类" class="headerlink" title="无分类"></a>无分类</h2><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h2 id="RDB-amp-AOF"><a href="#RDB-amp-AOF" class="headerlink" title="RDB&amp;AOF"></a>RDB&amp;AOF</h2><h2 id="RDB-amp-AOF-amp-复制"><a href="#RDB-amp-AOF-amp-复制" class="headerlink" title="RDB&amp;AOF&amp;复制"></a>RDB&amp;AOF&amp;复制</h2><h2 id="RDB-amp-AOF-amp-复制-amp-集群"><a href="#RDB-amp-AOF-amp-复制-amp-集群" class="headerlink" title="RDB&amp;AOF&amp;复制&amp;集群"></a>RDB&amp;AOF&amp;复制&amp;集群</h2><h2 id="RDB-amp-AOF-amp-复制-amp-集群-amp-哨兵"><a href="#RDB-amp-AOF-amp-复制-amp-集群-amp-哨兵" class="headerlink" title="RDB&amp;AOF&amp;复制&amp;集群&amp;哨兵"></a>RDB&amp;AOF&amp;复制&amp;集群&amp;哨兵</h2><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><h1 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h1><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><h1 id="Redis管道"><a href="#Redis管道" class="headerlink" title="Redis管道"></a>Redis管道</h1><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h1 id="Redis缓存穿透"><a href="#Redis缓存穿透" class="headerlink" title="Redis缓存穿透"></a>Redis缓存穿透</h1><h1 id="Redis缓存雪崩"><a href="#Redis缓存雪崩" class="headerlink" title="Redis缓存雪崩"></a>Redis缓存雪崩</h1><h1 id="Redis缓存击穿"><a href="#Redis缓存击穿" class="headerlink" title="Redis缓存击穿"></a>Redis缓存击穿</h1><h1 id="Redis缓存更新"><a href="#Redis缓存更新" class="headerlink" title="Redis缓存更新"></a>Redis缓存更新</h1><h1 id="Redis缓存降级"><a href="#Redis缓存降级" class="headerlink" title="Redis缓存降级"></a>Redis缓存降级</h1><h1 id="Redis缓存预热"><a href="#Redis缓存预热" class="headerlink" title="Redis缓存预热"></a>Redis缓存预热</h1><h1 id="Redis缓存一致性"><a href="#Redis缓存一致性" class="headerlink" title="Redis缓存一致性"></a>Redis缓存一致性</h1><h1 id="Redis缓存并发"><a href="#Redis缓存并发" class="headerlink" title="Redis缓存并发"></a>Redis缓存并发</h1><h1 id="Redis缓存分布式"><a href="#Redis缓存分布式" class="headerlink" title="Redis缓存分布式"></a>Redis缓存分布式</h1><h1 id="Redis缓存原理"><a href="#Redis缓存原理" class="headerlink" title="Redis缓存原理"></a>Redis缓存原理</h1><h1 id="Redis缓存优化"><a href="#Redis缓存优化" class="headerlink" title="Redis缓存优化"></a>Redis缓存优化</h1><h1 id="Redis缓存淘汰策略"><a href="#Redis缓存淘汰策略" class="headerlink" title="Redis缓存淘汰策略"></a>Redis缓存淘汰策略</h1><h1 id="Redis缓存淘汰算法"><a href="#Redis缓存淘汰算法" class="headerlink" title="Redis缓存淘汰算法"></a>Redis缓存淘汰算法</h1><h1 id="Redis缓存淘汰机制"><a href="#Redis缓存淘汰机制" class="headerlink" title="Redis缓存淘汰机制"></a>Redis缓存淘汰机制</h1><h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/post/c24675b4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">MySQL :: Download MySQL Community Server</a></p>
<p>安装配置：<a href="https://blog.csdn.net/qq_40236497/article/details/124592813?ops_request_misc=%7B%22request%5Fid%22%3A%22165689506416781685344242%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165689506416781685344242&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124592813-null-null.142^v30^pc_rank_34,185^v2^control&amp;utm_term=mysql安装配置教程8.0.29&amp;spm=1018.2226.3001.4187">(12条消息) SQL 入门之第一讲——MySQL 8.0.29安装教程(windows 64位)_henry_rhy的博客-CSDN博客_sql8.0安装</a></p>
<p>软件卸载：</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据库（DB,DateBase）：按照数据结构来组织、存储和管理数据的仓库</p>
<p>作用：存储数据，管理数据</p>
<p>分类：</p>
<ul>
<li>关系型数据库（SQL）<ul>
<li>MySQL，Oracle，Sql Server，DB2，SQLlite</li>
<li>通过表和表之间，行和列之间的关系进行数据的存储</li>
</ul>
</li>
<li>非关系型数据库（NoSQL）<ul>
<li>Redis，MongDB</li>
<li>非关系型数据库，对象存储，通过对象的自身的属性来决定</li>
</ul>
</li>
</ul>
<p>数据库管理系统（DBMS）：</p>
<ul>
<li>数据库的管理软件，科学有效的管理数据，维护和获取数据</li>
<li>MySQL，数据管理系统</li>
</ul>
<p>关系型数据库管理系统（RDBMS）来存储和管理大数据量。是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据</p>
<p>关系数据库管理系统（RDBMS）(Relational Database Management System)的特点：</p>
<ul>
<li>1.数据以表格的形式出现</li>
<li>2.每行为各种记录名称</li>
<li>3.每列为记录名称所对应的数据域</li>
<li>4.许多的行和列组成一张表单</li>
<li>5.若干的表单组成database</li>
</ul>
<p>RDBMS的术语：</p>
<ul>
<li><strong>数据库:</strong> 数据库是一些关联表的集合。</li>
<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li>
<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li><strong>外键：</strong>外键用于关联两个表。</li>
<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ul>
<p>MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成，如图所示的一个表格:</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/0921_1.jpg" alt="img"></p>
<ul>
<li>表头(header): 每一列的名称;</li>
<li>列(col): 具有相同数据类型的数据的集合;</li>
<li>行(row): 每一行用来描述某条记录的具体信息;</li>
<li>值(value): 行的具体信息, 每个值必须与该列的数据类型相同;</li>
<li><strong>键(key)</strong>: 键的值在当前列中具有唯一性</li>
</ul>
<p>MySQL是一个<strong>关系型数据库管理系统</strong>，MySQL 是最流行的<strong>关系型数据库管理系统之一</strong>，在 WEB应用方面，MySQL是最好的RDBMS(Relational Database Management System，关系数据库管理系统) 应用软件之一，MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性</p>
<ul>
<li>MySQL 是开源的，目前隶属于 Oracle 旗下产品。</li>
<li>MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL 使用标准的 SQL 数据语言形式。</li>
<li>MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。</li>
<li>MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。</li>
<li>MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。</li>
<li>MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统</li>
</ul>
<p>基本命令行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p密码       -- 链接数据库</span><br><span class="line">flush privileges;     -- 刷新权限</span><br><span class="line">show datAbases；      -- 查看所有数据库</span><br><span class="line">mysql&gt; use school     -- 切换数据库 use 数据库名</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">show tables;      -- 查看数据库中所有的表</span><br><span class="line">describe student；     -- 查看数据库中所有表的信息</span><br><span class="line">create datebase westos;       -- 创建一个数据库</span><br><span class="line">exit;       -- 退出连接</span><br><span class="line"></span><br><span class="line">-- 单行注释   # 单行注释（MySQL特有）</span><br><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>DDL      数据库定义语言</p>
<p>DML     数据库操作语言</p>
<p>DQL      数据库查询语言</p>
<p>DCL       数据库控制语言</p>
<h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>操作数据库 &gt; 操作数据库中的表 &gt; 操作数据库中表的数据</p>
<p>mysql关键字不区分大小写</p>
<p>操作数据库：</p>
<ol>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABAS [IF NOT EXISTS] westos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] westos</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- tab键的上面，如果表名或字段名为一个特殊字符，则需要加&#x27;&#x27;</span><br><span class="line">USE &#x27;test&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASE    -- 查看所有数据库</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据库的列类型</p>
<ul>
<li><p>数值：</p>
<ul>
<li>tinyint            十分小的数据              1个字节</li>
<li>smallint         极小的数据                  2个字节</li>
<li>mediumint    中等大小的数据          3个字节</li>
<li><strong>int                   标准的整数                 4个字节</strong></li>
<li>big                   较大的数据                  8个字节</li>
<li>float                 浮点数                          4个字节</li>
<li>double              浮点数                        8个字节（精度问题）</li>
<li>decimal              字符串形式的浮点数        金融计算的时候，一般使用decimal</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li>char                  字符串固定大小的              0~255</li>
<li>varchar             可变字符串                         0~65535      常用的String</li>
<li>ting                     微型文本                              2^8-1</li>
<li>text                         文本串                           2^16-1             保存大文本</li>
</ul>
</li>
<li><p>时间日期</p>
<ul>
<li>date                  YYYY-MM-DD            日期格式</li>
<li>time                  HH：mm：sss            时间格式</li>
<li>datetime          YYYY-MM-DD HH：mm：sss               最常用的时间格式</li>
<li>timestamp         时间戳，自1970.1.1到现在的毫秒数</li>
<li>year                   年份</li>
</ul>
</li>
<li><p>null</p>
<p>没有值，未知</p>
<p><strong>注意：不要使用NULL运算，结果为NUL</strong></p>
</li>
</ul>
<p>数据库字段属性（重点）</p>
<p>Unsigned：</p>
<ul>
<li>无符号的整数</li>
<li>声明了该列不能声明为负数</li>
</ul>
<p>zerofill：</p>
<ul>
<li>0填充的</li>
<li>不足的位数使用0来填充</li>
</ul>
<p>自增：</p>
<ul>
<li>通常理解为自增，自动在上一条记录上+1（默认）</li>
<li>通常用来设计唯一的主键<br>-</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="==正则表达式=="></a>==正则表达式==</h4><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合 要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户 输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常 复杂的查询</p>
<p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式</p>
<ol>
<li><p>查询以特定字符或字符串开头的记录</p>
<p>字符‘^’匹配以特定字符或者字符串开头的文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询以特定字符或字符串结尾的记录</p>
<p>字符‘$’匹配以特定字符或者字符串结尾的文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用符号”.”来替代字符串中的任意一个字符</p>
<p>字符‘.’匹配任意一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用”*”和”+”来匹配多个字符</p>
<p>星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至 少一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba*&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配指定字符串</p>
<p>正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个 字符串，多个字符串之间使用分隔符‘|’隔开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
<ol>
<li><p>匹配指定字符中的任意一个</p>
<p>方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的 文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配指定字符以外的字符</p>
<p>“<sup><a href="#fn_字符集合" id="reffn_字符集合">字符集合</a></sup>” 匹配不在指定集合中的任何字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用{n,}或者{n,m}来指定字符串连续出现的次数</p>
<p>“字符串{n,}”表示至少匹配n次前面的字符；“字符串 {n,m}”表示匹配前面的字符串不少于n次，不多于m次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基本的SELECT语句"><a href="#基本的SELECT语句" class="headerlink" title="基本的SELECT语句"></a>基本的SELECT语句</h2><p>SELECT…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 1; #没有任何子句</span><br><span class="line">SELECT 9/2; #没有任何子句</span><br></pre></td></tr></table></figure>
<p>SELECT … FROM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT #标识选择哪些列</span><br><span class="line">FROM #标识从哪个表中选择</span><br></pre></td></tr></table></figure>
<p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节 省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通 配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们</p>
<p>列的别名</p>
<p>去除重复行</p>
<p>默认情况下，查询会返回全部行，包括重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>在SELECT语句中使用关键字DISTINCT去除重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>DISTINCT 需要放到所有列名的前面，如果写成 SELECT salary, DISTINCT department_id FROM employees 会报错</li>
<li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部 门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需 要写 DISTINCT department_id 即可，后面不需要再加其他的列名了</li>
</ol>
<p>空值参与运算</p>
<p>所有运算符或列值遇到null值，运算的结果都为null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary,commission_pct,</span><br><span class="line">12 * salary * (1 + commission_pct) &quot;annual_sal&quot;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>
<p>注意：在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的</p>
<p>着重号</p>
<p>表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在 SQL语句中使用一对``（着重号）引起来</p>
<p>查询常数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;尚硅谷&#x27; as corporation, last_name FROM employees;</span><br></pre></td></tr></table></figure>
<p>显示表结构</p>
<p>使用DESCRIBE 或 DESC 命令，表示表结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE employees;</span><br><span class="line">或</span><br><span class="line">DESC employees;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employees;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| employee_id | int(6) | NO | PRI | 0 | |</span><br><span class="line">| first_name | varchar(20) | YES | | NULL | |</span><br><span class="line">| last_name | varchar(25) | NO | | NULL | |</span><br><span class="line">| email | varchar(25) | NO | UNI | NULL | |</span><br><span class="line">| phone_number | varchar(20) | YES | | NULL | |</span><br><span class="line">| hire_date | date | NO | | NULL | |</span><br><span class="line">| job_id | varchar(10) | NO | MUL | NULL | |</span><br><span class="line">| salary | double(8,2) | YES | | NULL | |</span><br><span class="line">| commission_pct | double(2,2) | YES | | NULL | |</span><br><span class="line">| manager_id | int(6) | YES | MUL | NULL | |</span><br><span class="line">| department_id | int(4) | YES | MUL | NULL | |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>Field：表示字段名称</li>
<li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的</li>
<li>Null：表示该列是否可以存储NULL值</li>
<li>Key：表示该列是否已编制索引</li>
<li>PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一 部分；MUL表示在列中某个给定值允许出现多次</li>
<li>Default：表示该列是否有默认值，如果有，那么值是多少</li>
<li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li>
</ul>
<p>过滤数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1,字段2</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 过滤条件</span><br></pre></td></tr></table></figure>
<ul>
<li>使用WHERE 子句，将不满足条件的行过滤掉</li>
<li>WHERE子句紧随 FROM子句</li>
</ul>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h2 id="TCL"><a href="#TCL" class="headerlink" title="TCL"></a>TCL</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="流程控制与游标"><a href="#流程控制与游标" class="headerlink" title="流程控制与游标"></a>流程控制与游标</h2><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h1 id="MySQL进阶"><a href="#MySQL进阶" class="headerlink" title="MySQL进阶"></a>MySQL进阶</h1><p><a href="https://www.processon.com/view/link/5eafbe626376897466a3403f">72_MySQL 高级开发-ProcessOn</a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看Linux服务器上是否安装过MySQL</span><br><span class="line">rpm -qa | grep -i mysql # 查询出所有mysql依赖包</span><br><span class="line"></span><br><span class="line"># 1、拉取镜像</span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"># 2、创建实例并启动</span><br><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /root/mysql/log:/var/log/mysql \</span><br><span class="line">-v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br><span class="line"></span><br><span class="line"># 3、mysql配置 /root/mysql/conf/my.conf</span><br><span class="line">[client]</span><br><span class="line">#mysqlde utf8字符集默认为3位的，不支持emoji表情及部分不常见的汉字，故推荐使用utf8mb4</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#设置client连接mysql时的字符集,防止乱码</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_general_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line"></span><br><span class="line">#数据库默认字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line">#数据库字符集对应一些排序等规则，注意要和character-set-server对应</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line"># 跳过mysql程序起动时的字符参数设置 ，使用服务器端字符集设置</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"></span><br><span class="line"># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</span><br><span class="line"># 但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，</span><br><span class="line"># 否则MySQL将无法正常处理连接请求！</span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line"># 4、重启mysql容器</span><br><span class="line">docker restart mysql</span><br><span class="line"></span><br><span class="line"># 5、进入到mysql容器</span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"></span><br><span class="line"># 6、查看修改的配置文件</span><br><span class="line">cat /etc/mysql/my.conf</span><br></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#没有chkconfig安装</span><br><span class="line">apt install sysv-rc-conf</span><br><span class="line"></span><br><span class="line"># 设置开机启动</span><br><span class="line">chkconfig mysql on</span><br><span class="line"># 查看启动级别</span><br><span class="line">chkconfig --list|grep mysql</span><br></pre></td></tr></table></figure>
<h3 id="安装位置"><a href="#安装位置" class="headerlink" title="安装位置"></a>安装位置</h3><p>Docker容器就是一个小型的Linux环境，进入到MySQL容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure>
<p>Linux环境下MySQL的安装目录</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/mysql</td>
<td>MySQL数据库文件存放位置</td>
</tr>
<tr>
<td>/usr/share/mysql</td>
<td>错误消息和字符集文件配置</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>客户端程序和脚本 mysqladmin mysqldump</td>
</tr>
<tr>
<td>/etc/init.d/mysql</td>
<td>启停脚本相关</td>
</tr>
</tbody>
</table>
</div>
<h3 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h3><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol>
<li><p>二进制日志<code>log-bin</code>：主从复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#my cnf</span><br><span class="line">#开启mysql binlog功能</span><br><span class="line">log-bin = mysql-bin</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>错误日志<code>log-error</code>：默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my,cnf</span><br><span class="line"># 数据库错误日志文件</span><br><span class="line">log-error = error.log</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>查询日志<code>log</code>：默认关闭，记录查询的sql语句，如果开启会降低MySQL整体的性能，因为记录日志需要消耗系统资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my,cnf</span><br><span class="line"># 慢查询sql日志设置</span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = slow.log</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>数据文件</p>
<ul>
<li>frm文件：存放表结构</li>
<li>myd文件：存放表数据</li>
<li>myi文件：存放表索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql5.7 使用.frm文件来存储表结构</span><br><span class="line"># 使用 .ibd文件来存储表索引和表数据</span><br><span class="line">-rw-r----- 1 mysql mysql 8988 Jun 25 09:31 pms_category.frm</span><br><span class="line">-rw-r----- 1 mysql mysql 245760 Jul 21 10:01 pms_category.ibd</span><br></pre></td></tr></table></figure>
<p>MySQL5.7的Innodb存储引擎可将所有数据存放于ibdata*的共享表空间，也可将每张表存放于独立的.ibd文件的独立表空间。 共享表空间以及独立表空间都是针对数据的存储方式而言的</p>
<ul>
<li>共享表空间：某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1 初始化为10M</li>
<li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。在配置文件my.cnf中设置： innodb_file_per_table</li>
</ul>
</li>
</ol>
<h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><p>连接服务引擎存储<br>架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，`插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</p>
<ol>
<li>连接层<br>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcplip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li>服务层<br>第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li>
<li>引擎层<br>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。</li>
<li>存储层<br>数据存储层，文件系统之上，完成与存储引擎的交互</li>
</ol>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul>
<li><p>查看mysql以提供什么存储引擎<code>show engines;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看mysql当前默认的存储引擎<code>show variables like &#39;%storage_engine%&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%storage_engine%&#x27;;</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| Variable_name                    | Value  |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">| default_storage_engine           | InnoDB |</span><br><span class="line">| default_tmp_storage_engine       | InnoDB |</span><br><span class="line">| disabled_storage_engines         |        |</span><br><span class="line">| internal_tmp_disk_storage_engine | InnoDB |</span><br><span class="line">+----------------------------------+--------+</span><br><span class="line">4 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>MyISAM和InnoDB</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁，操作时只锁某一行，不对其他行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<h2 id="索引优化分析"><a href="#索引优化分析" class="headerlink" title="索引优化分析"></a>索引优化分析</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>性能下降sql、执行时间长、等待时间长</p>
<ol>
<li>查询语句写的差</li>
<li>索引失效 （索引建立了，没用上索引）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ol>
<p>补充：索引分为单值和复合</p>
<ul>
<li>单值：单个表中的某个字段建一个索引</li>
<li>复合：单个表中的某个字段建多个索引</li>
</ul>
<h3 id="常见join查询"><a href="#常见join查询" class="headerlink" title="常见join查询"></a>常见join查询</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/b83a988a5240818d9beb29bae12d76fb.png" alt></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"># 3</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"># 4</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">WHERE B.Key IS NULL;</span><br><span class="line"></span><br><span class="line"># 5</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL;</span><br><span class="line"></span><br><span class="line"># 6</span><br><span class="line">-- SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line"># 7</span><br><span class="line">-- SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key</span><br><span class="line">-- WHERE A.Key IS NULL OR B.Key IS NULL;</span><br><span class="line">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">WHERE B.Key IS NULL;</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">WHERE A.Key IS NULL;</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引（Index）是帮助MySQL高效获取数据的数据结构。<strong>索引是排好序的快速查找数据结构</strong></p>
<p>目的：提高效率，类比资源</p>
<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引</p>
<p>索引会影响到MySQL==查找（WHERE的查询条件）==和==排序（ORDER BY）==两大功能</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p>
<p>我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等</p>
<p>优势：</p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本（不用一直通过磁盘查找）</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
<p>劣势</p>
<ul>
<li>索引列也是要占用空间的（占空间）</li>
<li>更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
</ul>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul>
<li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。</li>
<li>复合索引：即一个索引包含多个列</li>
</ul>
<p>基本语法：</p>
<ul>
<li><p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE] INDEX indexName ON mytable(columnName(length));</span><br><span class="line">//或者</span><br><span class="line">ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnName(length));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除<code>DROP INDEX [indexName] ON mytable;</code></p>
</li>
<li><p>查看<code>SHOW INDEX FROM tableName;</code></p>
</li>
<li><p>添加</p>
<ol>
<li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);</code>：该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><code>ALTER TABLE tbl name ADD UNIQUE index_name (column_list);</code>：这条语句创建索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)。</li>
<li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list);</code>：添加普通索引，索引值可出现多次。</li>
<li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);</code>：该语句指定了索引为FULLTEXT，用于全文索引。</li>
</ol>
</li>
</ul>
<h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><ul>
<li>B+Tree索引</li>
<li>Hash索引</li>
<li>full-text全文索引</li>
<li>R-Tree索引</li>
</ul>
<p>B+Tree 索引检索原理</p>
<p>初始化介绍</p>
<p>浅蓝色的称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示)<br>如磁盘块1包含数据项17和35，包含指针P1、P2、P3,<br>P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p>
<p>真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。</p>
<p>非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p>查找过程</p>
<p>如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO。<br>在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，<br>29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</p>
<p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高</p>
<h4 id="索引情况"><a href="#索引情况" class="headerlink" title="索引情况"></a>索引情况</h4><p>需要建立索引的情况有：</p>
<ul>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li>
<li>查询中统计或者分组字段（分组都是需要排序的）</li>
</ul>
<p>不需要简历索引的情况有：</p>
<ul>
<li>表记录太少</li>
<li>经常增删改的表（提高了查询速度，但是会同时江低更新表的速度，对表进行更新的时候，mysql还要保存数据，还要保存一下索引文件）</li>
<li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
<li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录还会更新索引</li>
<li>Where条件里用不到的字段不创建索引</li>
</ul>
<p>一个索引的选择性越接近于1，这个索引的效率就越高</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Mysql中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划，但不见得最优</p>
<p>MySQL常见瓶颈（通过cpu 、io 、 服务器的硬件进行分析）</p>
<ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
</ul>
<p>服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态</p>
<h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><p>SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的</p>
<p>语法：explain + sql语句</p>
<p>功能</p>
<ul>
<li><code>id</code>：表的读取顺序。</li>
<li><code>select_type</code>：数据读取操作的操作类型。</li>
<li><code>possible_keys</code>：哪些索引可以使用。</li>
<li><code>key</code>：哪些索引被实际使用。</li>
<li><code>ref</code>：表之间的引用。</li>
<li><code>rows</code>：每张表有多少行被优化器查询。</li>
</ul>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<ul>
<li>id相同，执行顺序由上至下</li>
<li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id相同不同，同时存在。永远是id大的优先级最高，id相等的时候顺序执行</li>
</ul>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p>
<p>具体的类型有：</p>
<ul>
<li>SIMPLE - 简单的select查询,查询中不包含子查询或者UNION。</li>
<li>PRIMARY - 查询中若包含任何复杂的子部分，最外层查询则被标记为。（最外层）</li>
<li>SUBQUERY - 在SELECT或WHERE列表中包含了子查询。（内层）越内层等级越高，越先执行</li>
<li>DERIUED - 在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。</li>
<li>UNION - 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中外层SELECT将被标记为：DERIVED。</li>
<li>UNION RESULT - 从UNION表获取结果的SELECT。（合并之后的查询就是这个选项）</li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>访问类型排列</p>
<p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt;ALL</p>
<p>常见的指标主要有：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<ul>
<li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计。</li>
<li>const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快如将主键置于where列表中，MySQL就能将该查询转换为一个常量。（单表中的主键id，一张表一个条件）</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫（联表唯一，和上面的区别在于索引数量不同）</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。（上面的条件是一对一，这个条件是一对多）</li>
<li>range：只检索给定范围的行,使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>
<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。</li>
<li>all：Full Table Scan，将遍历全表以找到匹配的行。<br>（也就是通过 select * 全部数据读取）</li>
</ul>
<h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>possible_keys（理论上要多少索引）<br>显示可能应用在这张表中的索引，一个或多个。<br>查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>key（实际用到的索引）</p>
<p>实际使用的索引。如果为NULL，则没有使用索引<br>查询中若使用了覆盖索引，则该索引仅出现在key列表中</p>
<blockquote>
<p>覆盖索引：查询时未发生回表。查询的字段只能建立在索引的字段中</p>
</blockquote>
<p>key_len （估计用到的长度）<br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好<br>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
<p>计算规则：<a href="https://blog.csdn.net/qq_34930488/article/details/102931490">(21条消息) mysql组合索引建立顺序及key<em>len计算规则</em>-星星-的博客-CSDN博客_mysql组合索引顺序</a></p>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值（显示使用到的条件查询，如果是常量就为const）</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。（越小越好）</p>
<p>每张表被优化器查询<br>把不合适的索引删除，慢慢优化</p>
<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<ul>
<li><p>Using filesort</p>
<p>说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取</p>
<p>MySQL中无法利用索引完成的排序操作称为”文件内排序”</p>
</li>
<li><p>Using temporary</p>
<p>使用了临时表保存中间结果，MySQL在対查询结果排序时使用了临时表。常见于排序order by和分组查询group by。临时表対系统性能损耗很大</p>
</li>
<li><p>Using index</p>
<p>表示相应的SELECT操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现Using where，表示索引被用来执行索引键值的查找；如果没有同时出现Using where，表明索引用来读取数据而非执行查找动作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
<ul>
<li>Using where：表明使用了WHERE过滤</li>
<li>Using join buffer：使用了连接缓存</li>
<li>Aimpossible where：WHERE子句的值总是false，不能用来获取任何元组</li>
</ul>
</li>
</ul>
<h3 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h3><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/post/df2849ec.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="八大数据类型（基本数据类型）"><a href="#八大数据类型（基本数据类型）" class="headerlink" title="八大数据类型（基本数据类型）"></a>八大数据类型（基本数据类型）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">30L</span>;  <span class="comment">//long类型要在数字后面加L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小数/浮点数</span></span><br><span class="line"><span class="type">float</span> <span class="variable">num5</span> <span class="operator">=</span> <span class="number">50.1F</span>;  <span class="comment">//float类型要在数字后面加F</span></span><br><span class="line"><span class="type">double</span> <span class="variable">num6</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符</span></span><br><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">//字符串，String不是关键字，而是类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ol>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ol>
<h4 id="数据类型拓展"><a href="#数据类型拓展" class="headerlink" title="数据类型拓展"></a>数据类型拓展</h4><h5 id="整数拓展"><a href="#整数拓展" class="headerlink" title="整数拓展"></a>整数拓展</h5><p>二进制0b      十进制      八进制0      十六进制0x</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">010</span>;    <span class="comment">//八进制0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0x10</span>;   <span class="comment">//十进制0x  0~9 A~F 16</span></span><br><span class="line"></span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure>
<h5 id="浮点数扩展"><a href="#浮点数扩展" class="headerlink" title="浮点数扩展"></a>浮点数扩展</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;   <span class="comment">//BigDecimal  数学工具类，表示银行业务，钱</span></span><br></pre></td></tr></table></figure>
<p>浮点型(float,double)：有限  离散  舍入误差  大约   接近但不等于，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1f</span>;    <span class="comment">//0.1</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.0</span>/<span class="number">10</span>;  <span class="comment">//0.1</span></span><br><span class="line">        System.out.println(a == b);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">234567890123f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">d</span> <span class="operator">=</span> c + <span class="number">1</span>;</span><br><span class="line">        System.out.println(c == d);   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最好完全使用浮点数进行比较</strong></p>
<h5 id="字符扩展"><a href="#字符扩展" class="headerlink" title="字符扩展"></a>字符扩展</h5><p>所有的字符本质还是数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println((<span class="type">int</span>)c1);   <span class="comment">//强制转换</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println((<span class="type">int</span>)c2);   <span class="comment">//强制转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码</p>
<h5 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h5><h5 id="对象-从内存分析"><a href="#对象-从内存分析" class="headerlink" title="对象 从内存分析"></a>对象 从内存分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.out.println(a == b);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        System.out.println(c == d);    <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="布尔值扩展"><a href="#布尔值扩展" class="headerlink" title="布尔值扩展"></a>布尔值扩展</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag = <span class="literal">true</span>)&#123;&#125; == <span class="keyword">if</span> (flag)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol>
<li><p>强制类型转换      (类型)变量名称      高—低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">byte</span>)i;   <span class="comment">//如果数值过大，容易导致内存溢出</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动类型转换        低—高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点：</p>
<ul>
<li>不能对布尔值进行转换</li>
<li>不能把对象类型转换为不相干的类型</li>
<li>在把高容量转换为低容量时，强制转换</li>
<li>转换的时候可能存在<strong>内存溢出</strong>(操作过大的时候)或者<strong>精度</strong>问题    JDK7新特性，数字之间可以用下划线分割</li>
</ul>
</li>
</ol>
<h3 id="变量，常量，作用域"><a href="#变量，常量，作用域" class="headerlink" title="变量，常量，作用域"></a>变量，常量，作用域</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol>
<li>变量是可以变化的量       变量必须声明             变量类型  变量名字 = new 变量名字</li>
<li>Java变量是最基本的存储单元，其要素包括变量名，变量类型和作用域       //数据类型     变量名 = 值</li>
<li><p>注意事项：</p>
<ul>
<li>每个变量必须有类型，可以是基本类型，也可以是引用类型</li>
<li>变量必须是合法的标识符</li>
<li>变量声明是一条完整的语句，每个变量写完必须以分号结束</li>
</ul>
</li>
<li><p><strong><em>变量的命名规范</em></strong></p>
<ul>
<li>所有变量、方法、类名：见名知意</li>
<li>类成员变量：<strong>首字母小写</strong>和<strong>驼峰原则</strong>，除了第一个单词以外，后面的单词首字母大写</li>
<li>局部变量：<strong>首字母小写</strong>和<strong>驼峰原则</strong></li>
<li>常量：<strong>大写字母</strong>和<strong>下划线</strong></li>
<li>类名：<strong>首字母大写</strong>和<strong>驼峰原则</strong></li>
<li>方法名：<strong>首字母小写</strong>和<strong>驼峰原则</strong></li>
</ul>
</li>
</ol>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>从属于对象，如果不自行初始化，则这个类型的默认值为0，0.0</p>
<p>布尔值的的默认类型是false，除了基本类型，其他的默认值都是null</p>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>必须声明和初始化值</p>
<h5 id="类变量-static"><a href="#类变量-static" class="headerlink" title="类变量 static"></a>类变量 static</h5><p>加上static关键字是存储于类</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ol>
<li>常量：初始化后不能改变值，不能变动的值       final 常量名 = 值    (final是修饰符，不存在先后顺序)</li>
<li>常量名一般用大写字符</li>
</ol>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Java支持此下运算符：</p>
<ul>
<li><p>算术运算符：+,-,*,/,%,++,—</p>
<ul>
<li><p>自增自减运算符(一元运算符)：++，—</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line">        <span class="comment">//a = a + 1</span></span><br><span class="line">        System.out.println(b);    <span class="comment">//执行完这行代码后，先给b赋值，再自增</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++a;</span><br><span class="line">        <span class="comment">//a + a + 1</span></span><br><span class="line">        System.out.println(c);    <span class="comment">//执行完这行代码前，先自增，再给c赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//幂运算</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(pow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>赋值运算符：=</p>
</li>
<li><p>关系运算符：&gt;,&lt;,=,&lt;=,==,!=        返回结果：正确/错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(a&gt;b);</span><br><span class="line">        System.out.println(a&lt;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符：&amp;&amp;,||,!</p>
</li>
<li><p>位运算符：&amp;,|,^,~,&gt;&gt;,&lt;&lt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A = 0011 1100</span></span><br><span class="line"><span class="comment">B = 0000 1101</span></span><br><span class="line"><span class="comment">A&amp;B = 0000 1100</span></span><br><span class="line"><span class="comment">A|B = 0011 1101</span></span><br><span class="line"><span class="comment">A^B = 0011 0001</span></span><br><span class="line"><span class="comment">~B = 1111 0010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;&lt;左移   相当于*2</span></span><br><span class="line"><span class="comment">&gt;&gt;右移   相当于/2</span></span><br><span class="line"><span class="comment">根据二进制表：</span></span><br><span class="line"><span class="comment">0000 0000   0</span></span><br><span class="line"><span class="comment">0000 0001   1</span></span><br><span class="line"><span class="comment">0000 0010   2</span></span><br><span class="line"><span class="comment">0000 0011   3</span></span><br><span class="line"><span class="comment">0000 0100   4</span></span><br><span class="line"><span class="comment">0000 1000   8</span></span><br><span class="line"><span class="comment">0001 0000   16</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>条件运算符：?:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x ? y : z      <span class="comment">//如果x==true，则结果为y，否则结果为z</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展赋值运算符：+=,-=,*=,/=</p>
</li>
<li><p>优先级</p>
</li>
</ul>
<h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>为了更好的组织类，Java提供了包机制，用于区别类名的命名空间</p>
<p>包语句的语法格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg2[.pkg3]];</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">package</span> com.company;</span><br></pre></td></tr></table></figure>
<p>包属于标识符</p>
<p>一般利用公司域名倒置作为包名</p>
<p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包，使用“import”可完成此功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2](classname|*);</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br></pre></td></tr></table></figure>
<h3 id="Java-Doc生成文档"><a href="#Java-Doc生成文档" class="headerlink" title="Java Doc生成文档"></a>Java Doc生成文档</h3><p>Java Doc命令是用来生成自己 API 文档的</p>
<p>参数信息：</p>
<ul>
<li>@author   作者名</li>
<li>@version   版本号</li>
<li>@since       指明需要最早使用的 jdk 版本</li>
<li>@param     参数名</li>
<li>@return     返回值情况</li>
<li>@throws    异常抛出情况</li>
</ul>
<h2 id="Java流程控制"><a href="#Java流程控制" class="headerlink" title="Java流程控制"></a>Java流程控制</h2><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h3><h4 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h4><p><code>java.util.Scanner</code>是Java 5的新特征，我们可以通过Scanner来获取用户输入基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>
<p>通过Scanner类的next()和nextLine()方法获取输入的字符串读取前我们一般需要使用hasnext()与hasnextLine()判断是否还有输入的数据</p>
<h4 id="Scanner进阶"><a href="#Scanner进阶" class="headerlink" title="Scanner进阶"></a>Scanner进阶</h4><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>Java基本结构是顺序结构，除非特别指明，否则就按照顺序一句一句执行</p>
<p>顺序结构是最简单的算法，它是任何一个算法都离不开的一种基本算法结构</p>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><h5 id="if单选结构"><a href="#if单选结构" class="headerlink" title="if单选结构"></a>if单选结构</h5><p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值)&#123;</span><br><span class="line">    <span class="comment">//如果布尔值表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入内容&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//equals:判断字符串是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;hello&quot;</span>))&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="if双选结构"><a href="#if双选结构" class="headerlink" title="if双选结构"></a>if双选结构</h5><p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔值表达式为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果布尔值表达式为false将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="if多选结构"><a href="#if多选结构" class="headerlink" title="if多选结构"></a>if多选结构</h5><p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔值表达式1为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔值表达式2为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔值表达式3为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果以上布尔值表达式都不为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="if嵌套结构"><a href="#if嵌套结构" class="headerlink" title="if嵌套结构"></a>if嵌套结构</h5><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch case 语句判断一个变量与一系列值中的某个值是否相等，每个值称为一个分支</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">//可选</span></span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch语句中的变量类型可以是：</p>
<ul>
<li><p>byte，short，int或者char</p>
</li>
<li><p>从Java SE 7开始，switch支持字符串String类型</p>
<p>jdk7新特性，表达式可以是字符串（字符的本质是数字），</p>
<p><em>反编译</em>   Java——class(字节码文件)——反编译(IDEA)</p>
</li>
<li><p>case标签必须为字符串常量或者字面量</p>
</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while是最基本的循环，它的结构是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要布尔表达式为true，循环就会一直执行下去</p>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span> (布尔表达式)</span><br></pre></td></tr></table></figure>
<p>do while 循环至少执行一次</p>
<p>while 和do while 循环的区别：</p>
<ul>
<li>while先判断后执行，do while先执行后判断</li>
<li>do while 总是保证循环至少执行一次</li>
</ul>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>for 循环是支持迭代的一种通用结构是最有效、最灵活的循环</p>
<p>for 循环执行的次数是在循环前就确定的，语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增强for 循环：</p>
<ul>
<li><p>Java 5引入了一种用于数组或集合的增强型for语句</p>
</li>
<li><p>语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (声明语句：表达式)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>声明语句：声明新的局部变量，该变量的类型必须与数组元素的类型匹配，其作用域限定在循环语句块，其值与数组元素的值相等</p>
</li>
<li><p>表达式：表达式就是要访问的数组名，或者是返回值为数组的方法</p>
</li>
</ul>
</li>
</ul>
<h3 id="break-continue-goto"><a href="#break-continue-goto" class="headerlink" title="break continue goto"></a>break continue goto</h3><p>break用于强行退出循环，不执行循环中剩余的语句</p>
<p>continue用于终止某次循环过程，即跳过循环中尚未执行的语句，接着进行下一次是否执行循环的判定</p>
<p>goto关键字</p>
<h3 id="Java流程控制例子"><a href="#Java流程控制例子" class="headerlink" title="Java流程控制例子"></a>Java流程控制例子</h3><h4 id="打印三角形"><a href="#打印三角形" class="headerlink" title="打印三角形"></a>打印三角形</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">5</span>; j &gt;= i; j--)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot;*&quot;</span> + j + <span class="string">&quot;=&quot;</span> + (i * j) + <span class="string">&quot;\t&quot;</span>);  <span class="comment">//print()输出后不会换行</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();  <span class="comment">//println()输出后会换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h2><p>Java方法是语句的结合：</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含与类或对象中</li>
<li>方法在程序这被创建，其他地方被调用</li>
</ul>
<p>设计方法的原则：一个方法只完成一个功能</p>
<h3 id="定义及调用"><a href="#定义及调用" class="headerlink" title="定义及调用"></a>定义及调用</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Java方法类似与其他语言的函数，是一段用来完成特定功能的代码片段</p>
<p>方法包含一个方法头和一个方法体，一个方法的所有部分：：</p>
<ul>
<li>修饰符  可选的</li>
<li>返回值类型</li>
<li>方法名</li>
<li>参数类型<ul>
<li>形式参数  用来定义作用的</li>
<li>实参 实际调用传给它的参数</li>
</ul>
</li>
<li>方法体</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 (参数类型 参数名)&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>调用方法：对象名. 方法名(实参列表)</p>
<p><em>值传递（Java）</em>  <em>引用传递</em></p>
<h4 id="return关键字的使用："><a href="#return关键字的使用：" class="headerlink" title="return关键字的使用："></a>return关键字的使用：</h4><ol>
<li>使用范围：使用在方法体中</li>
<li>作用：<ul>
<li>结束方法：</li>
<li>针对有返回值类型的方法，使用“return 数据”方法</li>
</ul>
</li>
<li>注意点：return关键字后面不可以声明执行语句</li>
</ol>
<h3 id="重裁"><a href="#重裁" class="headerlink" title="重裁"></a>重裁</h3><p>重裁就是在一个类中，有相同的函数名称，但形参不同的函数</p>
<p>规则：</p>
<ul>
<li>方法名称必须相同</li>
<li>参数列表必须不同（个数不同，类型不同或排列顺序不同）</li>
<li>方法的返回类型可以相同可以不同</li>
<li>仅仅返回类型不同不足以构成重裁</li>
</ul>
<h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Java 1.5开始，Java支持传递同类型的的可变参数给一个方法</p>
<p>在方法声明中，在指定参数类型后面加省略号(…)</p>
<p>一个方法中只能指定一个可变参数，它必须是方法中最后一个参数，任何普通的参数必须在它之前声明</p>
<p>可变个数形参（JDK5.0新增内容）：</p>
<p>具体使用：</p>
<ol>
<li>可变个数形参的格式，数据类型 … 变量名</li>
<li>可调用可变个数形参的方法，传入的参数个数可以是0个，1个，3个。。。</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重裁</li>
</ol>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归就是调用自身</p>
<p>递归结构包含两部分;</p>
<ul>
<li>递归头：什么时候不调用自身方法</li>
<li>递归体：什么时候调用自身方法</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  n*f(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>数组是相同类型数据的有序结合</p>
<p>数组的描述是相同类型的若干个数据，按照一定的先后次序排列而成</p>
<p>其中，每一个数据称为数组元素，每个数组元素可以通过一个下标来访问</p>
<h3 id="数组声明创建"><a href="#数组声明创建" class="headerlink" title="数组声明创建"></a>数组声明创建</h3><p>声明数据变量的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dateType[] arrayRefVar;     <span class="comment">//首选方法</span></span><br></pre></td></tr></table></figure>
<p>JAVA语言使用new操作符来创建数组，语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dateType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dateType</span>[arraySize];</span><br></pre></td></tr></table></figure>
<p>数组的元素是通过索引来访问的数组索引从0开始</p>
<p>获取数组长度： <code>arrays.length</code></p>
<p><strong>数组的特点：</strong></p>
<ul>
<li><p>数组的长度是固定的，不可变的，不能越界</p>
<p>数组下标越界报错 <code>ArrayIndexOutOfBoundsException</code></p>
</li>
<li><p>其元素必须是相同类型</p>
</li>
<li><p>数组中的元素可以是任意类型，包括基本类型和引用类型</p>
</li>
<li><p>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的</p>
</li>
</ul>
<p><strong>Java内存</strong></p>
<p>三种初始化</p>
<ul>
<li>静态初始化：创建+赋值</li>
<li>动态初始化包含默认初始化</li>
<li>数组默认初始化</li>
</ul>
<h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><ul>
<li><strong>普通for循环</strong></li>
<li><strong>For—Each循环</strong></li>
<li><strong>数组作方法入参</strong></li>
<li><strong>数组作返回值</strong></li>
</ul>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组可以看作顺序数组的在数组，其每个元素都是一个一维数组</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="type">int</span> a[][] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">2</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：杨辉三角</span><br></pre></td></tr></table></figure>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>数组的工具类<code>java.util.Arrays</code></p>
<p>功能：</p>
<ul>
<li>给数组赋值：<code>fill</code>方法</li>
<li>对数组排序：<code>sort</code>方法，升序</li>
<li>比较数组：<code>equals</code>方法，比较数组中元素值是否相等</li>
<li>查找数组元素：<code>binarySearch</code>方法，对排序好的数组进行二分查找</li>
<li>输出数组信息：<code>toString</code>方法</li>
</ul>
<h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><ol>
<li><p>数组角标越界异常：<code>ArrayIndexOutOfBoundsException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= arr.length; i++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针异常：<code>NullPointerException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//情况一</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        arr = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//情况二</span></span><br><span class="line">        <span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">0</span>];</span><br><span class="line">        System.out.println(arr1[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//情况三</span></span><br><span class="line">        String[] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(arr2[<span class="number">0</span>].toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>最出名的排序算法之一,复杂度为O(n2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">45</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">43</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] sort = sort(a);  <span class="comment">//调用完方法后，返回一个排序后的数组</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(sort));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="comment">//1.比较数组中两个相邻元素，如果第一个比第二个大，则交换位置</span></span><br><span class="line">    <span class="comment">//2.每次比较都会产生一个最大的数或者最小的数</span></span><br><span class="line">    <span class="comment">//3.下一轮可以减少一次排序</span></span><br><span class="line">    <span class="comment">//4.依次循环，直到结束</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">        <span class="comment">//临时变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//外层循环，判断需要走多少次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//通过flag标识减少没有意义的比较，使其优化</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//内层循环，比价判断两个数，如果第一个比第二个大，则交换位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j+<span class="number">1</span>] &lt; array[j])&#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>当一个数组中大部分元素为0 时，或者为同一值的数组，可以用稀疏数组来保存该数组</p>
<p>稀疏数组的处理方式：</p>
<ul>
<li><p>记录数组一共有几行几列，有多少不同值</p>
</li>
<li><p>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<p>|                 |  行  |  列  |  值  |<br>| :——————-: | :—: | :—: | :—: |<br>|     [0]总共     |      |      |      |<br>| [1]第一个有效值 |      |      |      |<br>| [2]第二个有效值 |      |      |      |</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个二维数组11*11，  0：没有棋子  1：黑棋   2：白棋</span></span><br><span class="line">        <span class="type">int</span>[][] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        array1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        array1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输出原始数组&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints: array1)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt: ints)&#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转化为稀疏数组保存</span></span><br><span class="line">        <span class="comment">//获取有效值的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;有效值的个数：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        array2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        array2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非零的值放入稀疏数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array1[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    array2[count][<span class="number">0</span>] = i;</span><br><span class="line">                    array2[count][<span class="number">1</span>] = j;</span><br><span class="line">                    array2[count][<span class="number">2</span>] = array1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            System.out.println(array2[i][<span class="number">0</span>] + <span class="string">&quot;\t&quot;</span> + array2[i][<span class="number">1</span>] + <span class="string">&quot;\t&quot;</span> + array2[i][<span class="number">2</span>] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;还原&quot;</span>);</span><br><span class="line">        <span class="comment">//1.读取稀疏数组的值</span></span><br><span class="line">        <span class="type">int</span>[][] array3 = <span class="keyword">new</span> <span class="title class_">int</span>[array2[<span class="number">0</span>][<span class="number">0</span>]][array2[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2.给其中的元素还原它的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            array3[array2[i][<span class="number">0</span>]][array2[i][<span class="number">1</span>]] = array2[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.打印还原数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输出还原数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints: array3)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt: ints)&#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象（抽象"><a href="#面向对象（抽象" class="headerlink" title="面向对象（抽象)"></a>面向对象（抽象)</h3><p>面向对象的本质是：以类的方式组织代码，以对象的组织（封装）数据</p>
<h3 id="对象的创建分析"><a href="#对象的创建分析" class="headerlink" title="对象的创建分析"></a>对象的创建分析</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类的声明</p>
<h4 id="属性和局部变量："><a href="#属性和局部变量：" class="headerlink" title="属性和局部变量："></a>属性和局部变量：</h4><ul>
<li><p>相同点：</p>
<ol>
<li>定义变量的格式，数据类型 变量名 = 变量值</li>
<li>先声明，后使用</li>
<li>变量都有其对应的作用域</li>
</ol>
</li>
<li><p>不同点：</p>
<ol>
<li><p>在类中声明的位置不同</p>
<ul>
<li>属性：直接定义在类的一对{}内</li>
<li>局部变量：声明方法内，方法形参，代码块内，构造器形参构造器内部的变量</li>
</ul>
</li>
<li><p>关于权限修饰符的不同</p>
<ul>
<li><p>属性：可以在声明属性时指明其权限，使用权限修饰符</p>
<p>常用的权限修饰符：private，public，缺省，protected   —&gt;继承</p>
</li>
<li><p>局部变量：不可以使用权限修饰符</p>
</li>
</ul>
</li>
<li><p>默认初始化值</p>
<ul>
<li><p>属性：类的属性，根据其类型，都有默认初始化值，</p>
<p>整型（byte，short，int，long）：0</p>
<p>浮点型（float，double）：0.0</p>
<p>字符型（char）：0（或‘\u000‘）</p>
<p>布尔型（boolean）：false</p>
<p>引用数据类型（类，数组，接口）：null</p>
</li>
<li><p>局部变量：没有默认的初始化值</p>
<p>意味着，我们在调用局部变量之前，一定要显示赋值</p>
<p>特别的，形参在调用时，我们赋值即可</p>
</li>
</ul>
</li>
<li><p>在内存中加载的位置</p>
<ul>
<li>属性：加载到堆空间中（非static）</li>
<li>局部变量：加载到栈空间</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是不能代表某一个具体事物</p>
<p>对象是抽象概念的具体实例</p>
<p>类是对象的模板</p>
<h4 id="创建初始化对象"><a href="#创建初始化对象" class="headerlink" title="创建初始化对象"></a>创建初始化对象</h4><p>使用new关键字创建对象</p>
<p>使用new关键字创建的时候，除了分配内存空间外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用</p>
<p>匿名对象：</p>
<ul>
<li>没有显示的赋给一个变量名，即为匿名对象</li>
<li>特征：匿名对象只能调用一次</li>
<li>使用</li>
</ul>
<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><ul>
<li><p>类中的构造器也称为构造方法，是在进行创建对象时必须调用的，其特点：</p>
<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</li>
</ul>
</li>
<li><p>作用：</p>
<ol>
<li><p>使用new关键字本质是在调用构造器</p>
<p>有参构造：一旦定义了有参构造，无参构造就必须显示定义</p>
</li>
<li><p>用来初始化值</p>
</li>
</ol>
</li>
<li><p>注意：定义了有参构造之后，如果想要使用无参构造，显示的定义一个无参的构造</p>
</li>
</ul>
<h5 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h5><p>Java内存</p>
<p>堆  唯一目的是存放对象实例</p>
<p>栈   是指虚拟机栈，虚拟机栈用于存储局部变量</p>
<p>方法区  用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>一种Java语言写成的可重用组件</p>
<p>所谓JavaBean是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get，set方法</li>
</ul>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p>+表示public类型，-表示private类型，#表示protected类型</p>
<p>方法的写法：方法的类型（+，-） 方法名（参数名：参数类型）：返回值类型</p>
<h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul>
<li><p>作用：</p>
<ol>
<li>提高程序安全性，保护数据；</li>
<li>隐藏代码的实现细节；</li>
<li>统一接口；</li>
<li>增加系统可维护性；</li>
</ol>
</li>
<li><p>属于私有</p>
</li>
<li><p>属性私有，private：私有</p>
</li>
<li><p>get/set</p>
<p>提供可以操作该属性的方法，  提供一些public的get，set方法             alt+insert可以自动生成方法</p>
<ul>
<li>get  获得这个数据</li>
<li>set  给这个数据设置值</li>
</ul>
</li>
</ul>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>本质是对某一批类的抽象，从而实现对现实世界更好的建模</p>
<p>extends的意思是扩展，子类是父类的扩展，子类继承了父类就会继承父类所有的方法</p>
<p>Java类中只有单继承，没有多继承</p>
<ul>
<li><p>object类：Java中，所有的类都默认直接或间接继承object类</p>
</li>
<li><p>super    ——      this</p>
<p>super注意点：</p>
<ol>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ol>
<p>VS   this：</p>
<ol>
<li>代表的对象不同：<ul>
<li>this：本身调用者这个对象</li>
<li>super：代表父类对象的应用</li>
</ul>
</li>
<li>前提：<ul>
<li>this：没有继承也可以使用</li>
<li>super：只能在继承条件下使用</li>
</ul>
</li>
<li>构造方法：<ul>
<li>this：本类的构造</li>
<li>super：父类的构造</li>
</ul>
</li>
</ol>
</li>
<li><p>方法重写   重写是方法的重写，与属性无关   overried 重写</p>
<p>子类的方法和父类必须要一致；方法体不同</p>
<p>静态方法：只与左边定义的数据类型有关</p>
<p>非静态方法：重写</p>
<p>需要有继承关系，子类重写父类的方法</p>
<ol>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大但是不能缩小       public&gt;Protected&gt;Default&gt;private</li>
<li>抛出的异常：范围可以被缩小但是不能扩大         <code>ClassNotFoundException</code>—&gt;<code>Exception</code>(大)</li>
</ol>
</li>
</ul>
<p>Object类 <code>java.lang.Object</code></p>
<p>Object类中的功能（属性，方法）具有通用性</p>
<p>Object类只声明了一个空参的构造器</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>对象的多态性：父类的引用指向子类的对象</p>
<p>多态的使用，虚拟方法调用</p>
<p>方便方法的使用，可以减少重复的代码</p>
<p>注意事项：</p>
<ol>
<li><p>多态是方法的多态，属性没有多态</p>
</li>
<li><p>父类和子类，有联系，        类型转换异常<code>ClassCastException</code></p>
</li>
<li><p>存在条件：继承关系，<em>方法需要重写</em>，父类引用指向子类</p>
<p>不能重写的方法：</p>
<ul>
<li>static方法属于类，不属于实例</li>
<li>final方法</li>
<li>private方法</li>
</ul>
</li>
</ol>
<p>instanceceof和类型转换</p>
<p>子类转换为父类，强制转换，可能丢失一些方法</p>
<p>static关键字</p>
<p>static静态代码块，随类一起执行，只执行一次</p>
<h6 id="和equal-的比较"><a href="#和equal-的比较" class="headerlink" title="==和equal()的比较"></a>==和equal()的比较</h6><ul>
<li><p>==     运算符</p>
<ol>
<li><p>可以引用基本数据类型和引用数据类型</p>
</li>
<li><p>比较基本数据类型，比较两个变量保存的数据是否相同</p>
<p>比较引用数据类型，比较两个对象的地址值是否相同，即两个对象是否指向同一个对象实体</p>
</li>
</ol>
</li>
<li><p>equal     方法而非运算符</p>
<ol>
<li><p>只能使用与引用数据类型</p>
</li>
<li><p>Object类中equal()的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equal</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：Object类中定义的equal和==作用是相同的，比较两个对象的地址是否相同，即两个引用是否指向同一个对象实体</p>
</li>
<li><p>像String、Date、File、包装类等都重写了Object中的equal()方法，重写以后比较的不是两个地址是否相同，而是比较两个对象的“实体内容”是否相同</p>
</li>
<li><p>equal()重写</p>
<p>对称性，自反性，一致性，任何情况下，equal(null)返回false</p>
</li>
</ol>
</li>
</ul>
<h3 id="代码块-或初始化块"><a href="#代码块-或初始化块" class="headerlink" title="代码块(或初始化块)"></a>代码块(或初始化块)</h3><p>作用：用来初始化类，对象</p>
<p>只能用static修饰</p>
<p>静态代码块和非静态代码块：</p>
<ul>
<li><p>静态代码块</p>
<p>内部可以有输出语句</p>
<p>随着类的加载而执行</p>
<p>初始化类的信息</p>
<p>如果一个类中定义了多个静态代码块，按照声明先后顺序执行</p>
<p>静态代码块的执行优先于非静态代码块</p>
<p>静态代码块内只能调用静态的属性，方法</p>
</li>
<li><p>非静态代码块</p>
<p>内部可以有输出语句</p>
<p>随着对象的创建而执行</p>
<p>每创建一个对象，就执行一次非静态代码块</p>
<p>创建对象时，对对象的属性初始化</p>
<p>非静态代码块年可以调用静态的属性，方法，非静态的属性，方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static的代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,static clock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非static的代码块</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello block&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="抽象类（抽象的抽象，约束）"><a href="#抽象类（抽象的抽象，约束）" class="headerlink" title="抽象类（抽象的抽象，约束）"></a>抽象类（抽象的抽象，约束）</h4><p>在类前面使用abstract即可变成抽象类，类的本质还是继承，（接口可以实现多继承）</p>
<p>abstract用在方法上，为抽象方法，只有方法的名字，没有方法的实现</p>
<p>抽象类的所有方法继承了它的子类，都必须要实现它的方法，除非子类也是abstract</p>
<p>不能new出来，只能靠子类实现它</p>
<p>抽象方法必须在抽象类中</p>
<p>//是否存在构造器，存在的意义（抽象出来，提高开发效率）</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>声明类的关键字是class，接口声明的关键字是<code>intreface</code>，接口都需要实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">users</span> &#123;</span><br><span class="line">    <span class="comment">//接口中定义的所有的属性默认的都是常量 public static final</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//接口中定义的所有的方法都是抽象的public interface</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delate</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">uodate</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">time</span> &#123;</span><br><span class="line">    <span class="keyword">void</span>  <span class="title function_">timer</span><span class="params">(String time)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类可以实现接口，implements  接口</span></span><br><span class="line"><span class="comment">//实现了接口的类，就需要重写接口的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">usersImpl</span> <span class="keyword">implements</span> <span class="title class_">users</span>,time&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delate</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uodate</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timer</span><span class="params">(String time)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ol>
<li>约束</li>
<li>定义一些方法，让不同的人实现</li>
<li><code>public interface</code></li>
<li><code>public static final</code></li>
<li>接口不能被实例化，接口中没有构造方法</li>
<li>通过implements可以实现多个接口</li>
<li>必须要重写接口中的方法</li>
</ol>
<p>创建接口匿名实现类的对象</p>
<p>应用：</p>
<ul>
<li>代理模式</li>
<li>工厂模式</li>
</ul>
<h3 id="内部类及OOP实战"><a href="#内部类及OOP实战" class="headerlink" title="内部类及OOP实战"></a>内部类及OOP实战</h3><p>内部类就是在一个类的内部定义一个类</p>
<ol>
<li><p>成员内部类（静态，非静态）</p>
<p>可以获得外部类的私有属性私有方法</p>
<p>一方面，作为外部类的成员，</p>
<ul>
<li>调用外部类的结构</li>
<li>可以被static修饰</li>
<li>可以被四种不同的权限修饰</li>
</ul>
<p>另一方面，作为一个类</p>
<ul>
<li>可以定义属性，方法，构造器等</li>
<li>可以被final修饰，表示不能被继承；不使用final，可以被继承</li>
<li>可以被abstract修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;kala is a dog!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bird</span> <span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span> <span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am a bird!&quot;</span>);</span><br><span class="line">            Person.<span class="built_in">this</span>.eat();</span><br><span class="line">            eat();</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span> <span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(Person.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">BB</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">CC</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态内部类</p>
<p>一个Java类中可以有多个class类，但是只能有一个public class类</p>
</li>
<li><p>局部内部类（方法内，代码块内，构造器内）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个实现了Comparable接口的类对象</span></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类</p>
</li>
</ol>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特性</p>
<p>基本数据类型，包装类，String的转换</p>
<ol>
<li>基本数据类型—————-&gt;包装类        调用包装类的构造器             自动装箱</li>
<li>包装类—————-&gt;基本数据类型        调用包装类Xxx的xxxValue()                 自动拆箱</li>
<li>基本数据类型，包装类—————-&gt;String<ul>
<li>方式一：连接运算</li>
<li>方式二：调用String重载的<code>valueOf(Xxx xxx)</code></li>
</ul>
</li>
<li>String—————-&gt;基本数据类型，包装类</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p>软件程序在运行过程中，可能遇到异常问题，我们叫异常，英文是Exception，意思是例外</p>
<p>异常指程序中出现的不期而至的各种状况，例如：文件找不到，网络连接失败，非法参数等</p>
<p>异常发生在程序运行期间，它影响了正常的程序执行流程</p>
<ul>
<li>检查性异常：最具代表性的检查性异常是用户错误或问题引起的异常</li>
<li>运行时异常：运行时异常是可能会被程序员避免的异常</li>
<li>错误：错误表示异常，而是脱离程序员控制的问题，错误在代码中常常被忽略，例如：栈溢出</li>
</ul>
<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3><p><img src="https://img-blog.csdn.net/20160331115514210" alt></p>
<p>Java把异常当作对象来处理，并定义一个基类<code>Java.lang.Throwable</code>作为所有异常的超类</p>
<p>在Java API 中已经定义了许多异常类，这些异常类分为两大部分，错误 Error和异常 Exception</p>
<h4 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h4><ul>
<li><p>error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关</p>
<p>Java虚拟机运行错误（<code>Vrtual MachineError</code>），当VJM不再有继续执行操作所需要的内存资源，会出现<code>OutOfMemoryError</code>，这些异常发生时，Java虚拟机（JVM）一般会选择线程终止</p>
<p>还有虚拟机试图执行应用时，如类定义错误（<code>NoClassDefFoundError</code>），链接错误（<code>LinkageError</code>），这些错误是不可查的，因为他们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况</p>
</li>
<li><p>Exception</p>
<p>在Exception分支中有一个重要的子类<code>RuntimeError</code>（运行时异常）</p>
<ul>
<li><code>ArrayIndexOutOfBoundExcepton</code>（数组下标越界）</li>
<li><code>NullPointerException</code>（空指针异常）</li>
<li><code>ArithmeticException</code>（算术异常）</li>
<li><code>MissingResourceException</code>（丢失资源）</li>
<li><code>ClassNotFoundException</code>（找不到类）等异常，这些异常通常是不检查异常，程序中可以选择捕获处理，也可以选择不处理</li>
</ul>
<p>这些异常一般由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这些异常的发生</p>
</li>
<li><p>Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（VJM）一般会选择终止线程；Exception通常情况下是开心被程序处理的，并且在程序中一个尽可能的去处理这些异常</p>
</li>
</ul>
<h3 id="Java异常处理机制"><a href="#Java异常处理机制" class="headerlink" title="Java异常处理机制"></a>Java异常处理机制</h3><p>抛出异常，获取异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//（尝试运行的）程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常的变量名)&#123;</span><br><span class="line">  <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//异常发生，方法返回之前，总是要执行的代码</span></span><br><span class="line">&#125;<span class="comment">//Crtl+Alt+T   自动生成</span></span><br></pre></td></tr></table></figure>
<p>以上语法有三个代码块：</p>
<ul>
<li>try语句块，表示要尝试运行代码，try语句块中代码受异常监控，其中代码发生异常时，会抛出异常对象</li>
<li>catch语句块会捕获try代码块中发生的异常并在其代码块中做异常处理，catch语句带一个<code>Throwable</code>类型的参数，表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配，若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了，通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等</li>
<li>finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，而不管是否try语句块是否发生异常。并且这个语句块总是在方法返回前执行，目的是给程序一个补救的机会</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//要监测的代码块</span></span><br><span class="line">            Scanner in=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入被除数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.println(num1+<span class="string">&quot;/&quot;</span>+num2+<span class="string">&quot;=&quot;</span>+num1/num2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;  <span class="comment">//catch（异常类型 异常名称）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;被除数和除数必须要是整数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (java.lang.Exception e)&#123;		<span class="comment">//多重catch的使用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;其他未知异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;   <span class="comment">//不管是否出现异常，finally一定会被执行。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设捕获多个异常，需要从小到大捕获</span></span><br></pre></td></tr></table></figure>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>5个关键字：try，catch，finally，throw，throws</p>
<p>throw和throws：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">      <span class="comment">//抛出一个检查异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;方法test3中的Exception&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><p>throw关键字是用于方法体内部，用来抛出一个<code>Throwable</code>类型的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//要监测的代码块</span></span><br><span class="line">            Scanner in=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.print(<span class="string">&quot;输入被除数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.println(num1+<span class="string">&quot;/&quot;</span>+num2+<span class="string">&quot;=&quot;</span>+num1/num2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;  	  </span><br><span class="line">            System.out.println(<span class="string">&quot;被除数和除数必须要是整数&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InputMismatchException</span>();   <span class="comment">//抛出catch捕捉到的InputMismatchException异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();      <span class="comment">//抛出ArithmeticException异常</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (java.lang.Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;其他未知异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;   <span class="comment">//不管是否出现异常，finally一定会被执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;	<span class="comment">//main()方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//要监测的代码块，为了更直观，将代码封装在了divide()方法中。</span></span><br><span class="line">            divide();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;  <span class="comment">//catch（异常类型 异常名称）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;被除数和除数必须要是整数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (java.lang.Exception e)&#123;     <span class="comment">//多重catch的使用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;其他未知异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;   <span class="comment">//不管是否出现异常，finally一定会被执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过throws声明抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">divide</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123; <span class="comment">//这里是divide()，throws后可以有多个异常,逗号隔开</span></span><br><span class="line"></span><br><span class="line">        Scanner in=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入被除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.println(num1+<span class="string">&quot;/&quot;</span>+num2+<span class="string">&quot;=&quot;</span>+num1/num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SomeClass A=<span class="keyword">new</span> <span class="title class_">SomeClass</span>();</span><br><span class="line">        A.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ER</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span><span class="keyword">throws</span> ER&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>区别：</p>
<ol>
<li>作用不同，throw用于程序员自行产生并抛出异常，throws用于声明该方法内抛出异常</li>
<li>使用位置不同，throw位于方法体内部，可以作为单独语句使用；throws必须跟在方法参数列表的后面，不能单独使用</li>
<li>内容不同：throw抛出一个异常对象，只能是一个;throws后面跟异常类，可以跟多个</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>使用Java内置的异常可以描述在编程中出现的大多数异常，除此之外还可以自定义异常，用户自定义异常，只需要继承Exception即可</p>
<p>在出现中使用自定义异常类，大体步骤：</p>
<ol>
<li>创建自定义异常类</li>
<li>在方法中通过throw抛出异常对象</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try—catch语句捕获并处理；否则在方法的声明处通过throws指明要抛出给方法调用者的异常，继续下一步操作</li>
<li>在出现异常方法的调用者中捕获并处理异常</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</p>
<p>实现：</p>
<ul>
<li><p>饿汉式</p>
<ol>
<li>私有化类的构造器</li>
<li>内部创建类的对象</li>
<li>提供公共的静态方法，返回类的对象</li>
<li>要求此对象也必须声明为静态的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank2</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        System.out.println(bank1 == bank2);    <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.内部创建类的对象</span></span><br><span class="line">    <span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">Instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供公共的静态方法，返回类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式</p>
<ol>
<li>私有化类的构造器</li>
<li>声明当前类对象，没有初始化</li>
<li>声明public，static的返回当前类对象的方法</li>
<li>此对象也必须声明为static的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> Order.getInstance();</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2);       <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明当前类对象，没有初始化</span></span><br><span class="line">    <span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">Instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.声明public，static的返回当前类对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            Instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>饿汉式，懒汉式区别：</p>
<ul>
<li><p>饿汉式：</p>
<p>坏处：对象加载时间过长</p>
<p>好处：饿汉式是线程安全的</p>
</li>
<li><p>懒汉式：</p>
<p>好处：延迟对象的创建</p>
<p>目前写法的坏处：线程不安全</p>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>计算机网络：计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</p>
<p>目的: 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</p>
<p>JavaWeb：网页编程      T/S</p>
<p>网络编程：TCP/IP           C/S</p>
<h3 id="网络通信的要素"><a href="#网络通信的要素" class="headerlink" title="网络通信的要素"></a>网络通信的要素</h3><ul>
<li><p>通信双方的地址：</p>
<ul>
<li><p>IP</p>
<p>IP:唯一的标识 Internet 上的计算机（通信实体）</p>
<p>在Java中使用InetAddress类代表IP</p>
<p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p>
<p>域名: 通过域名解析服务器将域名解析为IP地址</p>
<p>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。</p>
<p>本地回路地址：<code>127.0.0.1</code> 对应着：<code>localhost</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>端口号</p>
<p>用于标识正在计算机上运行的进程。</p>
<ul>
<li><p>要求：不同的进程不同的端口号</p>
</li>
<li><p>范围：被规定为一个 16 位的整数 0~65535。</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>公认端口：0~1023，被预先定义的服务通信占用（HTTP ：80；HTTPS ：443；FTP ：21，TeInet ：23）</p>
</li>
<li><p>注册端口：1024~49151，分配给用户进程或应用程序。（如：Tomcat ：8080，MySQL ：3306，Oracle ：1521等）</p>
</li>
<li><p>动态私有端口：49152~65535</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano  <span class="comment">#查看所有端口</span></span><br><span class="line">netstat -ano|findstr <span class="string">&quot;1572&quot;</span>   <span class="comment">#查看指定端口</span></span><br><span class="line">tasklist|findstr <span class="string">&quot;1572&quot;</span>  <span class="comment">#查看指定端口的进程</span></span><br><span class="line">Ctrl+Shift+Esc  <span class="comment">#打开任务管理器</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>InetAddress类</p>
<p>此类的一个对象就代表着一个具体的IP地址</p>
<p>实例化<code>getByName(String host)/getLocalHost()</code></p>
<p>常用方法<code>getHostName() / getHostAddress()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.10.14&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(inet1);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inet2);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inet3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取本地ip</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet4</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(inet4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//getHostName()</span></span><br><span class="line">            System.out.println(inet2.getHostName());</span><br><span class="line">            <span class="comment">//getHostAddress()</span></span><br><span class="line">            System.out.println(inet2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>规则：网络通信的协议</p>
<p><strong>TCP/IP参考模型：</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190105164025264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNjIy,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>TCP和UDP的区别</strong></p>
<ul>
<li>TCP协议     稳定<ul>
<li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端。</li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，效率低</li>
</ul>
</li>
<li>UDP协议     不稳定<ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
</ul>
</li>
</ul>
<p><strong>TCP三次握手和四次挥手</strong></p>
<p><strong>套接字Socket</strong></p>
<p>端口号与 IP 地址的组合得出一个网络套接字：<code>Socket</code></p>
<ul>
<li>利用套接字(<code>Socket</code>)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。</li>
<li>网络上具有唯一标识的 IP 地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</li>
<li>通信的两端都要有 <code>Socket</code>，是两台机器间通信的端点。</li>
<li>网络通信其实就是 <code>Socket</code> 间的通信。</li>
<li><code>Socket</code> 允许程序把网络连接当成一个流，数据在两个 <code>Socket</code> 间通过 <code>IO</code> 传输。</li>
<li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li>
<li><code>Socket</code> 分类<ul>
<li>流套接字(<code>stream socket</code>)：使用TCP提供可依赖的字节流服务</li>
<li>数据报套接字(<code>datagram socket</code>)：使用UDP提供“尽力而为”的数据报服务</li>
</ul>
</li>
</ul>
<h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>Java语言的基于套接字Socket编程分为客户端和服务端</p>
<ul>
<li><p>客户端Socket的工作过程</p>
<ul>
<li>创建 <code>Socket</code>：根据指定服务端的 IP地址或端口号构造 <code>Sσcket</code> 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 <code>Socket</code> 的输入出流：使用 <code>getInputstream()</code> 方法获得输入流，使用<code>getOutputStream()</code> 方法获得输出流，进行数据传输</li>
<li>按照一定的协议对 <code>Socket</code> 进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程</li>
<li>关闭 <code>Socket</code>：断开客户端到服务器的连接，释放线路</li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>客户端程序可以使用 <code>Socket</code> 类创建对象，创建的同时会自动向服务器方发起连接。</li>
<li><code>Socket</code> 的构造器是：<ul>
<li><code>Socket(String host，int port) throws UnknownHostException</code>，<code>EXCeption</code>：向服务器（域名是 <code>host</code>,端口号为 <code>port</code> ）发起 <code>TCP</code> 连接，若成功，则创建 <code>Socket</code> 对象，否则抛出异常。</li>
<li><code>Socket(InetAddress address，int port)throws IOException</code>：根据 <code>InetAddress</code> 对象所表示的 <code>IP</code> 地址以及端口号 <code>port</code> 发起连接</li>
</ul>
</li>
<li>客户端建立 socketAtClient对象的过程就是向服务器发出套接字连接请求</li>
</ul>
</li>
<li><p>服务器端Socket的工作过程：</p>
<ul>
<li>调用 <code>ServerSocket(int port)</code>：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用 <code>accept0()</code>：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li>
<li>调用该 <code>Socket</code> 类对象的 <code>getOutputStream()</code> 和 <code>getInputStream()</code>：获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭 <code>ServerSocket</code> 和 <code>Socket</code> 对象：客户端访问结束，关闭通信套接字。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><code>ServerSocket</code> 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的 <code>Server Socket</code> 对象。</li>
<li>所谓“接收”客户的套接字请求，就是 <code>accept()</code> 方法会返回一个 <code>Socket</code> 对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端发送信息给服务端，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不建议这样写，可能会有乱码</span></span><br><span class="line">            <span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line">            <span class="comment">//        int len;</span></span><br><span class="line">            <span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line">            <span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line">            <span class="comment">//            System.out.print(str);</span></span><br><span class="line">            <span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端发送文件给服务端，服务端将文件保存在本地</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭数据的输出</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><ul>
<li>类 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 实现了基于 <code>UDP</code> 协议网络程序。</li>
<li><code>UDP</code> 数据报通过数据报套接字 <code>DatagramSocket</code> 发送和接收，系统不保证 <code>UDP</code> 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li>
<li><code>DatagramPacket</code> 对象封装了 <code>UDP</code> 数据报，在数据报中包含了发送端的 <code>IP</code> 地址和端口号以及接收端的 <code>IP</code> 地址和端口号</li>
<li><code>UDP</code> 协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h4 id="DatagramSocket-类"><a href="#DatagramSocket-类" class="headerlink" title="DatagramSocket 类"></a>DatagramSocket 类</h4><p>流程：</p>
<ol>
<li><code>DatagramSocket</code> 与 <code>DatagramPacket</code></li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用 <code>Socket</code> 的发送、接收方法</li>
<li>关闭 <code>Socket</code></li>
</ol>
<p>注意：发送端与接收端是两个独立的运行程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><ul>
<li><p><code>URL(Uniform Resource Locator)</code>：统一资源定位符，它表示 Internet 上某一资源的地址。</p>
</li>
<li><p>它是一种具体的 <code>URI</code>，即 <code>URL</code> 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
</li>
<li><p>通过 <code>URL</code> 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的 <code>URL</code> 可以在网络上查找相应的文件或其他资源</p>
</li>
<li><p>URL的基本结构由5部分组成: &lt;传输协议&gt;：//&lt;主机名&gt;：&lt;端口号&gt;/&lt;文件名&gt;#片段名？参数列表</p>
<p>例如： <code>http://192.168.1.100:8080/helloworld/indexjsp#a?username=shkstart&amp;password=123</code></p>
<p><strong>#片段名</strong>：即锚点，例如看小说，直接定位到章节</p>
<p><strong>参数列表格式</strong>：参数名=参数值&amp;参数名=参数值…</p>
</li>
</ul>
<h4 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h4><h5 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h5><p>为了表示 <code>URL</code>，<code>java.net</code>中实现了类 <code>URL</code>。我们可以通过下面的构造器来初始化一个 <code>URL</code> 对象</p>
<ul>
<li><p><code>public URL(String spec)</code>：通过一个表示 <code>URL</code> 地址的字符串可以构造一个 <code>URL</code> 对象。 例如：<code>URL url = new URL（&quot;[http://www.baidu.com/](http://www.baidu.com/)&quot;);</code></p>
</li>
<li><p><code>public URL(URL context,String spec)</code>：通过基URL和相对URL构造一个URL对象</p>
<p>例如： <code>URL downloadeUrl = new URL(url,&quot;download.html&quot;);</code></p>
</li>
<li><p><code>public URL(String protocol,String host,String file);</code></p>
<p>例如：<code>new URL(&quot;http&quot;,&quot;[www.baidu.com](http://www.baidu.com)&quot;,80,&quot;download.html&quot;);</code></p>
</li>
<li><p><code>public URL(String protocol,String host,int port,String file);</code></p>
<p>例如：<code>new URL(&quot;http&quot;,&quot;[www.baidu.com](http://www.baidu.com)&quot;,80,&quot;download.html&quot;);</code></p>
</li>
</ul>
<p>注意：<code>URL</code> 类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 <code>try-catch</code> 语句进行捕获。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>public String getProtocol()</code> 获取该 <code>URL</code> 的协议名</li>
<li><code>public String getHost()</code> 获取该 <code>URL</code> 的主机名</li>
<li><code>public String getPort()</code> 获取该 <code>URL</code> 的端口号</li>
<li><code>public String getPath()</code> 获取该 <code>URL</code> 的文件路径</li>
<li><code>public String getFile()</code> 获取该 <code>URL</code> 的文件名</li>
<li><code>public String getQuery()</code> 获取该 <code>URL</code> 的查询名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            public String getProtocol(  )     获取该URL的协议名</span></span><br><span class="line">            System.out.println(url.getProtocol());</span><br><span class="line"><span class="comment">//            public String getHost(  )           获取该URL的主机名</span></span><br><span class="line">            System.out.println(url.getHost());</span><br><span class="line"><span class="comment">//            public String getPort(  )            获取该URL的端口号</span></span><br><span class="line">            System.out.println(url.getPort());</span><br><span class="line"><span class="comment">//            public String getPath(  )           获取该URL的文件路径</span></span><br><span class="line">            System.out.println(url.getPath());</span><br><span class="line"><span class="comment">//            public String getFile(  )             获取该URL的文件名</span></span><br><span class="line">            System.out.println(url.getFile());</span><br><span class="line"><span class="comment">//            public String getQuery(   )        获取该URL的查询名</span></span><br><span class="line">            System.out.println(url.getQuery());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：通过URL下载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">            urlConnection.connect();</span><br><span class="line"></span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>程序：为完成特定任务，用某种语言编写的一组指令的的集合。即一段<strong>静态</strong>的代码，静态对象</p>
<p>进程：是程序的一次执行过程，或者正在运行的程序。是一个<strong>动态</strong>的过程，是资源的分配单，</p>
<p>线程：是一个程序内部的一条执行路径，线程是CPU调度和执行的单位，<strong>独立</strong>的执行路径</p>
<p>若一个进程同一时间并行执行多个线程，就是支持多线程的</p>
<p>单核CPU 多核CPU</p>
<p>并行：多个CPU同时执行多个任务</p>
<p>并发：一个CPU同时执行多个任务</p>
<p>多线程：</p>
<p>优点：</p>
<ol>
<li>提高应用程序的响应</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构</li>
</ol>
<p>线程的优先级：</p>
<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN _PRIORITY：1</li>
<li>NORM_PRIORITY：5 —&gt;默认优先级</li>
</ul>
<p>获取和设置当前线程的优先级：</p>
<ul>
<li>getPriority():获取线程的优先级</li>
<li>setPriority(int p):设置线程的优先级</li>
</ul>
<blockquote>
<p>说明：高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p>
</blockquote>
<p>线程通信：wait() / notify() / notifyAll() :此三个方法定义在Object类中的</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>方式一：<strong>继承Tread类</strong></p>
<p>Java虚拟机允许应用程序同时执行多个执行线程，通过<code>java.lang.Thread</code>类实现</p>
<ol>
<li>创建一个继承与Tread类的子类</li>
<li>重写Tread中的run()方法</li>
<li>创建Tread类的子类的对象</li>
<li>通过此对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="comment">//打印100以内的偶数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">myTread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line">        myTread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网图下载</p>
<p>方式二：<strong>实现Runnable接口</strong>（开发中优先选择）</p>
<ol>
<li>创建一个实现Runnable接口的类</li>
<li>实现run()方法</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Tread类的构造器中，创建Tread类的对象</li>
<li>调用start()方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">myTread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myTread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="comment">//龟兔比赛</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Race</span> <span class="variable">race</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Race</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;rabbit&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;tortoise&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Race</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//胜利者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//模拟兔子睡觉</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;rabbit&quot;</span>) &amp;&amp; i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断比赛是否结束</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> gameover(i);</span><br><span class="line">            <span class="comment">//比赛结束，停止程序</span></span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;跑了&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否完成比赛</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">gameover</span><span class="params">(<span class="type">int</span> steps)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有胜利者</span></span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;&#123;</span><br><span class="line">            <span class="keyword">if</span> (steps &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;winner is &quot;</span> + winner);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式三：<strong>实现Callable接口</strong></p>
<ol>
<li>实现Callable接口，需要返回值类型</li>
<li>重写call方法，需要抛出异常</li>
<li>创建目标对象：</li>
<li>创建执行服务：<code>ExecutorService ser = Executors.newFixedThreadPool(1)</code></li>
<li>提交执行：<code>Future&lt;Boolean&gt; result11 = ser.submit(t1)</code></li>
<li>获取结果：<code>boolean r1 = result1.get()</code></li>
<li>关闭服务：<code>set.shutdownNow()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">myTread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(myTread);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get()返回值为FutureTask构造参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好处：</p>
<ul>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
<li>支持泛类的的返回值</li>
<li>借助Future Task类</li>
</ul>
<p>方式四：<strong>线程池</strong></p>
<p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程对性能影响很大</p>
<p>解决方案：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用</p>
<p>好处：</p>
<ul>
<li><p>提高响应速度（减少创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">corePoolSize:核心池的大小</span><br><span class="line">maximumPoolSize:最大线程数</span><br><span class="line">keepAliveTime:线程没有任务时最多保持的时间</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实现方法：</p>
<ol>
<li>提供指定线程数量的线程池</li>
<li>执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</li>
<li>关闭连接池</li>
</ol>
<p>线程池相关的 API：<code>ExecutorService</code>和<code>Excutors</code></p>
<ul>
<li><p><code>ExecutorService</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>:执行任务/命令，没有返回值</span><br><span class="line">&lt;T&gt;Future&lt;T&gt;submit(Callable&lt;T&gt;task):执行任务，有返回值</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>:关闭连接池</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Excutors</code>：工具类、线程池的工厂类，用于创建和返回不同类型的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newCachedThreadPool():创建一个可根据需要创建新线程的线程池</span><br><span class="line">Executors.newFixedThreadPool(n):创建一个可重用固定线程数的线程池</span><br><span class="line">Executors.newSingleThreadExecutor():创建一个只有一个线程的线程池</span><br><span class="line">Executors.newScheduledThreadPool(n):创建一个线程池，它可以安排在给定延迟后运行命令或定期执行</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">//newFixedThreadPool参数为池子大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyTread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyTread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyTread</span>());</span><br><span class="line">        <span class="comment">//2.关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式</p>
<p>静态代理模式：真实对象和代理对象要实现同一个接口，代理对象要代理成真实角色</p>
<p>Lamda表达式</p>
<p>避免匿名内部类定义过多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;多线程&quot;</span>)).start();</span><br></pre></td></tr></table></figure>
<p>函数式接口：任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数式接口，可以通过lambda表达式来创建该接口的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ILove</span> <span class="variable">love</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        love = a-&gt; System.out.println(<span class="string">&quot;i love you---&gt;&quot;</span> + a);</span><br><span class="line">        love.Love(<span class="number">520</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ILove</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Love</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>新建，就绪，运行，阻塞，死亡</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87335f86cc194a089781d888dd4b64b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;<span class="comment">//启动线程，并执行对象的run方法</span></span><br><span class="line">run();<span class="comment">//线程在被调用时的操作</span></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>;<span class="comment">//返回线程的名字</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;<span class="comment">//设置该线程的名字</span></span><br><span class="line"><span class="keyword">static</span> Tread current <span class="title function_">Tread</span><span class="params">()</span>;<span class="comment">//返回当前线程，在Tread子类中就是this，通常用于主线程和Runnable实现类</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">yield</span><span class="params">()</span>;<span class="comment">//线程让步，释放当前CPU执行</span></span><br><span class="line">join();<span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millitime)</span>;<span class="comment">//让当前线程“睡眠”指定的millitime毫秒，抛出InterruptedException异常</span></span><br><span class="line">stop();<span class="comment">//强制线程生命周期结束</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>;<span class="comment">//返回boolean，判断线程是否活着</span></span><br></pre></td></tr></table></figure>
<p>守护线程</p>
<p>线程分为用户线程和守护线程</p>
<p>虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕</p>
<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>多个线程执行的不确定性引起结果不确定性，多个线程对账本的共享，会造成操作的不完全性，会破坏数据</p>
<p>synchronized关键字，包括synchronized方法和synchronized块</p>
<p>方法一：同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码（操作共享数据的代码，共享数据：多个线程共同操作的变量）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Obj称为<strong>同步监视器</strong></p>
<p>同步监视器俗称锁，任何一个类的对象都可以充当锁，多个线程公用一把锁</p>
<p>方法二：同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则会阻塞，方法执行，占用该锁，方法返回释放锁</p>
<p>非静态的同步方法，同步监视器是this，静态的同步方法，同步监视器是当前类本身</p>
<p>死锁</p>
<p>死锁产生的四个必要条件：</p>
<ol>
<li>互斥条件</li>
<li>请求与保持条件</li>
<li>不剥夺条件</li>
<li>循环等条件</li>
</ol>
<p>Lock（锁）</p>
<p>通过显示定义同步锁对象来实现同步，同步锁使用Lock对象充当</p>
<p><code>java.util.concurrent.locks.Lock</code>接口是控制多个线程对共享资源进行访问的工具，每个只能有一个线程对Lock对象加锁，线程开始访问共享资源前应该先获得Lock对象</p>
<p><code>ReentrantLock</code>实现了Lock，有与synchronized相同的并发性和内存语义，可以显示加锁，释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestLock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testLock).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testLock).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testLock).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticketNums &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ticketNums--);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock是显示锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放</p>
<p>Lock只有代码块锁，synchronized有代码块锁和方法锁</p>
<p>使用Lock锁，JVM调线程花费时间少，有更多的扩展性</p>
<p>优先使用顺序：Lock&gt;同步代码块&gt;同步方法</p>
<h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait():一旦执行该方法，当前线程进入阻塞状态，并释放同步监视器</span><br><span class="line">wait(<span class="type">long</span> timeout):指等待的毫秒数</span><br><span class="line">notify():一旦执行该方法，就会唤起被wait的一个线程，如果有多个线程，唤醒优先级高的</span><br><span class="line">notifyAll():一旦执行该方法，就会唤醒所有wait的线程</span><br></pre></td></tr></table></figure>
<ol>
<li>只能出现在同步代码块或同步方法中</li>
<li>必须是同步代码块或同步方法中的同步监视器，否则会出现<code>IllegalMonitorStateException</code>异常</li>
<li>定义在<code>java.lang.Object</code>类中</li>
</ol>
<p>sleep()和wait()的异同：</p>
<ul>
<li>相同点：一旦执行该方法，都可以使当前线程进入阻塞状态</li>
<li>不同点：<ol>
<li>声明位置不同：Tread中声明sleep，Object中声明wait</li>
<li>调用范围（要求）不同：sleep可以在任何需要的场景下调用，wait只能出现在同步代码块或同步方法中</li>
<li>关于释放同步监视器：若均使用在同步代码块或同步方法中，sleep不会释放锁，wait会释放锁</li>
</ol>
</li>
</ul>
<p>生产消费者问题</p>
<p>线程同步问题，生产者和消费者共享一个资源，互相依赖互为条件</p>
<p>synchronized可阻止并发更新同一个共享资源，实现了同步；不能用来实现不同线程之间的消息传递（通信）</p>
<p>解决方法：</p>
<ul>
<li><p>管程法</p>
<p>生产者：负责生产数据的模块（可能是方法，对象，线程，进程）</p>
<p>消费者：负责处理数据的模块（可能是方法，对象，线程，进程）</p>
<p>缓存区：消费者不能直接使用生产者的数据，存在“缓冲区”</p>
<p>生产者将生产好的数据放入缓冲区，消费者从缓冲区取出数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Productor</span>(container).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumor</span>(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了：&quot;</span> + i);</span><br><span class="line">            container.push(<span class="keyword">new</span> <span class="title class_">Chicken</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费了：&quot;</span> + container.pop().id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chicken</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//产品编号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chicken</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span>&#123;</span><br><span class="line">    <span class="comment">//容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> <span class="title class_">Chicken</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//容器计数器</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Chicken chicken)</span>&#123;</span><br><span class="line">        <span class="comment">//容器满了</span></span><br><span class="line">        <span class="keyword">if</span> (count == chickens.length)&#123;</span><br><span class="line">            <span class="comment">//通知消费者消费，生产等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容器没有满</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//可以通知消费者消费</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者消费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否可以消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若可以消费</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="type">Chicken</span> <span class="variable">chicken</span> <span class="operator">=</span> chickens[count];</span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>信号灯法</p>
<p>通过标志位解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Actor</span>(tv).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Audience</span>(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者--&gt;演员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Actor</span><span class="params">(TV tv)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.tv.play(<span class="string">&quot;抖音&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.tv.play(<span class="string">&quot;快手&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者--&gt;观众</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audience</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Audience</span><span class="params">(TV tv)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品--&gt;节目</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span>&#123;</span><br><span class="line">    <span class="comment">//演员表演，观众等待</span></span><br><span class="line">    <span class="comment">//观众观看，演员等待</span></span><br><span class="line">    String name;<span class="comment">//节目名</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表演</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;演员表演：&quot;</span> + name);</span><br><span class="line">        <span class="comment">//通知观众观看</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观看</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;观众观看：&quot;</span> + name);</span><br><span class="line">        <span class="comment">//通知演员表演</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="字符串相关类"><a href="#字符串相关类" class="headerlink" title="字符串相关类"></a>字符串相关类</h3><p>String类：代表字符串</p>
<p>String是final类，代表不可变的字符序列，不可被继承</p>
<p>String对象的字符内容是存储在一个字符数组的value[]中，定义了final char[] value用于存储字符串数据</p>
<p>String实现了<code>Serializable</code>接口，表示字符串支持可序列化；实现了<code>Comparable</code>接口，表示可以比较大小</p>
<h3 id="JDK8-之前的日期时间API"><a href="#JDK8-之前的日期时间API" class="headerlink" title="JDK8 之前的日期时间API"></a>JDK8 之前的日期时间API</h3><h3 id="JDK8-中新日期时间API"><a href="#JDK8-中新日期时间API" class="headerlink" title="JDK8 中新日期时间API"></a>JDK8 中新日期时间API</h3><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><h3 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a><code>BigInteger</code>和<code>BigDecimal</code></h3><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类的使用</p>
<p>类的对象只有有限个，确定的，称为枚举类</p>
<p>需要定义一组常量，可以使用枚举类</p>
<p>若枚举类中只有一个对象，可以作为单例模式的实现方式</p>
<p>枚举类的定义：</p>
<ul>
<li>JDK5.0之前，自定义枚举类</li>
<li>JDK5.0，可以使用enum关键字定义枚举类</li>
</ul>
<p>步骤:</p>
<ol>
<li>私有化构造器，保证不能在类的外部创建其对象；</li>
<li>在类的内部创建枚举类的示例。声明为：public static final；</li>
<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li>
</ol>
<h3 id="enum定义枚举类"><a href="#enum定义枚举类" class="headerlink" title="enum定义枚举类"></a>enum定义枚举类</h3><p>使用说明：</p>
<ul>
<li>使用enum定义的枚举类默认继承了 <code>java.lang.Enum</code> 类，因此不能再继承其他类</li>
<li>枚举类的构造器只能使用private权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(<code>,</code> 分隔 <code>;</code> 结尾)。列出的实例系统会自动添加<code>public static final</code> 修饰</li>
<li>必须在枚举类的第一行声明枚举类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Enum类的常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">values():返回枚举类型的对象数组</span><br><span class="line">valueOf(String str):把一个字符串转换为相应的枚举类对象</span><br><span class="line">toString():返回当前枚举类对象常量的名称</span><br></pre></td></tr></table></figure>
<p>使用enum关键字定义的枚举类实现接口的情况</p>
<p>情况一：实现接口，在enum类中实现抽象方法</p>
<p>情况二：让枚举类的对象分别实现接口中的方法</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>框架=注解+反射+设计模式</p>
<p>Annotation作用：</p>
<ul>
<li>不是程序本身，可以对程序做出解释</li>
<li>可以被其他程序读取</li>
</ul>
<p>格式：@注释名，可以添加参数值</p>
<p>使用地点：可以附加在package，class，method，field上面，通过反射机制编程实现对这些元数据的访问</p>
<h3 id="常见的Annotation："><a href="#常见的Annotation：" class="headerlink" title="常见的Annotation："></a>常见的Annotation：</h3><ul>
<li><p>生成文档相关的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@author</span> 标明开发该类模块的作者，多个作者之间使用，分割 <span class="meta">@version</span> 标明该类模块的版本；</span><br><span class="line"><span class="meta">@see</span> 参考转向，也就是相关主题；</span><br><span class="line"><span class="meta">@since</span> 从哪个版本开始增加的；</span><br><span class="line"><span class="meta">@param</span> 对方法中某参数的说明，如果没有参数就不能写  <span class="meta">@return</span> 对方法返回值的说明，如果方法的返回值类型是 <span class="keyword">void</span> 就不能写 <span class="meta">@exception</span> 对方法可能抛出的异常进行说明，如果方法没有用 <span class="keyword">throws</span> 显式抛出的异常就不能写；</span><br><span class="line">其中 <span class="meta">@param</span> 、 <span class="meta">@return</span> 和 <span class="meta">@exception</span> 这三个标记都是只用于方法的。</span><br><span class="line"><span class="meta">@param</span> 的格式要求：<span class="meta">@param</span> 形参名形参类型形参说明；</span><br><span class="line"><span class="meta">@return</span> 的格式要求：<span class="meta">@return</span> 返回值类型返回值说明；</span><br><span class="line"><span class="meta">@exception</span> 的格式要求：<span class="meta">@exception</span> 异常类型异常说明；</span><br><span class="line"><span class="meta">@param</span> 和 <span class="meta">@exception</span> 可以并列多个；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在编译时进行格式检查（JDK内置的三个基本注解）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>: 定义于java.lang.Override中</span><br><span class="line">    该注解只能用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明</span><br><span class="line"><span class="meta">@Deprecated</span>: 定义于java.lang.Deprecated中</span><br><span class="line">    此注释可以用于修辞方法，用于表示所修饰的元素(类, 方法等)，已过时。</span><br><span class="line">    通常是因为所修饰的结构危险或存在更好的选择；</span><br><span class="line"><span class="meta">@SuppressWarnings</span>: 定义于java.lang.SuppressWarnings中</span><br><span class="line">    抑制编译器警告；需要添加一个参数才能使用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>跟踪代码依赖性，实现替代配置文件功能</p>
<p>在使用Spring框架时会大量用到注解驱动开发</p>
</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自动继承了<code>java.lang.annotation.Annotation</code>接口</p>
<p>定义</p>
<ol>
<li>注解声明为：<code>@interface</code></li>
<li>内部定义成员，通常使用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义注解没成员，表明是一个标识作用</li>
</ol>
<p>说明：</p>
<ul>
<li>如果注解有成员，在使用注解时，需要指明成员的值。</li>
<li>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</li>
<li>自定义注解通过都会指明两个元注解：<code>@Retention</code>、<code>@Target</code></li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解的作用是负责注解其他注解</p>
<p>四个meta-annotation类型，在<code>java.lang.annotation</code>包中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>:用于描述注解的使用范围</span><br><span class="line"><span class="meta">@Retention</span>：表示需要在什么级别保存该注释信息，描述注解的生命周期</span><br><span class="line"><span class="meta">@Documented</span>:说明该注解被包含在javadoc类中</span><br><span class="line"><span class="meta">@Inherited</span>:说明子类可以继承父类的该注解</span><br></pre></td></tr></table></figure>
<h3 id="JDK-8-0中注解的新特性"><a href="#JDK-8-0中注解的新特性" class="headerlink" title="JDK 8.0中注解的新特性"></a>JDK 8.0中注解的新特性</h3><ul>
<li><p>可重复注解</p>
<p>在MyAnnotation上声明 <code>@Repeatabl</code>e，成员值为 <code>MyAnnotations.class</code></p>
<p>MyAnnotation的Target和Retention等元注解与MyAnnotations相同</p>
</li>
<li><p>类型注解</p>
<p><code>ElementType.TYPE_PARAMETER</code>表示该注解能写在类型变量的声明语句中（如：泛型声明）</p>
<p><code>ElementType.TYPE_USE</code> 表示该注解能写在使用类型的任何语句中</p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于 <code>Reflection API</code> 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</li>
<li>加载完类之后，在堆内存的方法区中就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，称之为反射</li>
</ul>
<p>通常的方式：引入需要的“包类”名称——&gt;通过 <code>new</code> 实例化——&gt;获得实例化对象</p>
<p>反射的方式：实例化对象——&gt; <code>getClass()</code> 方法——&gt;得到完整的“包类”名称</p>
<p>框架 = 注解 + 反射 + 设计模式</p>
<p>动态体现：</p>
<p>只有当程序运行时我们才能知道调用的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">    classPath:指定类的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    <span class="comment">//1.通过反射，创建Person类对象</span></span><br><span class="line">    Constructor&lt;Person&gt; cons = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(person);<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调用属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    age.set(person, <span class="number">10</span>);</span><br><span class="line">    System.out.println(person.toString());<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(person);<span class="comment">//my name is Tom and age is 10</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">    <span class="comment">//通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性</span></span><br><span class="line">    <span class="comment">//调用私有的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> cons1.newInstance(<span class="string">&quot;Bruce&quot;</span>);</span><br><span class="line">    System.out.println(p1);<span class="comment">//Person&#123;name=&#x27;Bruce&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name.set(p1, <span class="string">&quot;Jarry&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">nation</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;nation&quot;</span>, String.class);</span><br><span class="line">    nation.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">nation1</span> <span class="operator">=</span> (String) nation.invoke(p1, <span class="string">&quot;China&quot;</span>);<span class="comment">//相当于String nation = p1.showNation(&quot;China&quot;)</span></span><br><span class="line">    System.out.println(nation1);<span class="comment">//I come from China</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关API：</p>
<p><code>java.lang.Class</code>：反射的源头</p>
<p><code>java.lang.reflect.Method</code>：反射方法</p>
<p><code>java.lang.reflect.Field</code>：反射参数</p>
<p><code>java.lang.reflect.Constructor</code>：反射构造器</p>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>概述</p>
<ul>
<li><p>在 <code>Object</code> 类中定义了以下的方法，此方法将被所有子类继承：<code>public final Class getClass()</code></p>
</li>
<li><p>以上的方法返回值的类型是一个 <code>Class</code> 类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即可以通过对象反射求出类的名称。</p>
</li>
<li>对象使用反射后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（ <code>class/interface/enum/annotation/primitive type/void/[]</code>）的有关信息。<ul>
<li><code>Class</code> 本身也是一个类</li>
<li><code>Class</code> 对象只能由系统建立对象</li>
<li>一个加载的类在 JVM 中只会有一个 <code>Class</code> 实例</li>
<li>一个 <code>Class</code> 对象对应的是一个加载到 JVM 中的一个 <code>.class</code> 文件</li>
<li>每个类的实例都会记得自己是由哪个 <code>Class</code> 实例所生成</li>
<li>通过 <code>Class</code> 可以完整地得到一个类中的所有被加载的结构</li>
<li><code>Class</code> 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 <code>Class</code> 对象</li>
</ul>
</li>
</ul>
<p><strong>类的加载过程：</strong></p>
<ul>
<li>程序经过 <code>javac.exe</code> 命令以后，会生成一个或多个字节码文件(<code>.class</code> 结尾)。接着我们使用 <code>java.exe</code> 命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为 <code>Class</code> 的一个实例。</li>
<li>换句话说，<code>Class</code> 的实例就对应着一个运行时类。</li>
<li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类</li>
</ul>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Class的实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;test1.Person&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(str);</span><br><span class="line"><span class="comment">//调用Class的空参构造器创建对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance;</span><br><span class="line"><span class="comment">//获取clazz的name属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.set(obj,<span class="string">&quot;Jarry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> filed.get(obj);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//test1.Person为test1包下的Person类</span></span><br></pre></td></tr></table></figure>
<p>获取class实例</p>
<ol>
<li>已知具体的类，通过类的 <code>class</code> 属性获取，该方法最为安全可靠，程序性能最高 实例：<code>Class clazz = String.class;</code></li>
<li>已知某个类的实例，调用该实例的 <code>getclass()</code> 方法获取 <code>Class</code> 对象 实例：<code>Class clazz=person.getclass();</code></li>
<li>已知一个类的全类名，且该类在类路径下，可通过 <code>Class</code> 类的静态方法 <code>forName()</code> 获取，可能抛出 <code>ClassNotFoundException</code>（比较常用）实例：<code>Class clazz = Class.forName(String classPath)</code></li>
<li>通过类加载器 <code>ClassLoader cl = this.getclass().getClassLoader();</code> <code>Class clazz = cl.loadClass(&quot;类的全类名&quot;);</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    System.out.println(clazz1);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">    Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(clazz1 == clazz3);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class&lt;?&gt; clazz4 = classLoader.loadClass(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line">    System.out.println(clazz1 == clazz4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：创建类的对象的方式</p>
<p>方式一：new + 构造器</p>
<p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。</p>
<p>方式三：通过反射</p>
<p>class实例代表的结构</p>
<ol>
<li><code>class</code>：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li><code>interface</code>：接口</li>
<li><code>[]</code>：数组</li>
<li><code>enum</code>：枚举</li>
<li><code>annotation</code>：注解@interface</li>
<li><code>primitive type</code>：基本数据类型</li>
<li><code>void</code>：无返回值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    Class&lt;Object&gt; c1 = Object.class;</span><br><span class="line">    Class&lt;Comparable&gt; c2 = Comparable.class;</span><br><span class="line">    Class&lt;String[]&gt; c3 = String[].class;</span><br><span class="line">    Class&lt;<span class="type">int</span>[][]&gt; c4 = <span class="type">int</span>[][].class;</span><br><span class="line">    Class&lt;ElementType&gt; c5 = ElementType.class;</span><br><span class="line">    Class&lt;Override&gt; c6 = Override.class;</span><br><span class="line">    Class&lt;Integer&gt; c7 = <span class="type">int</span>.class;</span><br><span class="line">    Class&lt;Void&gt; c8 = <span class="keyword">void</span>.class;</span><br><span class="line">    Class&lt;Class&gt; c9 = Class.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] i1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] i2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; c10 = i1.getClass();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; c11 = i2.getClass();</span><br><span class="line">    <span class="comment">// 只要数组的元素类型与维度一样，就是同一个Class</span></span><br><span class="line">    System.out.println(c10 == c11);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类的加载过程</p>
<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤对该类进行初始化：</p>
<ul>
<li>加载：将 <code>class</code> 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个 <code>Class</code> 对象。这个加载的过程需要类加载器参与</li>
<li><p>链接：将 <code>Java</code> 类的二进制代码合并到JVM的运行状态之中的过程。</p>
<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以 <code>cafe</code> 开头，没有安全方面的问题。</li>
<li>准备：正式为类变量(<code>static</code>)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li>执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。类构造器 <code>&lt;clinit&gt;()</code> 方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>
<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确加锁和同步</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：加载</span></span><br><span class="line"><span class="comment">//第二步：链接结束后m=0</span></span><br><span class="line"><span class="comment">//第三步：初始化结束后，m的值由&lt;clinit&gt;()方法执行决定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(A.m);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1.加载到内存，会产生一个类对应class对象</span></span><br><span class="line"><span class="comment">         2.链接，链接结束后，m = 0</span></span><br><span class="line"><span class="comment">         3.初始化：</span></span><br><span class="line"><span class="comment">               &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">                  System.out.println(&quot;A类静态代码块初始化&quot; );</span></span><br><span class="line"><span class="comment">                  m = 300;</span></span><br><span class="line"><span class="comment">                  m = 100;</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">               m = 100;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类静态代码块初始化&quot;</span> );</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     m = 300</span></span><br><span class="line"><span class="comment">     m = 100</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类的无参构造初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类的主动引用（一定发生类的初始化）</span></span><br><span class="line"><span class="comment">当虚拟机启动，，先初始化main方法所在的类</span></span><br><span class="line"><span class="comment">new一个类的对象</span></span><br><span class="line"><span class="comment">调用类的静态成员（除了final常量）和静态方法</span></span><br><span class="line"><span class="comment">使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line"><span class="comment">当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</span></span><br><span class="line"><span class="comment">类的被动引用（不会发生类的初始化）</span></span><br><span class="line"><span class="comment">当访问一个静态域时，只有真正声明这个域的类才会被初始化</span></span><br><span class="line"><span class="comment">通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">        <span class="comment">//1.主动引用</span></span><br><span class="line">        <span class="comment">//Son son = new Son();//Main类被加载  父类被加载  子类被加载</span></span><br><span class="line">        <span class="comment">//反射会产生主动引用</span></span><br><span class="line">        <span class="comment">//Class.forName(&quot;com.company.Son&quot;);//Main类被加载  父类被加载  子类被加载</span></span><br><span class="line">        <span class="comment">//不会产生类的引用的方法</span></span><br><span class="line">        <span class="comment">//System.out.println(Son.b);//Main类被加载  父类被加载  2</span></span><br><span class="line">        <span class="comment">//Son[] array = new Son[5];//Main类被加载</span></span><br><span class="line">        System.out.println(Son.M);<span class="comment">//Main类被加载   1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的加载器</p>
<ul>
<li><p>作用：</p>
<ul>
<li>将 <code>class</code> 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区中类数据的访问入口</li>
<li>类缓存：标准的 <code>JavaSE</code> 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些 <code>Class</code> 对象</li>
</ul>
</li>
<li><p>分类：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83b66229a80d48339640230806be1ca7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//对于自定义类，使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">    <span class="comment">//调用系统类加载器的getParent()：获取扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader1);</span><br><span class="line">    <span class="comment">//调用扩展类加载器的getParent()：无法获取引导类加载器</span></span><br><span class="line">    <span class="comment">//引导类加载器主要负责加载java的核心类库，无法加载自定义类的。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader3</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Classloader</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//        //读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        //此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = null;</span></span><br><span class="line">    <span class="comment">//        try &#123;</span></span><br><span class="line">    <span class="comment">//            fis = new FileInputStream(&quot;jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">//            pros.load(fis);</span></span><br><span class="line">    <span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//            e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//        &#125; finally &#123;</span></span><br><span class="line">    <span class="comment">//            if (fis != null) &#123;</span></span><br><span class="line">    <span class="comment">//                try &#123;</span></span><br><span class="line">    <span class="comment">//                    fis.close();</span></span><br><span class="line">    <span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//                &#125;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pros.load(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot; password =&quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h3><h4 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    <span class="comment">//方式二</span></span><br><span class="line">    Class&lt;Person&gt; clazz2 = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> clazz1.newInstance();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> clazz2.newInstance();</span><br><span class="line">    System.out.println(person1);</span><br><span class="line">    System.out.println(person2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newInstance()</code>:调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p>
<p>要想此方法正常的创建运行时类的对象，要求：</p>
<ul>
<li>运行时类必须提供空参的构造器</li>
<li>空参的构造器的访问权限得够。通常，设置为 <code>public</code>。</li>
</ul>
<p>在 <code>javabean</code> 中要求提供一个 <code>public</code> 的空参构造器。原因：</p>
<ul>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，默认调用 <code>super()</code> 时，保证父类此构造器</li>
</ul>
<h4 id="调用运行时类的完整结构"><a href="#调用运行时类的完整结构" class="headerlink" title="调用运行时类的完整结构"></a>调用运行时类的完整结构</h4><p>使用反射可以取得：</p>
<ol>
<li><p>实现的全部接口： <code>public Class&lt;?&gt;[] getInterfaces()</code> 确定此对象所表示的类或接口实现的接口。</p>
</li>
<li><p>所继承的父类： <code>public Class&lt;? Super T&gt; getSuperclass()</code> 返回表示此 <code>Class</code> 所表示的实体（类、接口、基本类型）的父类的 <code>Class</code>。</p>
</li>
<li><p>全部的构造器：</p>
<p><code>public Constructor&lt;T&gt;[] getConstructors()</code></p>
<p>返回此 <code>Class</code> 对象所表示的类的所有 <code>public</code> 构造方法。</p>
<p><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code></p>
<p>返回此Class对象表示的类声明的所有构造方法。</p>
<p>在Constructor类中:</p>
<ul>
<li>取得修饰符：<code>public int getModifiers();</code></li>
<li>取得方法名称： <code>public String getName();</code></li>
<li>取得参数的类型： <code>public Class&lt;?&gt; getParameterTypes();</code></li>
</ul>
</li>
<li><p>全部的方法：</p>
<p><code>public Method[] getDeclaredMethods()</code></p>
<p>返回此Class对象所表示的类或接口的全部方法</p>
<p><code>public Method[] getMethods()</code></p>
<p>返回此 <code>Class</code> 对象所表示的类或接口的 <code>public</code> 的方法</p>
<p><code>Method</code> 类中：</p>
<ul>
<li><code>public Class&lt;?&gt; getReturnType()</code>：取得全部的返回值</li>
<li><code>public Class&lt;?&gt;[] getParameterTypes()</code>：取得全部的参数</li>
<li><code>public int getModifiers()</code>：取得修饰符</li>
<li><code>public Class&lt;?&gt; [] getEXceptionTypes()</code>：取得异常信息</li>
</ul>
</li>
<li><p>全部的 <code>Field</code>:</p>
<p><code>public Field[] getFields()</code></p>
<p>返回此 <code>Class</code> 对象所表示的类或接口的 <code>public</code> 的 <code>Field</code>。</p>
<p><code>public Field[] getDeclaredFields()</code></p>
<p>返回此 <code>Class</code> 对象所表示的类或接口的全部 <code>Field</code></p>
<p><code>Field</code> 方法中</p>
<ul>
<li><code>public int getModifiers()</code>：以整数形式返回此 <code>Field</code> 的修饰符</li>
<li><code>public Class&lt;?&gt; getType()</code>：得到 <code>Field</code> 的属性类型</li>
<li><code>public String getName()</code>：返回 <code>Field</code> 的名称。</li>
</ul>
</li>
<li><p><code>Annotation</code> 相关</p>
<p><code>get Annotation(Class&lt;T&gt; annotationClass)</code></p>
<p><code>getDeclaredAnnotations()</code></p>
</li>
<li><p>泛型相关</p>
<p>获取父类泛型类型：<code>Type getGenericSuperclass()</code></p>
<p>泛型类型：<code>ParameterizedType</code></p>
<p>获取实际的泛型类型参数数组：<code>getActualTypeArguments()</code></p>
</li>
<li><p>类所在的包 <code>Package getPackage()</code></p>
</li>
</ol>
<p>例如：</p>
<p><strong>获取属性 Fieled</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiledTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//获取属性结构</span></span><br><span class="line">        <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限修饰符  数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifiers)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">            System.out.print(fName);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取方法 Method</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getMethods():获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             methods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Xxxx</span></span><br><span class="line"><span class="comment">    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//1.获取方法声明的注解</span></span><br><span class="line">            Annotation[] annos = m.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a :</span><br><span class="line">                 annos) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(m.getModifiers())+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.返回值类型</span></span><br><span class="line">            System.out.print(m.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.方法名</span></span><br><span class="line">            System.out.print(m.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.形参列表</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == parameterTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.抛出的异常</span></span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==exceptionTypes.length -<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取其他结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">             constructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所有的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">             declaredConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="built_in">super</span> Person&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        System.out.println(superclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        System.out.println(genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">//获取泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">        System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类所在的包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">        System.out.println(pack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类声明的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">            System.out.println(annos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h4><p>调用指定的属性</p>
<p>在反射机制中，可以直接通过 <code>Field</code> 类操作类中的属性，通过 <code>Field</code> 类提供的 <code>set()</code> 和<code>get()</code> 方法就可以完成设置和取得属性内容的操作</p>
<ul>
<li><p><code>public Field getField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>public</code> 的 <code>Field</code></p>
</li>
<li><p><code>public Field getDeclaredField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>Field</code></p>
<p>在 <code>Field</code> 中：</p>
</li>
<li><p><code>public Object get(object obj)</code> 取得指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容</p>
</li>
<li><p><code>public void set(Object obj,Object value)</code> 设置指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用指定的方法（常用）</p>
<p>通过反射，调用类中的方法，通过 <code>Method</code> 类完成。步骤:</p>
<ol>
<li>通过 <code>Class</code> 类的 <code>getMethod(String name,Class… parameterTypes)</code> 方法取得一个 <code>Method</code> 对象，并设置此方法操作时所需要的参数类型</li>
<li>之后使用 <code>Object invoke(Object obj， Object[] args)</code> 进行调用，并向方法中传递要设置的 <code>obj</code> 对象的参数信息</li>
</ol>
<p><strong>Object invoke(object obj,Object… args)方法：</strong></p>
<ol>
<li><code>Object</code> 对应原方法的返回值，若原方法无返回值，此时返回 <code>null</code></li>
<li>若原方法若为静态方法，此时形参 <code>Object obj</code> 可为 <code>null</code></li>
<li>若原方法形参列表为空，则 <code>Object[] args</code> 为 <code>null</code></li>
<li>若原方法声明为 <code>private</code>，则需要在调用此 <code>invoke()</code> 方法前，显式调用方法对象的 <code>setAccessible(true)</code> 方法，将可访问 <code>private</code> 的方法</li>
</ol>
<p><strong>setAccessible方法的使用：</strong></p>
<ul>
<li><code>Method</code> 和 <code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法</li>
<li><code>setAccessible</code> 是启动和禁用访问安全检查的开关</li>
<li>参数值为 <code>true</code> 则指示反射的对象在使用时应该取消 Java 语言访问检査</li>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true. 使得原本无法访问的私有成员也可以访问</li>
<li>参数值为 <code>false</code> 则指示反射的对象应该实施 Java 语言访问检査</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(person, <span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用指定的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的构造器</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理设计模式的原理:使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上</p>
<p>静态代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike 生产衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;<span class="comment">//用被代理类对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factory.produceCloth();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">nike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        <span class="type">ProxyClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态代理的缺点：</span></span><br><span class="line"><span class="comment">//1.代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</span></span><br><span class="line"><span class="comment">//2.每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理</span></span><br></pre></td></tr></table></figure>
<p>动态代理的特点：动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象</p>
<p>相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法</p>
<p>动态代理的实现：</p>
<p>需要解决的两个主要问题：</p>
<p>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象（通过 <code>Proxy.newProxyInstance()</code> 实现）</p>
<p>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法（通过 <code>InvocationHandler</code> 接口的实现类及其方法 <code>invoke()</code> )</p>
<p>动态代理相关的API：</p>
<p>Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。提供用于创建动态代理类和动态代理对象的静态方法</p>
<ul>
<li><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;...interface)</code> 创建一个动态代理类所对应的  <code>Class</code> 对象</li>
<li><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;...interface, InvocationHandler h)</code> 直接创建一个动态代理对象</li>
</ul>
<p>动态代理实现步骤：</p>
<ol>
<li>创建一个实现接口 <code>InvocationHandler</code> 的类，它必须实现invoke方法，以完成代理的具体操作。</li>
<li>创建被代理类以及接口</li>
<li>通过Proxy的静态方法 <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;...interface, InvocationHandler h)</code> 创建一个接口代理</li>
<li>通过代理类的实例调用被代理类的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like eat &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建继承了InvocationHandler接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHanlder</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">MyInvocationHanlder</span> <span class="variable">hanlder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHanlder</span>();</span><br><span class="line">        hanlder.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),hanlder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;火锅&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="动态代理与AOP"><a href="#动态代理与AOP" class="headerlink" title="动态代理与AOP"></a>动态代理与AOP</h5><ul>
<li>使用 <code>Proxy</code> 生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理</li>
<li>这种动态代理在 <code>AOP</code> 中被称为 <code>AOP</code> 代理，<code>AOP</code> 代理可代替目标对象，<code>AOP</code> 代理包含了目标对象的全部方法。但 <code>AOP</code> 代理中的方法与目标对象的方法存在差异</li>
<li><code>AOP</code> 代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa13edb6c344c8dbf188e34ca036320~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuntingDog</span> <span class="keyword">implements</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只猎狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我跑的很快&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法一=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法二=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler1</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">//需要被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">DogUtils</span> <span class="variable">dogUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogUtils</span>();</span><br><span class="line">        <span class="comment">//执行DogUtils对象中的method1</span></span><br><span class="line">        dogUtils.method1();</span><br><span class="line">        <span class="comment">//通过obj对象来调用执行method方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//执行DogUtils对象中的method2</span></span><br><span class="line">        dogUtils.method2();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProxyFactory1</span> &#123;</span><br><span class="line">    <span class="comment">//为target生成动态代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个MyInvocationHandler对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler1</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler1</span>();</span><br><span class="line">        <span class="comment">//为MyInvocationHandler设置target对象</span></span><br><span class="line">        handler.SetTarget(target);</span><br><span class="line">        <span class="comment">//创建返回一个动态代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuntingDog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) MyProxyFactory1.getProxy(target);</span><br><span class="line">        dog.info();</span><br><span class="line">        dog.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合与数组"><a href="#集合与数组" class="headerlink" title="集合与数组"></a>集合与数组</h3><p>集合与数组存储数据概述：集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt，.jpg，.avi，数据库中)</p>
<p>数组存储的特点：一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。比如：<code>String[] arr</code>、<code>int[] arr1</code>、<code>Object[] arr2</code></p>
<p>数组存储的弊端：</p>
<ol>
<li>一旦初始化以后，其长度就不可修改。</li>
<li>数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足</li>
</ol>
<p>集合存储的优点：解决数组存储数据方面的弊端</p>
<p>集合的分类：</p>
<p>Java集合可分为Collection和Map两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对“的集合</li>
</ul>
<p>集合的框架结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存<span class="literal">null</span>值</span><br><span class="line">           		|----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br></pre></td></tr></table></figure>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="单列集合框架结构"><a href="#单列集合框架结构" class="headerlink" title="单列集合框架结构"></a>单列集合框架结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存null值</span><br><span class="line">           		|----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a12d4e0b0d4d46dba04719c62c10359c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<h4 id="Collection接口常用方法："><a href="#Collection接口常用方法：" class="headerlink" title="Collection接口常用方法："></a>Collection接口常用方法：</h4><ol>
<li>添加<ul>
<li><code>add(Object obj)</code></li>
<li><code>addAll(Collection coll)</code></li>
</ul>
</li>
<li>获取有效元素个数<ul>
<li><code>int size()</code></li>
</ul>
</li>
<li>清空集合<ul>
<li><code>void clear()</code></li>
</ul>
</li>
<li>是否为空集合<ul>
<li><code>boolean isEmpty()</code></li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li><code>boolean contains(Object obj)</code>:是通过元素的equals方法来判断是否是同一个对象</li>
<li><code>boolean containsAll(Collection c)</code>:也是调用元素的equals方法来比较的。用两个两个集合的元素逐一比较</li>
</ul>
</li>
<li>删除<ul>
<li><code>boolean remove(Object obj)</code>:通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li><code>boolean removeAll(Collection coll)</code>:取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li><code>boolean retainAll(Collection c)</code>:把交集的结果存在当前的集合中，不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li><code>boolean equals(Object obj)</code></li>
</ul>
</li>
<li>转换成对象数组<ul>
<li><code>Object [] toArray()</code></li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li><code>hashCode()</code>复制代码</li>
</ul>
</li>
<li>遍历<ul>
<li><code>iterator()</code>:返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//1.add(Object e):将元素添加到集合中</span></span><br><span class="line">    collection.add(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">123</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">//2.size():获取添加元素的个数</span></span><br><span class="line">    System.out.println(collection.size());<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//3.addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    collection1.add(<span class="number">213</span>);</span><br><span class="line">    collection.addAll(collection1);</span><br><span class="line">    System.out.println(collection.size());<span class="comment">//9</span></span><br><span class="line">    <span class="comment">//调用collection1中的toString()方法输出</span></span><br><span class="line">    System.out.println(collection);<span class="comment">//[ZZ, AA, BB, 123, Tue Apr 28 09:22:34 CST 2020, 213, 213]</span></span><br><span class="line">    <span class="comment">//4.clear():清空集合元素</span></span><br><span class="line">    collection1.clear();</span><br><span class="line">    System.out.println(collection1.size());<span class="comment">//0</span></span><br><span class="line">    System.out.println(collection1);<span class="comment">//[]</span></span><br><span class="line">    <span class="comment">//5.isEmpty():判断当前集合是否为空</span></span><br><span class="line">    System.out.println(collection1.isEmpty());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//6.contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">//判断时需要调用obj对象所在类的equals()方法</span></span><br><span class="line">    System.out.println(coll.contains(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>)));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">23</span>)));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//7.containsAll(Collection coll1):判断形参coll1中的元素是否都存在当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">4566</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">//flase</span></span><br><span class="line">    <span class="comment">//8.remove(Object obj):从当前集合中移除obj元素</span></span><br><span class="line">    coll.remove(<span class="number">123</span>);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[456, Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;, false]</span></span><br><span class="line">    <span class="comment">//9.removeAll(Collection coll1):差集：从当前集合中和coll1中所有的元素</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>, <span class="literal">false</span>);</span><br><span class="line">    coll.removeAll(coll2);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//10.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">345</span>, <span class="number">456</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> coll.retainAll(coll1);</span><br><span class="line">    System.out.println(b);<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll);<span class="comment">//[123, 456]</span></span><br><span class="line">    <span class="comment">//11.equals(Object obj):返回true需要当前集合和形参集合的元素相同</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll2.add(<span class="number">123</span>);</span><br><span class="line">    coll2.add(<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.equals(coll2));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//12.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());<span class="comment">//5230</span></span><br><span class="line">    <span class="comment">//13.集合---&gt;数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (Object obj : array) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//14.数组---&gt;集合:调用Arrays类的静态方法asList()</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">345</span>&#125;);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(strings);<span class="comment">//[AA, BB, CC]</span></span><br><span class="line">    <span class="comment">//15.iteratoriterator():返回Iterator接口的实例，用于遍历集合元素。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Collection集合与数组间的转换"><a href="#Collection集合与数组间的转换" class="headerlink" title="Collection集合与数组间的转换"></a>Collection集合与数组间的转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合 ---&gt;数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>使用 Collection 集合存储对象，要求对象所属的类满足：</p>
<p>向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 <code>equals()</code></p>
<h3 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h3><p>遍历Collection的两种方式：</p>
<ol>
<li><p>使用迭代器Iterator</p>
<p><strong>java.utils包下定义的迭代器接口：Iterator</strong></p>
<p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生</p>
<p>Collection接口继承了<code>java.lang.Iterator</code>接口，该接口有<code>terator()</code>方法</p>
<p>集合对象每次调用<code>terator()</code>方法都会得到一个全新的迭代器对象</p>
<p>获取实例：<code>coll.iterator()</code> 返回一个迭代器实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2459e96817c4abe98f9e25ac8d70c45~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<p>iterator中remove()方法的使用：</p>
<ul>
<li>测试Iterator中的 <code>remove()</code></li>
<li>如果还未调用 <code>next()</code> 或在上一次调用 <code>next()</code> 方法之后已经调用了 <code>remove()</code> 方法，再调用 remove 都会报 <code>IllegalStateException</code></li>
<li>内部定义了 <code>remove()</code>,可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用<code>remove()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="string">&quot;Tom&quot;</span></span><br><span class="line">            );</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//            iterator.remove();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//                iterator.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针重新放到头部，遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>for-each循环（或增强for循环）</p>
<p>遍历操作不需要获取Collection的长度，无需使用索引访问元素</p>
<p>遍历集合的地层调用Iterator完成操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    <span class="comment">//内部仍然调用了迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Collection子接口：List"><a href="#Collection子接口：List" class="headerlink" title="Collection子接口：List"></a>Collection子接口：List</h3><p>存储数据的特点：</p>
<p>存储序有序的、可重复的数据</p>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK AP中List接口的实现类常用的有：ArrayList、LinkedList和 Vector.</li>
</ul>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><p>List除了从 Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。</p>
<ul>
<li><code>void add(int index, Object ele)</code>:在index位置插入ele元素</li>
<li><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</li>
<li><code>Object get(int index)</code>:获取指定index位置的元素</li>
<li><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</li>
<li><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</li>
<li><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</li>
<li><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</li>
<li><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</li>
</ul>
<p>总结：</p>
<ul>
<li>增：<code>add(Object obj)</code></li>
<li>删：<code>remove(int index)</code> / <code>remove(Object obj)</code></li>
<li>改：<code>set(int index, Object ele)</code></li>
<li>查：<code>get(int index)</code></li>
<li>插：<code>add(int index, Object ele)</code></li>
<li>长度：<code>size()</code></li>
<li>遍历： ① Iterator迭代器方式 ② foreach（增强for循环） ③ 普通的循环</li>
</ul>
<h4 id="常用实现类："><a href="#常用实现类：" class="headerlink" title="常用实现类："></a>常用实现类：</h4><ul>
<li><p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</p>
<p>ArrayList是List接口的典型实现类、主要实现类</p>
<p>本质上，ArrayList是对象引用的一个”变长”数组</p>
<p>Array Listi的JDK 1.8之前与之后的实现区别？</p>
<ul>
<li>JDK 1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li>
<li>JDK 1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</li>
</ul>
<p><code>Arrays.asList(...)</code>方法返回的List集合，既不是 ArrayList实例，也不是Vector实例。<code>Arrays.asList(...)</code>返回值是一个固定长度的List集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">345</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//iterator()遍历ArrayList集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</p>
<ul>
<li>对与对于频繁的插入和删除元素操作，建议使用LinkedList类，效率更高</li>
<li>新增方法：<ul>
<li><code>void addFirst(Object obj)</code></li>
<li><code>void addLast(Object obj)</code></li>
<li><code>Object getFirst()</code></li>
<li><code>Object getlast)()</code></li>
<li><code>Object removeFirst()</code></li>
<li><code>Object removeLast()</code></li>
</ul>
</li>
<li>Linkedlist：双向链表，内部没有声明数组，而是定义了Node类型的frst和last，用于记录首末元素。同时，定义内部类Node，作为 Linkedlist中保存数据的基本结构。Node除了保存数据，还定义了两个变量：<ul>
<li>prev：变量记录前一个元素的位置</li>
<li>next：变量记录下一个元素的位置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    linkedList.add(<span class="number">123</span>);</span><br><span class="line">    linkedList.add(<span class="number">345</span>);</span><br><span class="line">    linkedList.add(<span class="number">2342</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;DDD&quot;</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</p>
</li>
<li><p>ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？ Vector和 ArrayList的最大区别？</p>
<ul>
<li><p>相同：都实现了List接口，存储数据的特点相同（存储序有序的、可重复的数据）</p>
</li>
<li><p>ArrayList和 Linkedlist的异同：</p>
<p>二者都线程不安全，相比线程安全的 Vector，ArrayList执行效率高。 此外，ArrayList是实现了基于动态数组的数据结构，Linkedlist基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于Linkedlist，因为Linkedlist要移动指针。对于新增和删除操作add（特指插入）和 remove，Linkedlist比较占优势，因为 ArrayList要移动数据。</p>
</li>
<li><p>ArrayList和 Vector的区别：</p>
<p>Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比 ArrayList要大，访问要慢。正常情况下，大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack</p>
</li>
</ul>
</li>
</ul>
<p>源码分析：</p>
<p>ArrayList：JDK 7.0情况下，默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中，建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code>，JDK 8.0，后续的添加和扩容操作与JDK 7.0 无异</p>
<p>JDK 7.0中的ArrayList的对象的创建类似于单例的饿汉式，而JDK 8.0中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存</p>
<p>Linkedlist</p>
<p>Vector：Vector是一个古老的集合，JDK 1.0就有了。大多数操作与ArrayList相同，区别在于Vector是线程安全的</p>
<p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免选择使用。</p>
<p>JDK 7.0和JDK 8.0中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p>
<p>在扩容方面，默认扩容为原来的数组长度的2倍</p>
<h3 id="Collection子接口：Set"><a href="#Collection子接口：Set" class="headerlink" title="Collection子接口：Set"></a>Collection子接口：Set</h3><p>Set接口是Collection的子接口，set接口没有提供额外的方法</p>
<p>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。（多用于过滤操作，去掉重复数据）</p>
<p>Set判断两个对象是否相同不是使用==运算符，而是根据equals()方法</p>
<p>存储的数据特点：用于存放无序的、不可重复的元素</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User equals()....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">//return name.hashCode() + age;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><ul>
<li><p>HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p>
<p>Hashset是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</p>
<p>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p>
<p>HashSet具有以下特点：</p>
<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是nul</li>
</ul>
<p>HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等。</p>
<p>对于存放在Set容器中的对象，对应的类一定要重写equals()和<code>hashCode(Object obj)</code>方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”</p>
</li>
<li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p>
<p>LinkedhashSet是HashSet的子类</p>
<p>LinkedhashSet根据元素的hashCode值来决定元素的存储位置但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p>
<p>LinkedhashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p>
<p>LinkedhashSet不允许集合元素重复</p>
</li>
<li><p>TreeSet：可以按照添加对象的指定属性，进行排序</p>
<p>Treeset是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</p>
<p>TreeSet底层使用红黑树结构存储数据</p>
<p>新增的方法如下：（了解）</p>
<ul>
<li><code>Comparator comparator()</code></li>
<li><code>Object first()</code></li>
<li><code>Object last()</code></li>
<li><code>Object lower(object e)</code></li>
<li><code>Object higher(object e)</code></li>
<li><code>SortedSet subSet(fromElement， toElement)</code></li>
<li><code>SortedSet headSet(toElement)</code></li>
<li><code>SortedSet tailSet(fromElement)</code></li>
</ul>
<p>TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序</p>
</li>
</ul>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>自然排序中，比较两个对象是否相同的标准为：<code>compareTo()</code> 返回0.不再是 <code>equals()</code></p>
<p>定制排序中，比较两个对象是否相同的标准为：<code>compare()</code> 返回0.不再是 <code>equals()</code></p>
<ul>
<li><p>自然排序</p>
<p>TreeSet会调用集合元素的 <code>compareTo(object obj)</code> 方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列</p>
<p>如果试图把一个对象添加到Treeset时，则该对象的类必须实现Comparable接口。</p>
<ul>
<li>实现Comparable的类必须实现 <code>compareTo(Object obj)</code> 方法，两个对象即通过<code>compareTo(Object obj)</code> 方法的返回值来比较大小</li>
</ul>
<p>Comparable的典型实现:</p>
<ul>
<li>BigDecimal、BigInteger以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li>
<li>Character：按字符的unic！ode值来进行比较</li>
<li>Boolean：true对应的包装类实例大于fase对应的包装类实例</li>
<li>String：按字符串中字符的unicode值进行比较</li>
<li>Date、Time：后边的时间、日期比前面的时间、日期大</li>
</ul>
<p>向TreeSet中添加元素时，只有第一个元素无须比较 <code>compareTo()</code> 方法，后面添加的所有元素都会调用 <code>compareTo()</code> 方法进行比较。</p>
<p>因为只有相同类的两个实例才会比较大小，所以向 TreeSet中添加的应该是同一个类的对象。 对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 <code>compareTo(Object obj)</code> 方法比较返回值。</p>
<p>当需要把一个对象放入TreeSet中，重写该对象对应的equals()方法时，应保证该方法与 <code>compareTo(Object obj)</code> 方法有一致的结果：如果两个对象通过equals()方法比较返回true，则通过 <code>compareTo(object ob)</code> 方法比较应返回0</p>
</li>
</ul>
<ul>
<li><p>定制排序</p>
<p>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现 Comparable接口，或不希望按照升序（默认情况）的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过 Comparator接口来实现。需要重写 compare(T o1，T o2)方法。</p>
<p>利用 <code>int compare(T o1，T o2)</code> 方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p>
<p>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</p>
<p>此时，仍然只能向Treeset中添加类型相同的对象。否则发生 <code>ClassCastException</code> 异常</p>
<p>使用定制排序判断两个元素相等的标准是：通过 Comparator比较两个元素返回了0</p>
</li>
</ul>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</p>
<p>Map中的key和value都可以是任何引用类型的数据</p>
<p>Map中的key用set来存放，不允许重复，即同一个Map对象所对应的类，须重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</p>
<p>常用 String类作为Map的“键”</p>
<p>key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value</p>
<p>Map接口的常用实现类:HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类</p>
<p>Map中的key:无序的、不可重复的，使用Set存储所的key —-&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)</p>
<p>Map中的value:无序的、可重复的，使用Collection存储所的value —-&gt;value所在的类要重写equals()</p>
<p>一个键值对：key-value构成了一个Entry对象。</p>
<p>Map中的entry:无序的、不可重复的，使用Set存储所的entry</p>
<h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap的底层： 数组+链表  （JDK <span class="number">7.0</span>及之前)</span><br><span class="line">               数组+链表+红黑树 （JDK <span class="number">8.0</span>以后)</span><br></pre></td></tr></table></figure>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>HashMap是Map接口使用频率最高的实现类。</p>
<p>允许使用null键和null值，与 HashSet一样，不保证映射的顺序。</p>
<p>所有的key构成的集合是set：无序的、不可重复的。所以，key所在的类要重写equals()和 hashCode()</p>
<p>所有的value构成的集合是Collection：无序的、可以重复的。所以，value所在的类要重写:equals()</p>
<p>一个key-value构成一个entry</p>
<p>所有的entry构成的集合是Set：无序的、不可重复的</p>
<p>HashMap判断两个key相等的标准是：两个key通过 <code>equals()</code> 方法返回true，hashCode值也相等。</p>
<p>HashMap判断两个value相等的标准是：两个value通过 <code>equals()</code> 方法返回true</p>
<p><strong>底层实现原理：</strong></p>
<ul>
<li><p>JDK7</p>
<p>对象创建和添加过程：</p>
<p><code>HashMap map = new HashMap()；</code></p>
<p>在实例化以后，底层创建了长度是16的一维数组 <code>Entry[] table</code></p>
<p><code>map.put(key1,value1)</code>:</p>
<ul>
<li>首先，调用key1所在类的 <code>hashCode()</code> 计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</li>
<li>如果此位置上的数据为空，此时的key1-value1添加成功。 ——情况1</li>
<li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：<ul>
<li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。——情况2</li>
<li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：<ul>
<li>如果 <code>equals()</code> 返回false:此时key1-value1添加成功。——情况3</li>
<li>如果 <code>equals()</code> 返回true:使用value1替换value2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</p>
</blockquote>
<p>当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>扩容：</p>
<p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对 HashMap的数组进行扩容，而在HashMap数组扩容之后，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize</p>
<p>扩容时机：</p>
<p>当HashMap中的元素个数超过数组大小（数组总大小 length，不是数组中个数）<em> loadFactor时，就会进行数组扩容，loadFactor的默认值(<code>DEFAULT_LOAD_ FACTOR</code>)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(<code>DEFAULT INITIAL CAPACITY</code>)为16，那么当 HashMap中元素个数超过16 </em> 0.75=12（这个值就是代码中的 threshold值，也叫做临界值）的时候，就把数组的大小扩展为2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能</p>
</li>
</ul>
<ul>
<li><p>JDK8</p>
<p>添加元素的过程：</p>
<p>当实例化一个HashMap时，会初始化 initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为 initialCapacity的Node数组，这个长度在哈希表中被称为容量（Capacity），在这个数组中可以存放元素的位置我们称之为“桶”（ bucket），每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
<p>每个 bucket中存储一个元素，即一个Node对象，但每一个Noe对象可以带个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个 TreeNode对象，每一个Tree node对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
<p>扩容机制:</p>
<ul>
<li>当HashMapl中的其中一个链的对象个数没有达到8个和JDK 7.0以前的扩容方式一样。</li>
<li>当HashMapl中的其中一个链的对象个数如果达到了8个，此时如果 capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成 Tree Node类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</li>
</ul>
<p>变化：</p>
<ol>
<li><code>new HashMap()</code>:底层没有创建一个长度为16的数组</li>
<li>JDK 8.0底层的数组是：<code>Node[]</code>,而非 <code>Entry[]</code></li>
<li>首次调用put()方法时，底层创建长度为16的数组</li>
<li>JDK 7.0底层结构只有：数组+链表。JDK 8.0中底层结构：数组+链表+红黑树。<ul>
<li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，<span class="number">16</span></span><br><span class="line">DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：<span class="number">0.75</span></span><br><span class="line">threshold：扩容的临界值，= 容量*填充因子：<span class="number">16</span> * <span class="number">0.75</span> =&gt; <span class="number">12</span></span><br><span class="line">TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:JDK <span class="number">8.0</span>引入</span><br><span class="line">MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:<span class="number">64</span></span><br></pre></td></tr></table></figure>
<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p>LinkedHashMap继承于HashMap.</p>
<p>区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.</p>
<p>与Linkedhash Set类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-value对的插入顺序一致</p>
<p><strong>底层实现原理：</strong></p>
<p>LinkedHashMap继承于HashMap，区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node，与Linkedhash Set类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-value对的插入顺序一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap中内部类Node源码：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedHashM中内部类Entry源码：</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>TreeMap存储Key-Value对时，需要根据key-value对进行排序。TreeMap可以保证所有的 Key-Value对处于有序状态。</p>
<p>TreeSet底层使用红黑树结构存储数据</p>
<p>TreeMap的Key的排序:</p>
<ul>
<li>自然排序： TreeMap的所有的Key必须实现Comparable接口，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastEXception()</li>
<li>定制排序：创建 TreeMap时，传入一个 Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不需要Map的Key实现Comparable接口</li>
</ul>
<p>TreeMap判断两个key相等的标准：两个key通过 compareTo()方法或者compare()方法返回0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自然排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>, <span class="number">56</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Davie&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1, <span class="number">98</span>);</span><br><span class="line">    map.put(u2, <span class="number">16</span>);</span><br><span class="line">    map.put(u3, <span class="number">92</span>);</span><br><span class="line">    map.put(u4, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序：按照年龄大小排</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User) o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User) o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(), u2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入数据类型错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>, <span class="number">56</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Davie&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1, <span class="number">98</span>);</span><br><span class="line">    map.put(u2, <span class="number">16</span>);</span><br><span class="line">    map.put(u3, <span class="number">92</span>);</span><br><span class="line">    map.put(u4, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>Hashtable是个古老的Map实现类，JDK1.0就提供了。不同于 HashMap，Hashtable是线程安全的.</p>
<p>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用</p>
<p>与HashMap.不同，Hashtable不允许使用null作为key和value.</p>
<p>与HashMap一样，Hashtable也不能保证其中Key-value对的顺序.</p>
<p>Hashtable判断两个key相等、两个value相等的标准，与HashMap-致</p>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><p>Properties类是Hashtable的子类，该对象用于处理属性文件</p>
<p>由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是字符串类型</p>
<p>存取数据时，建议使用 <code>setProperty(String key,String value)</code> 方法和 <code>getProperty(String key)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="添加、删除、修改操作"><a href="#添加、删除、修改操作" class="headerlink" title="添加、删除、修改操作"></a>添加、删除、修改操作</h5><ul>
<li><code>Object put(Object key,Object value)</code>：将指定key-value添加到(或修改)当前map对象中</li>
<li><code>void putAll(Map m)</code>:将m中的所有key-value对存放到当前map中</li>
<li><code>Object remove(Object key)</code>：移除指定key的key-value对，并返回value</li>
<li><code>void clear()</code>：清空当前map中的所有数据</li>
</ul>
<h5 id="元素查询的操作"><a href="#元素查询的操作" class="headerlink" title="元素查询的操作"></a>元素查询的操作</h5><ul>
<li><code>Object get(Object key)</code>：获取指定key对应的value</li>
<li><code>boolean containsKey(Object key)</code>：是否包含指定的key</li>
<li><code>boolean containsValue(Object value)</code>：是否包含指定的value</li>
<li><code>int size()</code>：返回map中key-value对的个数</li>
<li><code>boolean isEmpty()</code>：判断当前map是否为空</li>
<li><code>boolean equals(Object obj)</code>：判断当前map和参数对象obj是否相等</li>
</ul>
<h5 id="元视图操作的方法"><a href="#元视图操作的方法" class="headerlink" title="元视图操作的方法"></a>元视图操作的方法</h5><ul>
<li><code>Set keySet()</code>：返回所有key构成的Set集合</li>
<li><code>Collection values()</code>：返回所有value构成的Collection集合</li>
<li><code>Set entrySet()</code>：返回所有key-value对构成的Set集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">添加：put(Object key,Object value)</span><br><span class="line">删除：remove(Object key)</span><br><span class="line">修改：put(Object key,Object value)</span><br><span class="line">查询：get(Object key)</span><br><span class="line">长度：size()</span><br><span class="line">遍历：keySet() / values() / entrySet()</span><br></pre></td></tr></table></figure>
<p><strong>面试题</strong></p>
<ol>
<li>HashMap的底层实现原理？</li>
<li>HashMap 和 Hashtable的异同？</li>
<li>CurrentHashMap 与 Hashtable的异同？</li>
<li>负载因子值的大小，对HashMap的影响？<ul>
<li>负载因子的大小决定了HashMap的数据密度。</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成査询或插入时的比较次数增多，性能会下降</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间</li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数</li>
</ul>
</li>
</ol>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排序</li>
<li><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List，int， int)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<h5 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h5><ul>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection，Comparator)</code></li>
<li><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所旧值</li>
</ul>
<h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>Collections 类中提供了多个 <code>synchronizedXxx()</code> 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
<h2 id="泛型和File"><a href="#泛型和File" class="headerlink" title="泛型和File"></a>泛型和File</h2><p>泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返 回值及参数类型</p>
<p>从JDK 5.0以后，Java引入了“参数化类型(Parameterized type)”的概念，允许我们在创建集合时再指定集合元素的类型，正如:List，这表明该List只能保存字符串类型的对象。</p>
<p>JDK 5.0改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参</p>
<p>目的：</p>
<ol>
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别</li>
</ol>
<p>Java泛型可以保证如果程序在编译时没有发岀警告，运行时就不会产生 <code>ClassCastException</code> 异常。同时，代码更加简洁、健壮。</p>
<h3 id="在集合中的应用"><a href="#在集合中的应用" class="headerlink" title="在集合中的应用"></a>在集合中的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在集合中使用泛型，以ArrayList为例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;FFF&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">	<span class="comment">//遍历方式一：</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    <span class="comment">//便利方式二：</span></span><br><span class="line">    <span class="keyword">for</span> (String str:</span><br><span class="line">         list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//在集合中使用泛型的情况：以HashMap为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//jdk7新特性：类型推断</span></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">26</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jarry&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Bruce&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Davie&quot;</span>,<span class="number">60</span>);</span><br><span class="line">    <span class="comment">//嵌套循环</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h3><p>声明：</p>
<ul>
<li>interface <code>List&lt;T&gt;</code> 和 <code>class GenTest&lt;K,V&gt;</code> 其中，T，K，V，不代表值，而是表示类型。这里使用任意字母都可以。</li>
<li>常用T表示，是Type的缩写。</li>
</ul>
<p>实例化：</p>
<p>一定要在类名后面指定类型参数的值（类型）</p>
<ul>
<li>T只能是类，不能用基本数据类型填充。但可以使用包装类填充</li>
<li>把一个集合中的内容限制为一个特定的数据类型，这就是 generics背后的核心思想</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前</span></span><br><span class="line"><span class="type">Comparable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(c.comparaTo(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//JDK 5.0以后</span></span><br><span class="line">Comparable &lt;Date&gt; c = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(c.comparaTo(<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：使用泛型的主要优点在于能够在编译时而不是在运行时检测错误</p>
</blockquote>
<p>注意点</p>
<ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内</p>
</li>
<li><p>泛型类的构造器如下： <code>public GenericClass()&#123;&#125;</code></p>
</li>
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致</p>
</li>
<li><p>泛型不同的引用不能相互赋值</p>
<blockquote>
<p>尽管在编译时 ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</p>
</blockquote>
</li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object</p>
</li>
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象</p>
</li>
<li><p>JDK 7.0，泛型的简化操作： <code>ArrayList&lt;Fruit&gt;first= new ArrayList&lt;&gt;();</code>（类型推断）</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换</p>
</li>
<li><p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型</p>
</li>
<li><p>异常类不能是泛型的</p>
</li>
<li><p>不能使用 <code>new E[]</code>。但是可以：<code>E[] elements= (E[])new Object[capacity];</code></p>
<p>ArrayList源码中声明：<code>Object[] elementData</code>，而非泛型参数类型数组</p>
</li>
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-   子类不保留父类的泛型：按需实现</span><br><span class="line">    -   没有类型---擦除</span><br><span class="line">    -   具体类型</span><br><span class="line">-   子类保留父类的泛型：泛型子类</span><br><span class="line">    -   全部保留</span><br><span class="line">    -   部分保留</span><br><span class="line">-   结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</span><br></pre></td></tr></table></figure>
<h4 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h4><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义泛型类Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> orderId;</span><br><span class="line">    <span class="comment">//使用T类型定义变量</span></span><br><span class="line">    <span class="keyword">private</span> T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用T类型定义构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName, <span class="type">int</span> orderId, T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个不是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个不是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个不是泛型方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    //静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //try-catch中不能是泛型的。</span></span><br><span class="line"><span class="comment">//    public void show()&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch (T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</span></span><br><span class="line">    <span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line">    <span class="comment">//泛型方法，可以声明为静态的。</span></span><br><span class="line">    <span class="comment">// 原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArryToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e :</span><br><span class="line">                list) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义泛型类Order的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">    <span class="comment">//要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setOrderT(<span class="number">123</span>);</span><br><span class="line">    System.out.println(order.getOrderT());</span><br><span class="line"></span><br><span class="line">    order.setOrderT(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(order.getOrderT());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">    Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;(<span class="string">&quot;Tom&quot;</span>, <span class="number">16</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">    order1.setOrderT(<span class="string">&quot;AA:BBB&quot;</span>);</span><br><span class="line">    System.out.println(order1.getOrderT());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//调用泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer [] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArryToList(arr);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h4><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义泛型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoInterface</span> &lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">DemoInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    demo.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h4><ul>
<li>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</li>
<li>泛型方法的格式： <code>[访问权限]&lt;泛型&gt;返回类型 方法名(泛型标识 参数名称])抛出的异常</code></li>
<li>泛型方法声明泛型时也可以指定上限</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</span></span><br><span class="line"><span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line"><span class="comment">//泛型方法，可以声明为静态的。</span></span><br><span class="line"><span class="comment">// 原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArryToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (E e :</span><br><span class="line">         list) &#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>泛型实际上就是标签，声明时不知道类型，再使用时指明</li>
<li>定义泛型结构，即：泛型类、接口、方法、构造器时贴上泛型的标签</li>
<li>用泛型定义类或借口是放到类名或接口名后面，定义泛型方法时在方法名前加上</li>
</ul>
<p>应用场景：</p>
<p><code>DAO.java</code>：定义了操作数据库中的表的通用操作。 ORM思想(数据库中的表和Java中的类对应)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span>&lt;T&gt; &#123;<span class="comment">//表的共性操作的DAO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index,T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询一条记录</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询多条记录</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getForList</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="comment">//举例：获取表中一共有多少条记录？获取最大的员工入职时间？</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; E <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CustomerDAO.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDAO</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Customer&gt;&#123;<span class="comment">//只能操作某一个表的DAO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StudentDAO.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDAO</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Student&gt; &#123;<span class="comment">//只能操作某一个表的DAO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在继承上的体现"><a href="#在继承上的体现" class="headerlink" title="在继承上的体现"></a>在继承上的体现</h3><p>类A是类B的父类，但是 <code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 二者不具备子父类关系，二者是并列关系。</p>
<p>补充：类A是类B的父类，<code>A&lt;G&gt;</code> 是 <code>B&lt;G&gt;</code> 的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        Date date = new Date();</span></span><br><span class="line">    <span class="comment">//        str = date;</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">//此时的list1和list2的类型不具子父类关系</span></span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        list1 = list2;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非String的数据。出错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    show(list1);</span><br><span class="line">    show1(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(List&lt;Object&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    AbstractList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list2 = list3;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><h4 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h4><ul>
<li>使用类型通配符：<code>?</code>比如：<code>List&lt;?&gt;</code>，<code>Map&lt;?,?&gt;</code>，<code>List&lt;?&gt;</code> 是 <code>List&lt;String&gt;</code>、<code>List&lt;Object&gt;</code> 等各种泛型 List 的父类。</li>
<li>读取 <code>List&lt;?&gt;</code> 的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object</li>
<li>写入list中的元素时，不可以。因为我们不知道c的元素类型，我们不能向其中添加对象。 除了添加null之外。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><p>将任意元素加入到其中不是类型安全的</p>
<p><code>Collection&lt;?&gt; c = new ArrayList&lt;String&gt;()</code></p>
<p><code>c.add(new Object());//编译时错误</code></p>
<p>因为我们不知道c的元素类型，我们不能向其中添加对象。add 方法有类型参数 E 作为集合的元素类型。我们传给add的任何参数都必须是一个已知类型的子类</p>
</li>
<li><p>唯一的例外的是 null，它是所有类型的成员</p>
</li>
<li><p>我们可以调用 <code>get()</code> 方法并使用其返回值。返回值是一个未知的类型，它总是一个Object</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    <span class="comment">//        print(list1);</span></span><br><span class="line">    <span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">    <span class="comment">//除了添加null之外。</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;DD&quot;);</span></span><br><span class="line">    <span class="comment">//        list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericTypeClass</span>&lt;?&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</span></span><br><span class="line">ArrayList&lt;&gt; list2 <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="有限制的通配符"><a href="#有限制的通配符" class="headerlink" title="有限制的通配符"></a>有限制的通配符</h4><ul>
<li><p><code>&lt;?&gt;</code>：允许所有泛型的引用调用</p>
</li>
<li><p>通配符指定上限</p>
<p>上限 <code>extends</code>：使用时指定的类型必须是继承某个类，或者实现某个接口，即 &lt;=</p>
</li>
<li><p>通配符指定下限</p>
<p>下限 <code>super</code>：使用时指定的类型不能小于操作的类，即 &gt;=</p>
</li>
<li><p>举例：</p>
<ul>
<li><p><code>&lt;?extends Number&gt;（无穷小， Number\]</code></p>
<p>只允许泛型为Number及Number子类的引用调用</p>
</li>
<li><p><code>&lt;?super Number&gt;\[Number，无穷大）</code></p>
<p>只允许泛型为Number及Number父类的引用调用</p>
</li>
<li><p><code>&lt;? extends Comparable&gt;</code></p>
<p>只允许泛型为实现 Comparable接口的实现类的引用调用</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">//        list1 = list5;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//        list2 = list3;</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据：</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">////编译不通过</span></span><br><span class="line">    <span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据：</span></span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</p>
<p>File类声明在 <code>java.io</code> 包下：文件和文件路径的抽象表示形式，与平台无关。</p>
<p>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</p>
<p>想要在 Java 程序中表示一个真实存在的文件或目录，那么必须有一个 File 对象，但是 Java程序中的一个 File 对象，可能没有一个真实存在的文件或目录。</p>
<p>File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”</p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><h5 id="常用构造器"><a href="#常用构造器" class="headerlink" title="常用构造器"></a>常用构造器</h5><ul>
<li><code>File(String filePath)</code></li>
<li><code>File(String parentPath,String childPath)</code></li>
<li><code>File(File parentFile,String childPath)</code></li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//构造器1</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\workspace_idea\\JavaSenic\\IO\\hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file1);</span><br><span class="line">    System.out.println(file2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\workspace_idea\\JavaSenior&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器3</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file3, <span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    System.out.println(file4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="路径分类"><a href="#路径分类" class="headerlink" title="路径分类"></a>路径分类</h5><ul>
<li>相对路径：相较于某个路径下，指明的路径。</li>
<li>绝对路径：包含盘符在内的文件或文件目录的路径。</li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li>IDEA中：<ul>
<li>如果使用JUnit中的单元测试方法测试，相对路径即为当前Module下。</li>
<li>如果使用main()测试，相对路径即为当前的Project下。</li>
</ul>
</li>
<li>Eclipse中：<ul>
<li>不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。</li>
</ul>
</li>
</ul>
<h5 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a>路径分隔符</h5><ul>
<li><p>windows和DOS系统默认使用 <code>\</code> 来表示</p>
</li>
<li><p>UNIX和URL使用 <code>/</code> 来表示</p>
</li>
<li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。</p>
</li>
<li><p>为了解决这个隐患，File类提供了一个常量： <code>public static final String separator</code>。根据操作系统，动态的提供分隔符。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//windows和DOS系统</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\io\\test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//UNIX和URL</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/io/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//java提供的常量</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:&quot;</span>+File.separator+<span class="string">&quot;io&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="File类的获取功能"><a href="#File类的获取功能" class="headerlink" title="File类的获取功能"></a>File类的获取功能</h5><ul>
<li><code>public String getAbsolutePath()</code>：获取绝对路径</li>
<li><code>public String getPath()</code>：获取路径</li>
<li><code>public String getName()</code> ：获取名称</li>
<li><code>public String getParent()</code>：获取上层文件目录路径。若无，返回 <code>null</code></li>
<li><code>public long length()</code> ：获取文件长度（即：字节数）。不能获取目录的长度。</li>
<li><code>public long lastModified()</code> ：获取最后一次的修改时间，毫秒值</li>
<li>如下的两个方法适用于文件目录：</li>
<li><code>public String[] list()</code> ：获取指定目录下的所有文件或者文件目录的名称数组</li>
<li><code>public File[] listFiles()</code> ：获取指定目录下的所有文件或者文件目录的File数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(file1.getAbsolutePath());</span><br><span class="line">    System.out.println(file1.getPath());</span><br><span class="line">    System.out.println(file1.getName());</span><br><span class="line">    System.out.println(file1.getParent());</span><br><span class="line">    System.out.println(file1.length());</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(file1.lastModified()));</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.println(file2.getAbsolutePath());</span><br><span class="line">    System.out.println(file2.getPath());</span><br><span class="line">    System.out.println(file2.getName());</span><br><span class="line">    System.out.println(file2.getParent());</span><br><span class="line">    System.out.println(file2.length());</span><br><span class="line">    System.out.println(file2.lastModified());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File f : files)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="File类的重命名功能"><a href="#File类的重命名功能" class="headerlink" title="File类的重命名功能"></a>File类的重命名功能</h5><ul>
<li><code>public boolean renameTo(File dest)</code>:把文件重命名为指定的文件路径</li>
<li>注意：<code>file1.renameTo(file2)</code>为例：要想保证返回 <code>true</code> ,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">renameTo</span> <span class="operator">=</span> file2.renameTo(file1);</span><br><span class="line">    System.out.println(renameTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="File类的判断功能"><a href="#File类的判断功能" class="headerlink" title="File类的判断功能"></a>File类的判断功能</h5><ul>
<li><code>public boolean isDirectory()</code>：判断是否是文件目录</li>
<li><code>public boolean isFile()</code> ：判断是否是文件</li>
<li><code>public boolean exists()</code> ：判断是否存在</li>
<li><code>public boolean canRead()</code> ：判断是否可读</li>
<li><code>public boolean canWrite()</code> ：判断是否可写</li>
<li><code>public boolean isHidden()</code> ：判断是否隐藏</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(file1.isDirectory());</span><br><span class="line">    System.out.println(file1.isFile());</span><br><span class="line">    System.out.println(file1.exists());</span><br><span class="line">    System.out.println(file1.canRead());</span><br><span class="line">    System.out.println(file1.canWrite());</span><br><span class="line">    System.out.println(file1.isHidden());</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io&quot;</span>);</span><br><span class="line">    file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io1&quot;</span>);</span><br><span class="line">    System.out.println(file2.isDirectory());</span><br><span class="line">    System.out.println(file2.isFile());</span><br><span class="line">    System.out.println(file2.exists());</span><br><span class="line">    System.out.println(file2.canRead());</span><br><span class="line">    System.out.println(file2.canWrite());</span><br><span class="line">    System.out.println(file2.isHidden());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="File类的创建功能"><a href="#File类的创建功能" class="headerlink" title="File类的创建功能"></a>File类的创建功能</h5><ul>
<li>创建硬盘中对应的文件或文件目录</li>
<li><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false</li>
<li><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li>
<li><code>public boolean mkdirs()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">        <span class="comment">//文件的创建</span></span><br><span class="line">        file1.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件存在</span></span><br><span class="line">        file1.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//文件目录的创建</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mkdir</span> <span class="operator">=</span> file1.mkdir();</span><br><span class="line">    <span class="keyword">if</span>(mkdir)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mkdir1</span> <span class="operator">=</span> file2.mkdirs();</span><br><span class="line">    <span class="keyword">if</span>(mkdir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要想删除成功，io4文件目录下不能有子目录或文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\io1\\io4&quot;</span>);</span><br><span class="line">    file3 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\io1&quot;</span>);</span><br><span class="line">    System.out.println(file3.delete());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="File类的删除功能"><a href="#File类的删除功能" class="headerlink" title="File类的删除功能"></a>File类的删除功能</h5><ul>
<li>删除磁盘中的文件或文件目录</li>
<li><code>public boolean delete()</code>：删除文件或者文件夹</li>
<li>删除注意事项：Java中的删除不走回收站</li>
</ul>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>用于处理设备之间的数据传输</p>
<p><code>Java.IO</code> 包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据</p>
<p>流分类：</p>
<ul>
<li><p>操作数据单位</p>
<p><strong>字节流、字符流</strong></p>
<ul>
<li>对于文本文件(<code>.txt,.java,.c,.cpp</code>)，使用字符流处理</li>
<li>对于非文本文件(<code>.jpg,.mp3,.mp4,.avi,.doc,.ppt,...</code>)，使用字节流处理</li>
</ul>
</li>
<li><p>数据流向</p>
<p><strong>输入流、输出流</strong></p>
<ul>
<li>输入 input:读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出 output:将程序（内存）数据输出到磁盘、光盘等存储设备中</li>
</ul>
</li>
<li><p>流的角色</p>
<p><strong>节点流、处理流</strong></p>
<ul>
<li>节点流：直接从数据源或目的地读写数据</li>
<li>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能</li>
</ul>
</li>
</ul>
<p>IO流的体系分类：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2d9b7400e643f8838c1aff49b709c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<p>红框为抽象基类，蓝框为常用IO流</p>
<p>常用的几个IO流结构：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>节点流（或文件流）</th>
<th>缓冲流（处理流的一种）</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputStream</td>
<td><code>FileInputStream (read(byte[] buffer))</code></td>
<td><code>BufferedInputStream (read(byte[] buffer))</code></td>
</tr>
<tr>
<td>OutputSteam</td>
<td><code>FileOutputStream (write(byte[] buffer,0,len)</code></td>
<td><code>BufferedOutputStream (write(byte[] buffer,0,len)</code> / <code>flush()</code></td>
</tr>
<tr>
<td>Reader</td>
<td><code>FileReader (read(char[] cbuf))</code></td>
<td><code>BufferedReader (read(char[] cbuf)</code> / <code>readLine()</code></td>
</tr>
<tr>
<td>Writer</td>
<td><code>FileWriter (write(char[] cbuf,0,len)</code></td>
<td><code>BufferedWriter (write(char[] cbuf,0,len)</code> / <code>flush()</code></td>
</tr>
</tbody>
</table>
</div>
<p>对抽象基类的说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入流</td>
<td>InputSteam</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputSteam</td>
<td>Writer</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>说明：Java的lO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li>
</ul>
<p><strong>InputSteam &amp; Reader</strong></p>
<ul>
<li>InputStream和Reader是所有输入流的基类。</li>
<li>InputStream（典型实现：FileInputStream）<ul>
<li><code>int read()</code></li>
<li><code>int read(byte[] b)</code></li>
<li><code>int read(byte[] b,int off,int len)</code></li>
</ul>
</li>
<li>Reader（典型实现：FileReader）<ul>
<li><code>int read()</code></li>
<li><code>int read(char[] c)</code></li>
<li><code>int read(char[] c,int off,int len)</code></li>
</ul>
</li>
<li>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</li>
<li>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader。</li>
</ul>
<p><strong>InputSteam：</strong></p>
<ul>
<li><p><code>int read()</code></p>
<p>从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</p>
</li>
<li><p><code>int read(byte[] b)</code></p>
<p>从此输入流中将最多b.length个字节的数据读入一个byte数组中。如果因为已经到达流末尾而没有可用的字节，则返回值-1.否则以整数形式返回实际读取的字节数。</p>
</li>
<li><p><code>int read(byte[] b,int off,int len)</code></p>
<p>将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。</p>
</li>
<li><p><code>public void close throws IOException</code></p>
<p>关闭此输入流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<p><strong>Reader：</strong></p>
<ul>
<li><p><code>int read()</code></p>
<p>读取单个字符。作为整数读取的字符，范围在0到65535之间（0x00-0xffff）(2个字节的 Unicode码)，如果已到达流的末尾，则返回-1。</p>
</li>
<li><p><code>int read（char[] cbuf)</code></p>
<p>将字符读入数组。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p>
</li>
<li><p><code>int read（char[] cbuf,int off,int len)</code></p>
<p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p>
</li>
<li><p><code>public void close throws IOException</code></p>
<p>关闭此输入流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<p><strong>OutputSteam &amp; Writer</strong></p>
<ul>
<li>OutputStream 和 Writer也非常相似：<ul>
<li><code>void write(int b/int c);</code></li>
<li><code>void write(byte[] b/char[] cbuf);</code></li>
<li><code>void write(byte[] b/char[] buff,int off,int len);</code></li>
<li><code>void flush();</code></li>
<li><code>void close();//需要先刷新，再关闭此流</code></li>
</ul>
</li>
<li>因为字符流直接以字符作为操作单位，所以 Writer可以用字符串来替换字符数组，即以 String对象作为参数<ul>
<li><code>void write(String str);</code></li>
<li><code>void write(String str,int off,int len);</code></li>
</ul>
</li>
<li>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputstream 用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter</li>
</ul>
<p><strong>OutputStream:</strong></p>
<ul>
<li><p><code>void write(int b)</code></p>
<p>将指定的字节写入此输出流。 write的常规协定是：向输出流写入一个字节。要写入的字节是参数b的八个低位。b的24个高位将被忽略。即写入0~255范围的</p>
</li>
<li><p><code>void write（byte[] b)</code></p>
<p>将 <code>b.length</code> 个字节从指定的byte数组写入此输出流。<code>write(b)</code>的常规协定是：应该与调用<code>wite(b,0,b.length)</code>的效果完全相同。</p>
</li>
<li><p><code>void write(byte[] b,int off,int len)</code></p>
<p>将指定byte数组中从偏移量off开始的len个字节写入此输出流。</p>
</li>
<li><p><code>public void flush()throws IOException</code></p>
<p>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p>
</li>
<li><p><code>public void close throws IOException</code></p>
<p>关闭此输岀流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
<p><strong>Writer:</strong></p>
<ul>
<li><p><code>void write(int c)</code></p>
<p>写入单个字符。要写入的字符包含在给定整数值的16个低位中，16高位被忽略。即写入0到65535之间的 Unicode码。</p>
</li>
<li><p><code>void write(char[] cbuf)</code></p>
<p>写入字符数组</p>
</li>
<li><p><code>void write(char[] cbuf,int off,int len)</code></p>
<p>写入字符数组的某一部分。从off开始，写入len个字符</p>
</li>
<li><p><code>void write(String str)</code></p>
<p>写入字符串。</p>
</li>
<li><p><code>void write(String str,int off,int len)</code></p>
<p>写入字符串的某一部分。</p>
</li>
<li><p><code>void flush()</code></p>
<p>刷新该流的缓冲，则立即将它们写入预期目标。</p>
</li>
<li><p><code>public void close throws IOException</code></p>
<p>关闭此输出流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<p>输入输出标准化过程：</p>
<ul>
<li><p>输入</p>
<ol>
<li>创建 File 类的对象，指明读取的数据的来源。（要求此文件一定要存在）</li>
<li>创建相应的输入流，将 File 类的对象作为参数，传入流的构造器中</li>
<li>具体的读入过程：创建相应的 <code>byte[]</code> 或 <code>char[]</code></li>
<li>关闭流资源</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理</p>
</li>
<li><p>输出</p>
<ol>
<li>创建 File 类的对象，指明写出的数据的位置。（不要求此文件一定要存在）</li>
<li>创建相应的输出流，将 File 类的对象作为参数，传入流的构造器中</li>
<li>具体的写出过程：<code>write(char[]/byte[] buffer,0,len)</code></li>
<li>关闭流资源</li>
</ol>
<p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理</p>
</li>
</ul>
<h3 id="节点流（文件流）"><a href="#节点流（文件流）" class="headerlink" title="节点流（文件流）"></a>节点流（文件流）</h3><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><ul>
<li><p>输入：从文件中读取到内存（程序）中</p>
<ol>
<li>建立一个流对象，将已存在的一个文件加载进流 <code>FileReader fr = new FileReader(new File(&quot;Test. txt&quot;));</code></li>
<li>创建一个临时存放数据的数组 <code>char[] ch = new char[1024];</code></li>
<li>调用流对象的读取方法将流中的数据读入到数组中。 <code>fr.read(ch);</code></li>
<li>关闭资源。 <code>fr.close();</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读入的操作</span></span><br><span class="line">        <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><code>read()</code> 的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li>
<li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用 <code>try-catch-finally</code> 处理</li>
<li>读入的文件一定要存在，否则就会报 <code>FileNotFoundException</code></li>
</ol>
</li>
<li><p>输出：从内存（程序）到硬盘文件中</p>
<ol>
<li>创建流对象，建立数据存放文件 <code>File Writer fw = new File Writer(new File(&quot;Test.txt&quot;))</code></li>
<li>调用流对象的写入方法，将数据写入流 <code>fw.write(&quot;HelloWord&quot;)</code></li>
<li>关闭流资源，并将流中的数据清空到文件中。 <code>fw.close();</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例如：实现文本文件的复制操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line">        <span class="comment">//            File srcFile = new File(&quot;test.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//            File destFile = new File(&quot;test1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>文件字节流操作与字符流操作类似，只是实例化对象操作和数据类型不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：实现图片文件复制操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建操流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>定义路径时，可以用 <code>/</code> 或 <code>\\</code></li>
<li>输出操作，对应的 File 可以不存在的。并不会报异常。</li>
<li>File 对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File 对应的硬盘中的文件如果存在：<ul>
<li>如果流使用的构造器是：<code>FileWriter(file,false)</code> / <code>FileWriter(file)</code>:对原有文件的覆盖。</li>
<li>如果流使用的构造器是：<code>FileWriter(file,true)</code>:不会对原有文件覆盖，而是在原有文件基础上追加内容。</li>
</ul>
</li>
<li>读取文件时，必须保证文件存在，否则会报异常。</li>
<li>对于文本文件(<code>.txt,.java,.c,.cpp</code>)，使用字符流处理</li>
<li>对于非文本文件(<code>.jpg,.mp3,.mp4,.avi,.doc,.ppt,...</code>)，使用字节流处理</li>
</ul>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>缓冲流涉及到的类：</p>
<ul>
<li><code>BufferedInputStream</code></li>
<li><code>BufferedOutputStream</code></li>
<li><code>BufferedReader</code></li>
<li><code>BufferedWriter</code></li>
</ul>
<p>引入目的：</p>
<ul>
<li>作用：提供流的读取、写入的速度</li>
<li>提高读写速度的原因：内部提供了一个缓冲区</li>
</ul>
<p>使用：</p>
<ul>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。</li>
<li>当使用 <code>BufferedInputStream</code> 读取字节文件时，<code>BufferedInputStream</code> 会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，<code>BufferedOutputStream</code> 才会把缓冲区中的数据一次性写到文件里。使用方法 <code>flush()</code> 可以强制将缓冲区的内容全部写入输出流。</li>
<li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流。</li>
<li><code>flush()</code> 方法的使用：手动将 buffer 中内容写入文件。</li>
<li>如果是带缓冲区的流对象的 <code>close()</code> 方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出</li>
</ul>
<p>使用 <code>BufferInputStream</code> 和 <code>BufferOutputStream</code> 实现非文本文件的复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test4.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2造缓冲流，可以合并书写</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.文件读取、写出操作</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bis != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>BufferedReader</code> 和 <code>BufferedWriter</code> 实现文本文件的复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line">        <span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line">        <span class="comment">//    //            bw.flush();</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法一：</span></span><br><span class="line">            <span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">            <span class="comment">//方法二：</span></span><br><span class="line">            bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">            bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试缓冲流和节点流文件复制速度</p>
<ul>
<li><p>节点流实现复制方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定路径下文件的复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>缓冲流实现复制操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现文件复制的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源关闭</span></span><br><span class="line">        <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>测试二者速度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCopyFileWithBuffered</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\01-视频.avi&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\03-视频.avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    copyFileWithBuffered(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//618 - 176</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实现图片加密操作：</p>
<p>加密操作</p>
<ul>
<li>将图片文件通过字节流读取到程序中</li>
<li>将图片的字节流逐一进行 <code>^</code> 操作</li>
<li>将处理后的图片字节流输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图片的加密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testSecret.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解密操作</p>
<ul>
<li>将加密后图片文件通过字节流读取到程序中</li>
<li>将图片的字节流逐一进行 <code>^</code> 操作（原理：<code>A^B^B = A</code>）</li>
<li>将处理后的图片字节流输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图片的解密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testSecret.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test4.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计文本字符出现次数：</p>
<p>实现思路：</p>
<ol>
<li>遍历文本每一个字符</li>
<li>字符出现的次数存在Map中</li>
<li>把map中的数据写入文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWordCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Map集合</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//int 还原 char</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) c;</span><br><span class="line">            <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(ch) == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(ch, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">        <span class="comment">//3.1 创建Writer</span></span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;wordcount.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (entry.getKey()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    bw.write(<span class="string">&quot;空格=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                    bw.write(<span class="string">&quot;tab键=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:<span class="comment">//</span></span><br><span class="line">                    bw.write(<span class="string">&quot;回车=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:<span class="comment">//</span></span><br><span class="line">                    bw.write(<span class="string">&quot;换行=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    bw.write(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ul>
<li><code>InputstreamReader</code>：将 <code>Inputstream</code> 转换为 <code>Reader</code></li>
<li><code>OutputStreamWriter</code>：将 <code>Writer</code> 转换为 <code>OutputStream</code></li>
</ul>
</li>
<li>字节流中的数据都是字符时，转成字符流操作更高效。</li>
<li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</li>
</ul>
<h5 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><code>InputStreamReader</code></h5><p><code>InputStreamReader</code> 将一个字节的输入流转换为字符的输入流</p>
<p>解码：字节、字节数组 —-&gt;字符数组、字符串</p>
<p>构造器：</p>
<ul>
<li><code>public InputStreamReader(InputStream in)</code></li>
<li><code>public InputStreamReader(Inputstream in,String charsetName)//可以指定编码集</code></li>
</ul>
<h5 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a><code>OutputStreamWriter</code></h5><p><code>OutputStreamWriter</code> 将一个字符的输出流转换为字节的输出流</p>
<p>编码：字符数组、字符串 —-&gt; 字节、字节数组</p>
<p>构造器：</p>
<ul>
<li><code>public OutputStreamWriter(OutputStream out)</code></li>
<li><code>public OutputStreamWriter(Outputstream out,String charsetName)//可以指定编码集</code></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8a2d6c522c4bdba8fe89378e9d5d82~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件、造流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">        isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        osw = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写过程</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        <span class="keyword">if</span> (isr != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (osw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                osw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明：文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）</span></span><br></pre></td></tr></table></figure>
<h4 id="编码集"><a href="#编码集" class="headerlink" title="编码集"></a>编码集</h4><p>常见的编码表</p>
<ul>
<li>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li>Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符</li>
</ul>
<p>编码应用</p>
<ul>
<li>编码：字符串—&gt;字节数组</li>
<li>解码：字节数组—&gt;字符串</li>
<li>转换流的编码应用<ul>
<li>可以将字符按指定编码格式存储</li>
<li>可以对文本数据按指定编码格式来解读</li>
<li>指定编码表的动作由构造器完成</li>
</ul>
</li>
</ul>
<p>使用要求：</p>
<p>客户端/浏览器端 &lt;——&gt; 后台(java,GO,Python,Node.js,php) &lt;——&gt; 数据库</p>
<p>要求前前后后使用的字符集都要统一：UTF-8</p>
<h3 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h3><p>简介：</p>
<p><code>System.in</code>:标准的输入流，默认从键盘输入</p>
<p><code>System.out</code>:标准的输出流，默认从控制台输出</p>
<p>主要方法：</p>
<p><code>System</code> 类的 <code>setIn(InputStream is)</code> 方式重新指定输入的流</p>
<p><code>System</code> 类的 <code>setOut(PrintStream ps)</code> 方式重新指定输出的流</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入 e 或者 exit 时，退出程序</span></span><br><span class="line"><span class="comment">//设计思路：</span></span><br><span class="line"><span class="comment">//1.使用 Scanner 实现，调用 next() 返回一个字符串</span></span><br><span class="line"><span class="comment">//2.使用 System.in 实现。System.in ---&gt; 转换流 ---&gt; BufferedReader的readLine()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设计实现scanner类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> &#123;</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>PrintStream</code> 和 <code>PrintWriter</code></p>
<ul>
<li>提供了一系列重载的 <code>print()</code> 和 <code>println()</code> 方法，用于多种数据类型的输出</li>
<li><code>System.out</code> 返回的是 <code>PrintStream</code> 的实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">        ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">                System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code> 和 <code>DataOutputStream</code></p>
<p>作用： 用于读取或写出基本数据类型的变量或字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将内存中的字符串、基本数据类型的变量写出到文件中</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造对象、造流</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//数据输出</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;Bruce&quot;</span>);</span><br><span class="line">        dos.flush();<span class="comment">//刷新操作，将内存的数据写入到文件</span></span><br><span class="line">        dos.writeInt(<span class="number">23</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (dos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中</span></span><br><span class="line"><span class="comment">//注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造对象、造流</span></span><br><span class="line">        dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.从文件读入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age:&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;isMale:&quot;</span>+isMale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (dis != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>对象流：</p>
<ul>
<li><code>ObjectOutputStream</code>:内存中的对象—-&gt;存储中的文件、通过网络传输出去：序列化过程</li>
<li><code>ObjectInputStream</code>:存储中的文件、通过网络接收过来 —-&gt;内存中的对象：反序列化过</li>
</ul>
<p>对象的序列化：</p>
<ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</li>
<li>序列化的好处在于可将任何实现了<code>Serializable</code>接口的对象转化为字节数据，使其在保存和传输时可被还原。</li>
<li>序列化是RMI(Remote Method Invoke-远程方法调用)过程的参数和返回值都必须实现的机制，RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础。</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出 <code>NotserializableEXception</code> 异常<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
</li>
<li>凡是实现<code>Serializable</code>接口的类都有一个表示序列化版本标识符的静态变量：<ul>
<li><code>private static final long serialVersionUID;</code></li>
<li><code>serialVersionUID</code> 用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，<code>serialVersionUID</code>可能发生变化。故建议显式声明。</li>
</ul>
</li>
<li>简单来说，Java 的序列化机制是通过在运行时判断类的 <code>serialversionUID</code> 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 <code>serialversionUID</code> 与本地相应实体类的  <code>serialversionUID</code> 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(<code>InvalidCastException</code>)</li>
</ul>
<p>实现序列化的对象所属的类需要满足：</p>
<ol>
<li>需要实现接口：<code>Serializable</code>（标识接口）</li>
<li>当前类提供一个全局常量：<code>serialVersionUID</code>（序列版本号）</li>
<li>除了当前 <code>Person</code> 类需要实现 <code>Serializable</code> 接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li>
</ol>
<p>补充：<code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 不能序列化 <code>static</code> 和 <code>transient</code> 修饰的成员变量</p>
<p>使用：</p>
<ul>
<li><p>序列化代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化：将对象写入磁盘或进行网络传输</span></span><br><span class="line"><span class="comment">//要求被序列化对象必须实现序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象，创建流</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">//2.操作流</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>反序列化代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反序列化：将磁盘的对象数据源读出</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="随机存取文件流"><a href="#随机存取文件流" class="headerlink" title="随机存取文件流"></a>随机存取文件流</h3><p>简介:</p>
<ul>
<li><code>RandomAccessFile</code> 直接继承于 <code>java.lang.Object</code> 类，实现了 <code>DataInput</code> <code>和DataOutput</code> 接口</li>
<li><code>RandomAccessFile</code> 既可以作为一个输入流，又可以作为一个输出流</li>
<li><code>RandomAccessFile</code> 类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><code>RandomAccessFile</code> 对象包含一个记录指针，用以标示当前读写处的位置</li>
<li><code>RandomaccessFile</code> 类对象可以自由移动记录指针：<ul>
<li><code>long getFilePointer()</code>：获取文件记录指针的当前位置</li>
<li><code>void seek(long pos)</code>：将文件记录指针定位到 <code>pos</code> 位置</li>
</ul>
</li>
</ul>
<p><strong>构造器</strong></p>
<p><code>public RandomAccessFile(File file,String mode)</code> <code> </code>public RandomAccessFile(String name,String mode)</p>
<p>使用说明：</p>
<ol>
<li>如果 <code>RandomAccessFile</code> 作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</li>
<li>如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</li>
<li>可以通过相关的操作，实现 <code>RandomAccessFile</code> <strong>“插入”</strong>数据的效果。借助 <code>seek(int pos)</code> 方法</li>
<li>创建 <code>RandomAccessFile</code>类实例需要指定一个 <code>mode</code>参数，该参数指定<code>RandomAccessFile</code>的访问模式:<ul>
<li>r：以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd：打开以便读取和写入；同步文件内容的更新</li>
<li>rws：打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读 r ,则不会创建文件，而是会去读取一个已经存在的文件,读取的文件不存在则会出现异常。如果模式为 rw 读写,文件不存在则会去创建文件，存在则不会创建</li>
</ol>
<p>例如：</p>
<p>文件的读取和写出操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象，创建流</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//2.操作流</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>RandomAccessFile</code> 实现数据的插入效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">        <span class="comment">//            //方式一</span></span><br><span class="line">        <span class="comment">//            //保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">        <span class="comment">//            StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length());</span></span><br><span class="line">        <span class="comment">//            byte[] buffer = new byte[20];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while ((len = raf1.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                builder.append(new String(buffer,0,len));</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">        raf1.seek(<span class="number">3</span>);</span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">        raf1.write(baos.toString().getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="流的基本应用"><a href="#流的基本应用" class="headerlink" title="流的基本应用"></a>流的基本应用</h3><ul>
<li><p>流是用来处理数据的</p>
</li>
<li><p>处理数据时，一定要先明确数据源，与数据目的地数据源可以是文件，可以是键盘数据目的地可以是文件、显示器或者其他设备</p>
</li>
<li><p>而流只是在帮助数据进行传输，并对传输的数据进行处理，比如过滤处理、转换处理等</p>
</li>
<li><p>除去RandomAccessFile类外所有的流都继承于四个基本数据流抽象类InputSteam、OutputSteam、Reader、Writer</p>
</li>
<li><p>不同的操作流对应的后缀均为四个抽象基类中的某一个</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59ee6f429cf94040a78337c525fb394f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200502091615386"></p>
</li>
<li><p>不同处理流的使用方式都是标准操作：</p>
<ul>
<li>创建文件对象，创建相应的流</li>
<li>处理流数据</li>
<li>关闭流</li>
<li>用try-catch-finally处理异常</li>
</ul>
</li>
</ul>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h4><ul>
<li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO AP。</li>
<li>NIO 与原来的 IO 同样的作用和目的，但是使用的方式完全不同，NIO 支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。</li>
<li>NIO 将以更加高效的方式进行文件的读写操作。</li>
<li>JDK 7.0对 NIO 进行了极大的扩展，增强了对文件处理和文件系统特性的支持，称他为 NIO.2。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO</span><br><span class="line">|-----java.nio.channels.Channel</span><br><span class="line">      |---- FileChannel：处理本地文件</span><br><span class="line">      |---- SocketChannel：TCP网络编程的客户端的Channel</span><br><span class="line">      |---- ServerSocketChannel：TCP网络编程的服务器端的Channel</span><br><span class="line">      |---- DatagramChannel：UDP网络编程中发送端和接收端的Channel</span><br></pre></td></tr></table></figure>
<h4 id="Path接口"><a href="#Path接口" class="headerlink" title="Path接口"></a>Path接口</h4><p>JDK 7.0提供</p>
<ul>
<li>早期的 Java 只提供了一个 <code>File</code> 类来访问文件系统，但 <code>File</code> 类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</li>
<li>NIO.2为了弥补这种不足，引入了 <code>Path</code> 接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<code>Path</code> 可以看成是 <code>File</code> 类的升级版本，实际引用的资源也可以不存在。</li>
</ul>
<h5 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h5><p>Path替换原有的File类。</p>
<ul>
<li>在以前IO操作都是这样写的：<ul>
<li><code>import java.io.File</code></li>
<li><code>File file = new File(&quot;index.html&quot;);</code></li>
</ul>
</li>
<li>但在Java7中，我们可以这样写：<ul>
<li><code>import java.nio.file.Path;</code></li>
<li><code>import java.nio.file.Paths;</code></li>
<li><code>Path path = Paths.get(&quot;index. html&quot;);</code></li>
</ul>
</li>
</ul>
<h5 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h5><ul>
<li><code>Paths</code> 类提供的静态 <code>get()</code> 方法用来获取 <code>Path</code> 对象：</li>
<li><code>static Path get(String first， String….more)</code>：用于将多个字符串串连成路径</li>
<li><code>static Path get(URI uri)</code>：返回指定 uri 对应的 Path 路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//new File(String filepath)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\&quot;</span>, <span class="string">&quot;test\\test1\\haha.txt&quot;</span>);<span class="comment">//new File(String parent,String filename);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(path1);</span><br><span class="line">    System.out.println(path2);</span><br><span class="line">    System.out.println(path3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>String toString()</code> ： 返回调用 <code>Path</code> 对象的字符串表示形式</li>
<li><code>boolean startsWith(String path)</code> : 判断是否以 <code>path</code> 路径开始</li>
<li><code>boolean endsWith(String path)</code> : 判断是否以 <code>path</code> 路径结束</li>
<li><code>boolean isAbsolute()</code> : 判断是否是绝对路径</li>
<li><code>Path getParent()</code> ：返回 <code>Path</code> 对象包含整个路径，不包含 <code>Path</code> 对象指定的文件路径</li>
<li><code>Path getRoot()</code> ：返回调用 <code>Path</code> 对象的根路径</li>
<li><code>Path getFileName()</code> : 返回与调用 <code>Path</code> 对象关联的文件名</li>
<li><code>int getNameCount()</code> : 返回 <code>Path</code> 根目录后面元素的数量</li>
<li><code>Path getName(int idx)</code> : 返回指定索引位置 <code>idx</code> 的路径名称</li>
<li><code>Path toAbsolutePath()</code> : 作为绝对路径返回调用 <code>Path</code> 对象</li>
<li><code>Path resolve(Path p)</code> :合并两个路径，返回合并后的路径对应的 <code>Path</code> 对象</li>
<li><code>File toFile()</code>: 将 <code>Path</code> 转化为 <code>File</code> 类的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;nio\\nio1\\nio2\\hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String toString() ： 返回调用 Path 对象的字符串表示形式</span></span><br><span class="line">    System.out.println(path1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean startsWith(String path) : 判断是否以 path 路径开始</span></span><br><span class="line">    System.out.println(path1.startsWith(<span class="string">&quot;d:\\nio&quot;</span>));</span><br><span class="line">    <span class="comment">//boolean endsWith(String path) : 判断是否以 path 路径结束</span></span><br><span class="line">    System.out.println(path1.endsWith(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//boolean isAbsolute() : 判断是否是绝对路径</span></span><br><span class="line">    System.out.println(path1.isAbsolute() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    System.out.println(path2.isAbsolute() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    <span class="comment">//Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span><br><span class="line">    System.out.println(path1.getParent());</span><br><span class="line">    System.out.println(path2.getParent());</span><br><span class="line">    <span class="comment">//Path getRoot() ：返回调用 Path 对象的根路径</span></span><br><span class="line">    System.out.println(path1.getRoot());</span><br><span class="line">    System.out.println(path2.getRoot());</span><br><span class="line">    <span class="comment">//Path getFileName() : 返回与调用 Path 对象关联的文件名</span></span><br><span class="line">    System.out.println(path1.getFileName() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    System.out.println(path2.getFileName() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    <span class="comment">//int getNameCount() : 返回Path 根目录后面元素的数量</span></span><br><span class="line">    <span class="comment">//Path getName(int idx) : 返回指定索引位置 idx 的路径名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.getNameCount(); i++) &#123;</span><br><span class="line">        System.out.println(path1.getName(i) + <span class="string">&quot;*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</span></span><br><span class="line">    System.out.println(path1.toAbsolutePath());</span><br><span class="line">    System.out.println(path2.toAbsolutePath());</span><br><span class="line">    <span class="comment">//Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;nio&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;nioo\\hi.txt&quot;</span>);</span><br><span class="line">    path3 = path3.resolve(path4);</span><br><span class="line">    System.out.println(path3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//File toFile(): 将Path转化为File类的对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> path1.toFile();<span class="comment">//Path---&gt;File的转换</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> file.toPath();<span class="comment">//File---&gt;Path的转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Files类"><a href="#Files类" class="headerlink" title="Files类"></a>Files类</h4><p><code>java.nio.file.Files</code> 用于操作文件或目录的工具类</p>
<h5 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><p><code>Path copy(Path src, Path dest, CopyOption … how)</code> : 文件的复制</p>
<p>要想复制成功，要求 <code>path1</code> 对应的物理上的文件存在。<code>path1</code> 对应的文件没有要求。</p>
</li>
<li><p><code>Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);</code></p>
</li>
<li><p><code>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)</code> : 创建一个目录</p>
<p>要想执行成功，要求 <code>path</code> 对应的物理上的文件目录不存在。一旦存在，抛出异常。</p>
</li>
<li><p><code>Path createFile(Path path, FileAttribute&lt;?&gt; … arr)</code> : 创建一个文件</p>
</li>
<li><p>要想执行成功，要求 <code>path</code> 对应的物理上的文件不存在。一旦存在，抛出异常。</p>
</li>
<li><p><code>void delete(Path path)</code> : 删除一个文件/目录，如果不存在，执行报错</p>
</li>
<li><p><code>void deleteIfExists(Path path)</code> : <code>Path</code> 对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</p>
</li>
<li><p><code>Path move(Path src, Path dest, CopyOption…how)</code> : 将 <code>src</code> 移动到 <code>dest</code> 位置</p>
<p>要想执行成功，<code>src</code> 对应的物理上的文件需要存在，<code>dest</code> 对应的文件没有要求。</p>
</li>
<li><p><code>long size(Path path)</code> : 返回 <code>path</code> 指定文件的大小</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</span></span><br><span class="line">    <span class="comment">//要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</span></span><br><span class="line">    <span class="comment">//Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</span></span><br><span class="line">    <span class="comment">//要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio\\nio1&quot;</span>);</span><br><span class="line">    <span class="comment">//Files.createDirectory(path3);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</span></span><br><span class="line">    <span class="comment">//要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio\\hi.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//Files.createFile(path4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</span></span><br><span class="line">    <span class="comment">//Files.delete(path4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</span></span><br><span class="line">    Files.deleteIfExists(path3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</span></span><br><span class="line">    <span class="comment">//要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</span></span><br><span class="line">    <span class="comment">//Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//long size(Path path) : 返回 path 指定文件的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Files.size(path2);</span><br><span class="line">    System.out.println(size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常用方法：用于判断"><a href="#常用方法：用于判断" class="headerlink" title="常用方法：用于判断"></a>常用方法：用于判断</h5><ul>
<li><p><code>boolean exists(Path path, LinkOption … opts)</code> : 判断文件是否存在</p>
</li>
<li><p><code>boolean isDirectory(Path path, LinkOption … opts)</code>: 判断是否是目录</p>
<p>不要求此 <code>path</code> 对应的物理文件存在。</p>
</li>
<li><p><code>boolean isRegularFile(Path path, LinkOption … opts)</code>: 判断是否是文件</p>
</li>
<li><p><code>boolean isHidden(Path path)</code> : 判断是否是隐藏文件</p>
<p>要求此 <code>path</code> 对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</p>
</li>
<li><p><code>boolean isReadable(Path path)</code> : 判断文件是否可读</p>
</li>
<li><p><code>boolean isWritable(Path path)</code> : 判断文件是否可写</p>
</li>
<li><p><code>boolean notExists(Path path, LinkOption … opts)</code> : 判断文件是否不存在</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</span></span><br><span class="line">    System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</span></span><br><span class="line">    <span class="comment">//不要求此path对应的物理文件存在。</span></span><br><span class="line">    System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isHidden(Path path) : 判断是否是隐藏文件</span></span><br><span class="line">    <span class="comment">//要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</span></span><br><span class="line">    <span class="comment">//System.out.println(Files.isHidden(path1));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isReadable(Path path) : 判断文件是否可读</span></span><br><span class="line">    System.out.println(Files.isReadable(path1));</span><br><span class="line">    <span class="comment">//boolean isWritable(Path path) : 判断文件是否可写</span></span><br><span class="line">    System.out.println(Files.isWritable(path1));</span><br><span class="line">    <span class="comment">//boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</span></span><br><span class="line">    System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong></p>
<ul>
<li><code>StandardOpenOption.READ</code>:表示对应的 <code>Channel</code> 是可读的。</li>
<li><code>StandardOpenOption.WRITE</code>：表示对应的 <code>Channel</code> 是可写的。</li>
<li><code>StandardOpenOption.CREATE</code>：如果要写出的文件不存在，则创建。如果存在，忽略</li>
<li><code>StandardOpenOption.CREATE_NEW</code>：如果要写出的文件不存在，则创建。如果存在，抛异常</li>
</ul>
<h5 id="常用方法：用于操作内容"><a href="#常用方法：用于操作内容" class="headerlink" title="常用方法：用于操作内容"></a>常用方法：用于操作内容</h5><ul>
<li><code>InputStream newInputStream(Path path, OpenOption…how)</code>:获取 <code>InputStream</code> 对象</li>
<li><code>OutputStream newOutputStream(Path path, OpenOption…how)</code> : 获取 <code>OutputStream</code> 对象</li>
<li><code>SeekableByteChannel newByteChannel(Path path, OpenOption…how)</code> : 获取与指定文件的连接，<code>how</code> 指定打开方式。</li>
<li><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path path)</code> : 打开 <code>path</code> 指定的目录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Files.newInputStream(path1, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</span></span><br><span class="line">    <span class="type">SeekableByteChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DirectoryStream&lt;Path&gt;  newDirectoryStream(Path path) : 打开 path 指定的目录</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;e:\\teach&quot;</span>);</span><br><span class="line">    DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(path2);</span><br><span class="line">    Iterator&lt;Path&gt; iterator = directoryStream.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/post/3006dc10.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>系统为某一程序分配时间时，所需时间与空间大小无关，与申请次数有关<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/multiset区别：是否允许重复元素，set不允许，multiset允许</span><br><span class="line">        <span class="built_in">insert</span>()  插入一个数</span><br><span class="line">        <span class="built_in">find</span>()  查找一个数</span><br><span class="line">        <span class="built_in">count</span>()  返回某一个数的个数</span><br><span class="line">        <span class="built_in">erase</span>()</span><br><span class="line">            (<span class="number">1</span>) 输入是一个数x，删除所有<span class="function">x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span><br><span class="line">    和上面类似，增删改查的时间复杂度是 <span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">    不支持 <span class="built_in">lower_bound</span>()/<span class="built_in">upper_bound</span>()， 迭代器的++，--</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bitset, 圧位</span><br><span class="line">    bitset&lt;10000&gt; s;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/post/ae0f95e0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring6</title>
    <url>/post/e600a460.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring是一款主流的JavaEE轻量级开源框架，其目的是用于简化Java企业级应用的开发难度和开发周期。<br>Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<br>Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。</p>
<h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>在不同的语境中，Spring 所代表的含义是不同的</p>
<ul>
<li><strong>广义的 Spring：Spring 技术栈</strong><br>广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。<br>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。<br>这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</li>
<li><strong>狭义的 Spring：Spring Framework</strong><br>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。<br>Spring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。<br>Spring 有两个最核心模块： IoC 和 AOP。<ul>
<li><strong>IoC</strong>：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。</li>
<li><strong>AOP</strong>：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。</li>
</ul>
</li>
</ul>
<h2 id="Spring-Framework特点"><a href="#Spring-Framework特点" class="headerlink" title="Spring Framework特点"></a>Spring Framework特点</h2><ul>
<li><p>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</p>
</li>
<li><p>控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。</p>
</li>
<li><p>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</p>
</li>
<li><p>容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</p>
</li>
<li><p>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</p>
</li>
<li><p>一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</p>
</li>
</ul>
<h3 id="Spring模块组成"><a href="#Spring模块组成" class="headerlink" title="Spring模块组成"></a>Spring模块组成</h3><p>官网地址：<a href="https://spring.io/">https://spring.io/</a><br><img src="spring模块.png" alt></p>
<p><strong>①Spring Core（核心容器）</strong></p>
<p>spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。</p>
<ul>
<li><p>spring-core ：IOC和DI的基本实现</p>
</li>
<li><p>spring-beans：BeanFactory和Bean的装配管理(BeanFactory)</p>
</li>
<li>spring-context：Spring context上下文，即IOC容器(AppliactionContext)</li>
<li>spring-expression：spring表达式语言</li>
</ul>
<p><strong>②Spring AOP</strong></p>
<ul>
<li>spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy</li>
<li>spring-aspects：集成AspectJ，AOP应用框架</li>
<li>spring-instrument：动态Class Loading模块</li>
</ul>
<p><strong>③Spring Data Access</strong></p>
<ul>
<li>spring-jdbc：spring对JDBC的封装，用于简化jdbc操作</li>
<li>spring-orm：java对象与数据库数据的映射框架</li>
<li>spring-oxm：对象与xml文件的映射框架</li>
<li>spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信</li>
<li>spring-tx：spring jdbc事务管理</li>
</ul>
<p><strong>④Spring Web</strong></p>
<ul>
<li>spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器</li>
<li>spring-webmvc：实现web mvc</li>
<li>spring-websocket：与前端的全双工通信协议</li>
<li>spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务</li>
</ul>
<p><strong>⑤Spring Message</strong></p>
<ul>
<li>Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务</li>
</ul>
<p><strong>⑥Spring test</strong></p>
<ul>
<li>spring-test：集成测试支持，主要是对junit的封装</li>
</ul>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>JDK：Java17+<strong>（Spring6要求JDK最低版本是Java17）</strong><br>Maven：3.6+<br>Spring：6.0.2</p>
<h2 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h2><ol>
<li><strong>构建父模块spring6</strong><br>在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project<br>点击“Create”<br>删除src目录</li>
<li><strong>构建子模块spring6-first</strong><br>点击 Create 完成</li>
</ol>
<h2 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p><a href="https://spring.io/projects/spring-framework#learn">网址</a><br><strong>添加依赖：</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="创建java类"><a href="#创建java类" class="headerlink" title="创建java类"></a>创建java类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs.xm）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理</span></span><br><span class="line"><span class="comment">    通过bean标签配置IOC容器所管理的bean</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">        id：设置bean的唯一标识</span></span><br><span class="line"><span class="comment">        class：设置bean所对应类型的全类名</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.HelloWorld&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建测试类测试"><a href="#创建测试类测试" class="headerlink" title="创建测试类测试"></a>创建测试类测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloworld</span> <span class="operator">=</span> (HelloWorld) ac.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        helloworld.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><strong>1. 底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？</strong></p>
<p>修改HelloWorld类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建对象时调用了无参数构造方法。</strong></p>
<p><strong>2. Spring是如何创建对象的呢？原理是什么？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dom4j解析beans.xml文件，从中获取class属性值，类的全类名</span></span><br><span class="line"> <span class="comment">// 通过反射机制调用无参数构造方法创建对象</span></span><br><span class="line"> <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.spring6.bean.HelloWorld&quot;</span>);</span><br><span class="line"> <span class="comment">//Object obj = clazz.newInstance();</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure>
<p><strong>3. 把创建好的对象存储到一个什么样的数据结构当中了呢？</strong></p>
<p>bean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在<strong>DefaultListableBeanFactory</strong>类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
<p>Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,<br>Map<String,BeanDefinition> , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。</String,BeanDefinition></p>
<h2 id="启用Log4j2日志框架"><a href="#启用Log4j2日志框架" class="headerlink" title="启用Log4j2日志框架"></a>启用Log4j2日志框架</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。</p>
<p><strong>Apache Log4j2</strong>是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。</p>
<p><strong>Log4j2主要由几个重要的组件构成：</strong></p>
<p><strong>（1）日志信息的优先级</strong>，日志信息的优先级从高到低有<strong>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</strong><br>TRACE：追踪，是最低的日志级别，相当于追踪程序的执行<br>DEBUG：调试，一般在开发中，都将其设置为最低的日志级别<br>INFO：信息，输出重要的信息，使用较多<br>WARN：警告，输出警告的信息<br>ERROR：错误，输出错误信息<br>FATAL：严重错误</p>
<p>这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示</p>
<p><strong>（2）日志信息的输出目的地</strong>，日志信息的输出目的地指定了日志将打印到<strong>控制台</strong>还是<strong>文件中</strong>；</p>
<p><strong>（3）日志信息的输出格式</strong>，而输出格式则控制了日志信息的显示内容。</p>
<h3 id="引入Log4j2依赖"><a href="#引入Log4j2依赖" class="headerlink" title="引入Log4j2依赖"></a>引入Log4j2依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="加入日志配置文件"><a href="#加入日志配置文件" class="headerlink" title="加入日志配置文件"></a>加入日志配置文件</h3><p>在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            level指定日志级别，从低到高的优先级：</span></span><br><span class="line"><span class="comment">                TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span></span><br><span class="line"><span class="comment">                trace：追踪，是最低的日志级别，相当于追踪程序的执行</span></span><br><span class="line"><span class="comment">                debug：调试，一般在开发中，都将其设置为最低的日志级别</span></span><br><span class="line"><span class="comment">                info：信息，输出重要的信息，使用较多</span></span><br><span class="line"><span class="comment">                warn：警告，输出警告的信息</span></span><br><span class="line"><span class="comment">                error：错误，输出错误信息</span></span><br><span class="line"><span class="comment">                fatal：严重错误</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;spring6log&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;log&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;spring6log&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;log&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;d:/spring6_log/test.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的信息，</span></span><br><span class="line"><span class="comment">            每次大小超过size，</span></span><br><span class="line"><span class="comment">            则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，</span></span><br><span class="line"><span class="comment">            作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFile&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;d:/spring6_log/app.log&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;50MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，</span></span><br><span class="line"><span class="comment">            则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行原测试程序，多了spring打印日志</p>
<h3 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloworld</span> <span class="operator">=</span> (HelloWorld) ac.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        helloworld.sayHello();</span><br><span class="line">        logger.info(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="容器：IoC"><a href="#容器：IoC" class="headerlink" title="容器：IoC"></a>容器：IoC</h1><p>IoC是Inversion of Control的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p>
<p>Spring<strong>通过IoC容器来管理所有Java对象的实例化和初始化，控制对象与对象之间的依赖关系</strong>。将由IoC容器管理的Java对象称为Spring Bean，它与使用关键字new创建的Java对象没有任何区别。</p>
<p>IoC容器是Spring框架中最重要的核心组件之一</p>
<h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul>
<li>控制反转是一种思想。</li>
<li>控制反转是为了降低程序耦合度，提高程序扩展力。</li>
<li>控制反转，反转的是什么？ <ul>
<li>将对象的创建权利交出去，交给第三方容器负责。 </li>
<li>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</li>
</ul>
</li>
<li>控制反转这种思想如何实现呢？ <ul>
<li>DI（Dependency Injection）：依赖注入</li>
</ul>
</li>
</ul>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>依赖注入：指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</strong><br>常见的两种实现方式：①set注入；②构造注入；<br>IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现<br>Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）</p>
<h3 id="在spring6的实现"><a href="#在spring6的实现" class="headerlink" title="在spring6的实现"></a>在spring6的实现</h3><p>Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式：</p>
<p><strong>①BeanFactory</strong></p>
<p>这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</p>
<p><strong>②ApplicationContext</strong></p>
<p>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p>
<p><strong>③ApplicationContext的主要实现类</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>ConfigurableApplicationContext</td>
<td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="基于xml管理bean"><a href="#基于xml管理bean" class="headerlink" title="基于xml管理bean"></a>基于xml管理bean</h2><h3 id="搭建子模块spring6-ioc-xml"><a href="#搭建子模块spring6-ioc-xml" class="headerlink" title="搭建子模块spring6-ioc-xml"></a>搭建子模块spring6-ioc-xml</h3><p><strong>①搭建模块</strong></p>
<p>搭建方式如：spring-first</p>
<p><strong>②引入配置文件</strong></p>
<p>引入spring-first模块配置文件：beans.xml、log4j2.xml</p>
<p><strong>③添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>④引入java类</strong></p>
<p>引入spring-first模块java及test目录下实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验一：获取bean"><a href="#实验一：获取bean" class="headerlink" title="实验一：获取bean"></a>实验一：获取bean</h3><h3 id="实验二：依赖注入之setter注入"><a href="#实验二：依赖注入之setter注入" class="headerlink" title="实验二：依赖注入之setter注入"></a>实验二：依赖注入之setter注入</h3><h3 id="实验三：依赖注入之构造器注入"><a href="#实验三：依赖注入之构造器注入" class="headerlink" title="实验三：依赖注入之构造器注入"></a>实验三：依赖注入之构造器注入</h3><h3 id="实验四：特殊值处理"><a href="#实验四：特殊值处理" class="headerlink" title="实验四：特殊值处理"></a>实验四：特殊值处理</h3><h3 id="实验五：为对象类型属性赋值"><a href="#实验五：为对象类型属性赋值" class="headerlink" title="实验五：为对象类型属性赋值"></a>实验五：为对象类型属性赋值</h3><h3 id="实验六：为数组类型属性赋值"><a href="#实验六：为数组类型属性赋值" class="headerlink" title="实验六：为数组类型属性赋值"></a>实验六：为数组类型属性赋值</h3><h3 id="实验七：为集合类型属性赋值"><a href="#实验七：为集合类型属性赋值" class="headerlink" title="实验七：为集合类型属性赋值"></a>实验七：为集合类型属性赋值</h3><h3 id="实验八：p命名空间"><a href="#实验八：p命名空间" class="headerlink" title="实验八：p命名空间"></a>实验八：p命名空间</h3><h3 id="实验九：引入外部属性文件"><a href="#实验九：引入外部属性文件" class="headerlink" title="实验九：引入外部属性文件"></a>实验九：引入外部属性文件</h3><h3 id="实验十：bean的作用域"><a href="#实验十：bean的作用域" class="headerlink" title="实验十：bean的作用域"></a>实验十：bean的作用域</h3><h3 id="实验十一：bean生命周期"><a href="#实验十一：bean生命周期" class="headerlink" title="实验十一：bean生命周期"></a>实验十一：bean生命周期</h3><h3 id="实验十二：FactoryBean"><a href="#实验十二：FactoryBean" class="headerlink" title="实验十二：FactoryBean"></a>实验十二：FactoryBean</h3><h3 id="实验十三：基于xml自动装配"><a href="#实验十三：基于xml自动装配" class="headerlink" title="实验十三：基于xml自动装配"></a>实验十三：基于xml自动装配</h3><h2 id="基于注解管理bean"><a href="#基于注解管理bean" class="headerlink" title="基于注解管理bean"></a>基于注解管理bean</h2><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Spring框架的IOC是基于Java反射机制实现的</p>
<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为<code>Java</code>语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。<br>要想解剖一个类，必须先要<strong>获取到该类的Class对象</strong>。而剖析一个类或用反射解决具体的问题就是使用相关API<strong>（1）java.lang.Class（2）java.lang.reflect</strong>，所以，<strong>Class对象是反射的根源</strong>。<br><strong>自定义类</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法-run.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get和set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>编写测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取Class对象多种方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Car.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 对象.getClass()</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>().getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 Class.forName(&quot;全路径&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.Car&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)clazz3.getConstructor().newInstance();</span><br><span class="line">        System.out.println(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取构造方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br><span class="line">        <span class="comment">//获取所有构造</span></span><br><span class="line">        <span class="comment">// getConstructors()获取所有public的构造方法</span></span><br><span class="line"><span class="comment">//        Constructor[] constructors = clazz.getConstructors();</span></span><br><span class="line">        <span class="comment">// getDeclaredConstructors()获取所有的构造方法public  private</span></span><br><span class="line">        Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c:constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法名称：&quot;</span>+c.getName()+<span class="string">&quot; 参数个数：&quot;</span>+c.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定有参数构造创建对象</span></span><br><span class="line">        <span class="comment">//1 构造public</span></span><br><span class="line"><span class="comment">//        Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);</span></span><br><span class="line"><span class="comment">//        Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(car1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 构造private</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class, String.class);</span><br><span class="line">        c2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> (Car)c2.newInstance(<span class="string">&quot;捷达&quot;</span>, <span class="number">15</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        System.out.println(car2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、获取属性</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//获取所有public属性</span></span><br><span class="line">        <span class="comment">//Field[] fields = clazz.getFields();</span></span><br><span class="line">        <span class="comment">//获取所有属性（包含私有属性）</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field:fields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.getName().equals(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//设置允许访问</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                field.set(car,<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">                System.out.println(car);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、获取方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奔驰&quot;</span>,<span class="number">10</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> car.getClass();</span><br><span class="line">        <span class="comment">//1 public方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m1:methods) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(m1.getName());</span></span><br><span class="line">            <span class="comment">//执行方法 toString</span></span><br><span class="line">            <span class="keyword">if</span>(m1.getName().equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">invoke</span> <span class="operator">=</span> (String)m1.invoke(car);</span><br><span class="line">                <span class="comment">//System.out.println(&quot;toString执行了：&quot;+invoke);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 private方法</span></span><br><span class="line">        Method[] methodsAll = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methodsAll) &#123;</span><br><span class="line">            <span class="comment">//执行方法 run</span></span><br><span class="line">            <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;run&quot;</span>)) &#123;</span><br><span class="line">                m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                m.invoke(car);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Spring的IoC"><a href="#实现Spring的IoC" class="headerlink" title="实现Spring的IoC"></a>实现Spring的IoC</h2><p>IoC（控制反转）和DI（依赖注入）是Spring里面核心的东西</p>
<p><strong>①搭建子模块</strong></p>
<p>搭建模块：guigu-spring，搭建方式如其他spring子模块</p>
<p><strong>②准备测试需要的bean</strong></p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.test.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建UserDaoImpl实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.test.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建UserService接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建UserServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.test.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private UserDao userDao;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//userDao.print();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>③定义注解</strong></p>
<p>我们通过注解的形式加载bean与实现依赖注入</p>
<p>bean注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖注入注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Di &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：上面两个注解可以随意取名</p>
<p><strong>④定义bean容器接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑤编写注解bean容器接口实现</strong></p>
<p>AnnotationApplicationContext基于注解扫描bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储bean的容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据包扫描加载bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑥编写扫描bean逻辑</strong></p>
<p>我们通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储bean的容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据包扫描加载bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageDirName</span> <span class="operator">=</span> basePackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName);</span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> dirs.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                rootPath = filePath.substring(<span class="number">0</span>, filePath.length()-packageDirName.length());</span><br><span class="line">                loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File fileParent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileParent.isDirectory()) &#123;</span><br><span class="line">            File[] childrenFiles = fileParent.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(childrenFiles == <span class="literal">null</span> || childrenFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (File child : childrenFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//如果是个文件夹就继续调用该方法,使用了递归</span></span><br><span class="line">                    loadBean(child);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//通过文件路径转变成全类名,第一步把绝对路径部分去掉</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> child.getAbsolutePath().substring(rootPath.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//选中class文件</span></span><br><span class="line">                    <span class="keyword">if</span> (pathWithClass.contains(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//    com.xinzhi.dao.UserDao</span></span><br><span class="line">                        <span class="comment">//去掉.class后缀，并且把 \ 替换成 .</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> pathWithClass.replaceAll(<span class="string">&quot;\\\\&quot;</span>, <span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Class&lt;?&gt; aClass = Class.forName(fullName);</span><br><span class="line">                            <span class="comment">//把非接口的类实例化放在map中</span></span><br><span class="line">                            <span class="keyword">if</span>(!aClass.isInterface())&#123;</span><br><span class="line">                                <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> aClass.getAnnotation(Bean.class);</span><br><span class="line">                                <span class="keyword">if</span>(annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">                                    <span class="comment">//判断一下有没有接口</span></span><br><span class="line">                                    <span class="keyword">if</span>(aClass.getInterfaces().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把接口的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getInterfaces()[<span class="number">0</span>] +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass.getInterfaces()[<span class="number">0</span>], instance);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把自己的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getName() +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass, instance);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑦java类标识Bean注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> </span><br></pre></td></tr></table></figure>
<p><strong>⑧测试Bean加载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.AnnotationApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.test.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringIocTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIoc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationApplicationContext</span>(<span class="string">&quot;com.atguigu.spring.test&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)applicationContext.getBean(UserService.class);</span><br><span class="line">        userService.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;run success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印测试</p>
<p><strong>⑨依赖注入</strong></p>
<p>只要userDao.print();调用成功，说明就注入成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.test.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Di;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Di</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行第八步：报错了，说明当前userDao是个空对象</p>
<p><strong>⑩依赖注入实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Di;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储bean的容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据包扫描加载bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageDirName</span> <span class="operator">=</span> basePackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName);</span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> dirs.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                rootPath = filePath.substring(<span class="number">0</span>, filePath.length()-packageDirName.length());</span><br><span class="line">                loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//依赖注入</span></span><br><span class="line">        loadDi();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File fileParent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileParent.isDirectory()) &#123;</span><br><span class="line">            File[] childrenFiles = fileParent.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(childrenFiles == <span class="literal">null</span> || childrenFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (File child : childrenFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//如果是个文件夹就继续调用该方法,使用了递归</span></span><br><span class="line">                    loadBean(child);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//通过文件路径转变成全类名,第一步把绝对路径部分去掉</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> child.getAbsolutePath().substring(rootPath.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//选中class文件</span></span><br><span class="line">                    <span class="keyword">if</span> (pathWithClass.contains(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//    com.xinzhi.dao.UserDao</span></span><br><span class="line">                        <span class="comment">//去掉.class后缀，并且把 \ 替换成 .</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> pathWithClass.replaceAll(<span class="string">&quot;\\\\&quot;</span>, <span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Class&lt;?&gt; aClass = Class.forName(fullName);</span><br><span class="line">                            <span class="comment">//把非接口的类实例化放在map中</span></span><br><span class="line">                            <span class="keyword">if</span>(!aClass.isInterface())&#123;</span><br><span class="line">                                <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> aClass.getAnnotation(Bean.class);</span><br><span class="line">                                <span class="keyword">if</span>(annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">                                    <span class="comment">//判断一下有没有接口</span></span><br><span class="line">                                    <span class="keyword">if</span>(aClass.getInterfaces().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把接口的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getInterfaces()[<span class="number">0</span>] +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass.getInterfaces()[<span class="number">0</span>], instance);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把自己的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getName() +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass, instance);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123;</span><br><span class="line">            <span class="comment">//就是咱们放在容器的对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">            Field[] declaredFields = aClass.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : declaredFields)&#123;</span><br><span class="line">                <span class="type">Di</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Di.class);</span><br><span class="line">                <span class="keyword">if</span>( annotation != <span class="literal">null</span> )&#123;</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;正在给【&quot;</span>+obj.getClass().getName()+<span class="string">&quot;】属性【&quot;</span> + field.getName() + <span class="string">&quot;】注入值【&quot;</span>+ beanFactory.get(field.getType()).getClass().getName() +<span class="string">&quot;】&quot;</span>);</span><br><span class="line">                        field.set(obj,beanFactory.get(field.getType()));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行第八步：执行成功，依赖注入成功</p>
<h1 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h1><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h1 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h1><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h1 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h1><h1 id="提前编译"><a href="#提前编译" class="headerlink" title="提前编译"></a>提前编译</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/post/d044eab7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TypeScript是JavaScript的超集，它可以编译成纯JavaScript。TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/post/f8e09374.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>axios、fetch</title>
    <url>/post/28622150.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><h2 id="XHR的Ajax封装-简单版axios"><a href="#XHR的Ajax封装-简单版axios" class="headerlink" title="XHR的Ajax封装 (简单版axios)"></a>XHR的Ajax封装 (简单版axios)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>函数返回值是promise, 成功的结果为response, 失败的结果为error</li>
<li>能处理多种类型的请求: GET/POST/PUT/DELETE</li>
<li>函数的参数为一个配置对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 请求地址</span></span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 请求方式GET/POST/PUT/DELETE</span></span><br><span class="line">   <span class="attr">data</span>: &#123;&#125;, <span class="comment">// POST/PUT 请求的请求体参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>响应 json数据 自动解析为 js的对象/数组</li>
</ol>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">                   url,</span></span><br><span class="line"><span class="params">                   method=<span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="params">                   params=&#123;&#125;,</span></span><br><span class="line"><span class="params">                   data=&#123;&#125;</span></span><br><span class="line"><span class="params">               &#125;</span>)&#123;</span><br><span class="line">    <span class="comment">// 返回一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理method 转大写</span></span><br><span class="line">        method = method.<span class="title function_">toUpperCase</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 query参数（拼接到url上）id=1&amp;xxx=abc</span></span><br><span class="line">        <span class="keyword">let</span> queryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(params).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            queryString += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(queryString)&#123;</span><br><span class="line">            <span class="comment">// 去除最后的&#x27;&amp;&#x27;</span></span><br><span class="line">            queryString = queryString.<span class="title function_">substring</span>(<span class="number">0</span>, queryString.<span class="property">length</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 接到url</span></span><br><span class="line">            url += <span class="string">&#x27;?&#x27;</span> + queryString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 执行异步Ajax请求</span></span><br><span class="line">        <span class="comment">// 创建xhr对象</span></span><br><span class="line">        <span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="comment">// 打开连接（初始化请求，没有请求）</span></span><br><span class="line">        request.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        <span class="keyword">if</span>(method === <span class="string">&#x27;GET&#x27;</span> || method === <span class="string">&#x27;DELETE&#x27;</span>)&#123;</span><br><span class="line">            request.<span class="title function_">send</span>()<span class="comment">// undefined</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span> || method === <span class="string">&#x27;PUT&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 设置请求头，告诉服务器请求体的格式是json</span></span><br><span class="line">            request.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;appliaction/json;charset=utf-8&#x27;</span>);</span><br><span class="line">            <span class="comment">// 发送json格式请求参数</span></span><br><span class="line">            request.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)); <span class="comment">// 异步执行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定状态改变的监听</span></span><br><span class="line">        request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 同步执行</span></span><br><span class="line">            <span class="comment">// 如果请求没有完成，直接结束</span></span><br><span class="line">            <span class="keyword">if</span> (request.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果响应状态码在[200, 300)之间代表成功，否则失败</span></span><br><span class="line">            <span class="keyword">const</span> &#123;status, statusText&#125; = request</span><br><span class="line">            <span class="keyword">if</span>( status&gt;= <span class="number">200</span> &amp;&amp; status&lt;=<span class="number">299</span>) &#123;<span class="comment">// 2.1 如果请求成功，调用resolve()</span></span><br><span class="line">                <span class="comment">// 准备结果数据对象response</span></span><br><span class="line">                <span class="keyword">const</span> response = &#123;</span><br><span class="line">                    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(request.<span class="property">response</span>),</span><br><span class="line">                    status,</span><br><span class="line">                    statusText</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title function_">resolve</span>(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2.2 如果请求失败，调用reject()</span></span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;request error status is &#x27;</span> + status));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a>使用测试</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. GET请求：从服务器端获取数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testGet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">xxx</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. POST请求：向服务器端添加数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testPost</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;json-server_post&quot;</span>,</span><br><span class="line">      <span class="string">&quot;author&quot;</span>: <span class="string">&quot;typicode_post&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. PUT请求：服务器更新数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testPut</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts/1&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;json-server_put&quot;</span>,</span><br><span class="line">      <span class="string">&quot;author&quot;</span>: <span class="string">&quot;typicode_put&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. DELETE请求：服务器删除数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testDelete</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<p>特点：</p>
<ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>常用语法：</p>
<ul>
<li>axios(config): 通用/最本质的发任意类型请求的方式</li>
<li>axios(url[, config]): 可以只指定url 发get 请求</li>
<li>axios.request(config): 等同于axios(config)</li>
<li>axios.get(url[, config]): 发get 请求</li>
<li>axios.delete(url[, config]): 发delete 请求</li>
<li>axios.post(url[, data, config]): 发post 请求</li>
<li>axios.put(url[, data, config]): 发put 请求</li>
<li>axios.defaults.xxx: 请求的默认全局配置（method\baseURL\params\timeout…）</li>
<li>axios.interceptors.request.use(): 添加请求拦截器</li>
<li>axios.interceptors.response.use(): 添加响应拦截器</li>
<li>axios.create([config]): 创建一个新的axios(它没有下面的功能)</li>
<li>axios.Cancel(): 用于创建取消请求的错误对象</li>
<li>axios.CancelToken(): 用于创建取消请求的 token 对象</li>
<li>axios.isCancel(): 是否是一个取消请求的错误</li>
<li>axios.all(promises): 用于批量执行多个异步请求</li>
<li>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</li>
</ul>
<p>使用方法：</p>
<ul>
<li>GET请求<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
  也可以通过 params 对象传递参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
支持async/await<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>POST请求<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
  也可以通过 URLSearchParams 对象传递参数  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(),<span class="title function_">getUserPermissions</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> acct = results[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">const</span> perm = results[<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>基本流程</p>
<ol>
<li>配置 cancelToken 对象</li>
<li>缓存用于取消请求的 cancel 函数</li>
<li>在后面特定时机调用 cancel 函数取消请求</li>
<li>在错误回调中判断如果 error 是 cancel, 做相应处理</li>
</ol>
<p>用express先搭建一个有延迟的服务器<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cors, 允许跨域</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line"><span class="comment">// 能解析urlencode格式的post请求体参数</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>())</span><br><span class="line"><span class="comment">// 能解析json格式的请求体参数</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/products1&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>([</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;product1.1&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;product1.2&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;product1.3&#x27;</span>&#125;</span><br><span class="line">    ])</span><br><span class="line">  &#125;, <span class="number">1000</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">2000</span>);</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/products2&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>([&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;product2.1&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;product2.2&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;product2.3&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">  &#125;, <span class="number">1000</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server app start on port 4000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>点击按钮, 取消某个正在请求中的请求<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel <span class="comment">// 用于保存取消请求的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProducts1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:4000/products1&#x27;</span>,</span><br><span class="line">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>)&#123; <span class="comment">// c是用于取消当前请求的函数</span></span><br><span class="line">      <span class="comment">// 保存取消函数，用于之后可能需要取消当前请求</span></span><br><span class="line">      cancel = c;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      cancel = <span class="literal">null</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1成功了&#x27;</span>, response.<span class="property">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      cancel = <span class="literal">null</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1失败了&#x27;</span>, error.<span class="property">message</span>, error) <span class="comment">// 请求1失败了 强制取消请求 Cancel &#123;message: &quot;强制取消请求&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProducts2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:4000/products2&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求2成功了&#x27;</span>, response.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cancelReq</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// alert(&#x27;取消请求&#x27;)</span></span><br><span class="line">  <span class="comment">// 执行取消请求的函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cancel === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;强制取消请求&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有可取消的请求&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在请求一个接口前, 取消前面一个未完成的请求<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel <span class="comment">// 用于保存取消请求的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProducts1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 在准备发请求前，取消未完成的请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cancel === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;取消请求&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:4000/products1&#x27;</span>,</span><br><span class="line">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>)&#123; <span class="comment">// c是用于取消当前请求的函数</span></span><br><span class="line">      <span class="comment">// 保存取消函数，用于之后可能需要取消当前请求</span></span><br><span class="line">      cancel = c;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      cancel = <span class="literal">null</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1成功了&#x27;</span>, response.<span class="property">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error))&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1取消的错误&#x27;</span>, error.<span class="property">message</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">// 请求出错了</span></span><br><span class="line">        cancel = <span class="literal">null</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1失败了&#x27;</span>, error.<span class="property">message</span>, error) <span class="comment">// 请求1失败了 强制取消请求 Cancel &#123;message: &quot;强制取消请求&quot;&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProducts2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 在准备发请求前，取消未完成的请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cancel === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;取消请求&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:4000/products2&#x27;</span>,</span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>)&#123; </span><br><span class="line">      cancel = c;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      cancel = <span class="literal">null</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求2成功了&#x27;</span>, response.<span class="property">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error))&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求2取消的错误&#x27;</span>, error.<span class="property">message</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        cancel = <span class="literal">null</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求2失败了&#x27;</span>, error.<span class="property">message</span>, error) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cancelReq</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// alert(&#x27;取消请求&#x27;)</span></span><br><span class="line">  <span class="comment">// 执行取消请求的函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cancel === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;强制取消请求&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有可取消的请求&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用拦截器改进代码，减少重复代码<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123; <span class="comment">// 只写一个成功的回调</span></span><br><span class="line">  <span class="comment">// 在准备发请求前，取消未完成的请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cancel === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;取消请求&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个cancelToken的配置</span></span><br><span class="line">  config.<span class="property">cancelToken</span> = <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>)&#123; <span class="comment">// c是用于取消当前请求的函数</span></span><br><span class="line">      <span class="comment">// 保存取消函数，用于之后可能需要取消当前请求</span></span><br><span class="line">      cancel = c;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123; <span class="comment">// 成功的回调</span></span><br><span class="line">    cancel = <span class="literal">null</span> </span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">// 失败的回调</span></span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error))&#123; <span class="comment">// 请求取消的错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求取消的错误&#x27;</span>, error.<span class="property">message</span>)</span><br><span class="line">        <span class="comment">// 中断promise链</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 请求出错了</span></span><br><span class="line">      cancel = <span class="literal">null</span> </span><br><span class="line">      <span class="comment">// 将错误向下传递 </span></span><br><span class="line">      <span class="comment">// throw error</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cancel <span class="comment">// 用于保存取消请求的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProducts1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:4000/products1&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1成功了&#x27;</span>, response.<span class="property">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">// 只用处理请求失败的情况，取消请求的错误不用处理</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求1失败了&#x27;</span>, error.<span class="property">message</span>, error) </span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProducts2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:4000/products2&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求2成功了&#x27;</span>, response.<span class="property">data</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求2失败了&#x27;</span>, error.<span class="property">message</span>, error) </span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cancelReq</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cancel === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="string">&#x27;强制取消请求&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有可取消的请求&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>promise封装<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">        <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">instance</span>(config) <span class="comment">//本身返回一个Promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request&#x27;</span></span><br><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/home/multidata&#x27;</span>,</span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//success</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// export function request(config) &#123;</span></span><br><span class="line"><span class="comment">//   return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     // 1.创建axios的实例</span></span><br><span class="line"><span class="comment">//     const instance = axios.create(&#123;</span></span><br><span class="line"><span class="comment">//       baseURL: &#x27;http://152.136.185.210:7878/api/m5&#x27;,</span></span><br><span class="line"><span class="comment">//       timeout: 5000,</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // 发送真正的网络请求</span></span><br><span class="line"><span class="comment">//     instance(config)</span></span><br><span class="line"><span class="comment">//       .then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         resolve(res)</span></span><br><span class="line"><span class="comment">//       &#125;)</span></span><br><span class="line"><span class="comment">//       .catch(err =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         reject(err)</span></span><br><span class="line"><span class="comment">//       &#125;)&#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/home/multidata&#x27;</span>,</span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">//success</span></span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>方式二：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">config, success, failure</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  <span class="title function_">instance</span>(config)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 回调出去</span></span><br><span class="line">      <span class="title function_">success</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">failure</span>(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request&#x27;</span></span><br><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/home/multidata&#x27;</span>  <span class="comment">//config,</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;          <span class="comment">//success,</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;         <span class="comment">//failure</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>方式三：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">baseURL</span>: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">        <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    <span class="title function_">instance</span>(config.<span class="property">baseConfig</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(res);</span></span><br><span class="line">            <span class="comment">// 回调出去</span></span><br><span class="line">            config.<span class="title function_">success</span>(res);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(err);</span></span><br><span class="line">            config.<span class="title function_">failure</span>(err);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request&#x27;</span></span><br><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">baseConfig</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">failure</span>: <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="axios源码分析"><a href="#axios源码分析" class="headerlink" title="axios源码分析"></a>axios源码分析</h2><h3 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a>axios</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line">axios.<span class="property">Cancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/Cancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line">axios.<span class="property">isCancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/isCancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">spread</span> = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/spread&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">default</span> = axios</span><br></pre></td></tr></table></figure>
<h3 id="axios-create"><a href="#axios-create" class="headerlink" title="axios.create"></a>axios.create</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line">axios.<span class="property">Cancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/Cancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line">axios.<span class="property">isCancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/isCancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">spread</span> = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/spread&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个axios实例对象</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, config))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">default</span> = axios</span><br></pre></td></tr></table></figure>
<h3 id="axios-defaults"><a href="#axios-defaults" class="headerlink" title="axios.defaults"></a>axios.defaults</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line">axios.<span class="property">Cancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/Cancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line">axios.<span class="property">isCancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/isCancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">spread</span> = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/spread&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个axios实例对象</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, config))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line">axios.<span class="property">defaults</span> = &#123;</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="comment">// 请求超时时间</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// 请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="comment">// 默认请求头</span></span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">default</span> = axios</span><br></pre></td></tr></table></figure>
<h3 id="axios-get"><a href="#axios-get" class="headerlink" title="axios.get"></a>axios.get</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line">axios.<span class="property">Cancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/Cancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line">axios.<span class="property">isCancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/isCancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">spread</span> = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/spread&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个axios实例对象</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, config))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line">axios.<span class="property">defaults</span> = &#123;</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="comment">// 请求超时时间</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// 请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="comment">// 默认请求头</span></span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get请求</span></span><br><span class="line">axios.<span class="property">get</span> = <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">url, config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config || &#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">default</span> = axios</span><br></pre></td></tr></table></figure>
<h3 id="axios-post"><a href="#axios-post" class="headerlink" title="axios.post"></a>axios.post</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line">axios.<span class="property">Cancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/Cancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line">axios.<span class="property">isCancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/isCancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">spread</span> = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/spread&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个axios实例对象</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, config))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line">axios.<span class="property">defaults</span> = &#123;</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="comment">// 请求超时时间</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// 请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="comment">// 默认请求头</span></span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get请求</span></span><br><span class="line">axios.<span class="property">get</span> = <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">url, config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config || &#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line">axios.<span class="property">post</span> = <span class="keyword">function</span> <span class="title function_">post</span>(<span class="params">url, data, config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config || &#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">data</span>: data</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">default</span> = axios</span><br></pre></td></tr></table></figure>
<h3 id="axios-request"><a href="#axios-request" class="headerlink" title="axios.request"></a>axios.request</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// axios 是一个函数, 同时又是一个对象</span></span><br><span class="line">axios.<span class="property">Cancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/Cancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line">axios.<span class="property">isCancel</span> = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/isCancel&#x27;</span>)</span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">spread</span> = <span class="built_in">require</span>(<span class="string">&#x27;./helpers/spread&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个axios实例对象</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, config))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line">axios.<span class="property">defaults</span> = &#123;</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="comment">// 请求超时时间</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// 请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="comment">// 默认请求头</span></span><br><span class="line">    <span class="attr">common</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get请求</span></span><br><span class="line">axios.<span class="property">get</span> = <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">url, config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config || &#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line">axios.<span class="property">post</span> = <span class="keyword">function</span> <span class="title function_">post</span>(<span class="params">url, data, config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config || &#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">data</span>: data</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// request请求</span></span><br><span class="line">axios.<span class="property">request</span> = <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">axios</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config || &#123;&#125;, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: url,</span><br><span class="line">    <span class="attr">data</span>: data</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios</span><br><span class="line"><span class="comment">// Allow use of default import syntax in TypeScript</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">default</span> = axios</span><br></pre></td></tr></table></figure>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>fetch是一种新的网络请求方式，它是基于promise实现的，它的出现是为了替代XMLHttpRequest，它的语法比XMLHttpRequest更加简洁，而且fetch返回的是一个promise对象，这样就避免了嵌套的回调函数，使得代码更加简洁，可读性更强。<br>优点：</p>
<ol>
<li>语法简洁，更加语义化</li>
<li>基于标准Promise实现，支持async/await</li>
<li>同构方便，使用isomorphic-fetch</li>
<li>更加底层，提供的API丰富（request, response）</li>
<li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li>
</ol>
<p>缺点：</p>
<ol>
<li>兼容性不好，需要polyfill</li>
<li>默认不带cookie，需要添加配置项</li>
<li>不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li>
<li>无法原生监测请求的进度，如获取上传进度</li>
<li>fetch请求默认是不带cookie的，需要设置fetch(url, {credentials: ‘include’})</li>
</ol>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>fetch()的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。</p>
<ol>
<li>fetch()使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。 </li>
<li>fetch()采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。 </li>
<li>fetch()通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</li>
</ol>
<p>在用法上，fetch()接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">   .<span class="title function_">then</span>(...)</span><br><span class="line">   .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><br>例如：从服务器获取 JSON 数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err));</span><br></pre></td></tr></table></figure><br>fetch()接收到的response是一个 Stream 对象，response.json()是一个异步操作，取出所有内容，并将其转为 JSON 对象。</p>
<p>Promise 可以使用 await 语法改写，使得语义更清晰。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中await语句必须放在try…catch里面，这样才能捕捉异步操作中可能发生的错误。</p>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url,options).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// url ：是发送网络请求的地址</span></span><br><span class="line"><span class="comment">// options：发送请求参数,</span></span><br><span class="line"><span class="comment">//处理http响应</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//处理错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>fetch()的第一个参数是必须的，表示资源的URL地址，可以是绝对路径，也可以是相对路径。第二个参数是可选的，用来配置这个请求，可以是一个对象或者一个Request对象实例。<br>如果第二个参数是可选的，则它可以是一个函数或者一个字符串。如果第二个参数是一个函数，则相当于success回调函数，如果第二个参数是一个字符串，则相当于method。</p>
<ul>
<li>body - http请求参数</li>
<li>mode - 请求的模式 <ul>
<li>cors：默认值，允许跨域请求。 </li>
<li>same-origin：只允许同源请求。 </li>
<li>no-cors：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求。</li>
</ul>
</li>
<li>cache - 用户指定缓存。</li>
<li>method - 请求方法，默认GET</li>
<li>signal - 用于取消 fetch</li>
<li>headers - http请求头设置</li>
<li>keepalive - 用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</li>
<li>credentials -是否发送 Cookie <ul>
<li>same-origin：默认值，同源请求时发送 Cookie，跨域请求时不发送。 </li>
<li>include：不管同源请求，还是跨域请求，一律发送 Cookie。 </li>
<li>omit：一律不发送。</li>
</ul>
</li>
<li>referrer- 用于设定fetch()请求的referer标头</li>
<li>referrerPolicy- 用于设定Referer标头的规则 <ul>
<li>no-referrer-when-downgrade：默认值，总是发送Referer标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。 </li>
<li>no-referrer：不发送Referer标头。 </li>
<li>origin：Referer标头只包含域名，不包含完整的路径。 </li>
<li>origin-when-cross-origin：同源请求Referer标头包含完整的路径，跨域请求只包含域名。 </li>
<li>same-origin：跨域请求不发送Referer，同源请求发送。 </li>
<li>strict-origin：Referer标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送Referer标头。 </li>
<li>strict-origin-when-cross-origin：同源请求时Referer标头包含完整路径，跨域请求时只包含域名， </li>
<li>HTTPS 页面请求 HTTP 资源时不发送该标头。 </li>
<li>unsafe-url：不管什么情况，总是发送Referer标头。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://localhost:3000/test&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;qfc&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意<strong>Request对象的body属性</strong>，该属性支持：</p>
<ul>
<li>查询参数字符串，如’name=qfc&amp;age=18’</li>
<li>文本字符串，如’{“name”:”qfc”, “age”: 18}’</li>
<li>FormData对象</li>
<li>Blob对象</li>
<li>ReadableStream对象 </li>
<li>BufferSource对象</li>
</ul>
<h2 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h2><h3 id="Response-对象的同步属性"><a href="#Response-对象的同步属性" class="headerlink" title="Response 对象的同步属性"></a>Response 对象的同步属性</h3><p>fetch()请求成功以后，得到的是一个 Response 对象。它对应服务器的 HTTP 回应。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br></pre></td></tr></table></figure><br>Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（Headers），可以立即读取。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/readme.txt&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Response的标头信息属性：</p>
<ul>
<li>status - Response.status属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</li>
<li>statusText - Response.statusText属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回“OK”）。</li>
<li>ok - Response.ok属性返回一个布尔值，表示请求是否成功，true对应 HTTP 请求的状态码 200 到 299，false对应其他的状态码。</li>
<li>headers - 响应头</li>
<li>body - 响应体。响应体内的数据，根据类型各自处理。</li>
<li>type - 返回请求的类型。可能的值如下： <ul>
<li>basic：普通请求，即同源请求。 </li>
<li>cors：跨源请求。 </li>
<li>error：网络错误，主要用于 Service Worker。 </li>
<li>opaque：如果fetch()请求的type属性设为no-cors，就会返回这个值，详见请求部分。表示发出的是简单的跨源请求，类似<form>表单的那种跨源请求。 </form></li>
<li>opaqueredirect：如果fetch()请求的redirect属性设为manual，就会返回这个值，详见请求部分。</li>
</ul>
</li>
<li>url - Response.url属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</li>
<li>redirected - 返回一个布尔值，表示请求是否发生过跳转</li>
</ul>
<h3 id="判断请求是否成功"><a href="#判断请求是否成功" class="headerlink" title="判断请求是否成功"></a>判断请求是否成功</h3><p>fetch()发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，fetch()才会报错，其他情况都不会报错，而是认为请求成功。</p>
<p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，fetch()也不会报错（即 Promise 不会变为 rejected状态）。</p>
<p>只有通过Response.status属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功例如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://codegeex.cn&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="Response-headers"><a href="#Response-headers" class="headerlink" title="Response.headers"></a>Response.headers</h3><p>Response.headers属性返回一个 Headers 对象，包含了所有 HTTP 回应的头信息。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://codegeex.cn&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="property">headers</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br></pre></td></tr></table></figure></p>
<h3 id="读取内容的方法"><a href="#读取内容的方法" class="headerlink" title="读取内容的方法"></a>读取内容的方法</h3><p>Response 对象的主体内容，可以通过以下方法读取。</p>
<ul>
<li>Response.text()：返回一个字符串。</li>
<li>Response.json()：返回一个字符串或数组，得到的是 JSON 格式的字符串。如果没有对应的格式，则会被视为 HTML 的非格式化内容。</li>
<li>Response.blob()：返回一个二进制对象。</li>
<li>Response.formData()：返回一个 FormData 对象。</li>
<li>Response.arrayBuffer()：返回一个二进制数组。这是一个固定长度的数组，其中所有元素都是基于字节的基于数组的。如</li>
</ul>
<p>以上5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p>
<p><strong>response.text()</strong><br>response.text()可以用于获取文本数据，比如 HTML 文件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users.html&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> body = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = body</span><br></pre></td></tr></table></figure></p>
<p><strong>response.json()</strong><br>response.json()主要用于获取服务器返回的 JSON 数据，前面已经举过例子了。</p>
<p><strong>response.formData()</strong><br>response.formData()主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p>
<p><strong>response.blob()</strong><br>response.blob()用于获取二进制文件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>();</span><br><span class="line"><span class="keyword">const</span> objectURL = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">myImage.<span class="property">src</span> = objectURL;</span><br></pre></td></tr></table></figure></p>
<p><strong>response.arrayBuffer()</strong><br>response.arrayBuffer()主要用于获取流媒体文件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> audioCtx = <span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">AudioContext</span>();</span><br><span class="line"><span class="keyword">const</span> source = audioCtx.<span class="title function_">createBufferSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;song.ogg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodeData = <span class="keyword">await</span> audioCtx.<span class="title function_">decodeAudioData</span>(buffer);</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioCtx.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">loop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Response-clone"><a href="#Response-clone" class="headerlink" title="Response.clone()"></a>Response.clone()</h3><p>Response.clone()方法用于克隆一个 Response 对象，克隆以后，原始的 Response 对象将不会被消耗，可以多次使用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://codegeex.cn&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">clone</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br></pre></td></tr></table></figure></p>
<h3 id="Response-body"><a href="#Response-body" class="headerlink" title="Response.body"></a>Response.body</h3><p>Response.body属性返回一个 ReadableStream 对象，包含了响应的主体内容。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="fetch-第二个参数"><a href="#fetch-第二个参数" class="headerlink" title="fetch()第二个参数"></a>fetch()第二个参数</h2><p>fetch()的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&quot;firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br></pre></td></tr></table></figure></p>
<h2 id="fetch配置对象的完整API"><a href="#fetch配置对象的完整API" class="headerlink" title="fetch配置对象的完整API"></a>fetch配置对象的完整API</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>fetch()请求的底层用的是 Request() 对象的接口，参数完全一样，因此上面的 API 也是Request()的 API。</p>
<h2 id="取消请求-1"><a href="#取消请求-1" class="headerlink" title="取消请求"></a>取消请求</h2><p>fetch()发出的请求，可以通过 AbortController 接口的 abort()方法，被用户取消。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>,</span><br><span class="line">        <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>(); <span class="comment">// 取消</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>controller.abort()方法用于发出取消信号。这时会触发abort事件，这个事件可以监听，也可以通过controller.signal.aborted属性判断取消信号是否已经发出。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/long-operation&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> == <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Aborted!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js</title>
    <url>/post/bbc04bb4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O的模型，使其轻量又高效。Node.js 的包管理工具 npm 是全球最大的开源库生态系统。<br>Node.js 不是一门语言，也不是 JavaScript 的框架，也不是像Nginx一样的Web服务器 ，Node.js 是 JavaScript 在服务器端的运行环境（平台）</p>
<p>组成：<br>ECMAScript。ECMAScript 的所有语法在 Node 环境中都可以使用。<br>Node 环境提供的一些附加 API(包括文件、网络等相关的 API)。</p>
<p>特点：</p>
<ul>
<li>异步、非阻塞 IO 模型 </li>
<li>事件循环 </li>
<li>单线程</li>
</ul>
<p>应用：</p>
<ol>
<li>BFF中间层<br>BFF，即 Backend For Frontend（服务于前端的后端）。BFF 模式下，整体分工很清晰，后端通过 Java/C++ 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。<br>在 Web 服务里，搭建一个中间层，前端访问中间层的接口，中间层再访问后台的 Java/C++ 服务。这类服务的特点是不需要太强的服务器运算能力，但对程序的灵活性有较高的要求。这两个特点，正好和 Node.js 的优势相吻合。Node.js 非常适合用来做 BFF 层，优势如下： <ul>
<li>前端：让前端有能力自由组装后台数据，这样可以减少大量的业务沟通成本，加快业务的迭代速度；并且，前端同学能够自主决定与后台的通讯方式。</li>
<li>后台和运维：安全性（不会把主服务器暴露在外面）、降低主服务器的复杂度等。</li>
</ul>
</li>
<li>服务器渲染<br>客户端渲染（CSR / Client side render）：前端通过一大堆接口请求数据，然后通过 JS 动态处理和生成页面结构和展示。优点是前后端分离、减小服务器压力、局部刷新。缺点是不利于 SEO（如果你的页面然后通过 Ajax 异步获取内容，抓取工具并不会等待异步完成后再行抓取页面内容）、首屏渲染慢。<br>服务端渲染（SSR / Server Side Render）：服务器返回的不是接口数据，而是一整个页面（或整个楼层）的 HTML 字符串，浏览器直接显示即可。也就是说，在服务器端直接就渲染好了，然后一次性打包返回给前端。优点是有利于 SEO、首屏渲染很快。<br>Vue服务端渲染的概念<br><a href="https://blog.csdn.net/u012036171/article/details/88833200">https://blog.csdn.net/u012036171/article/details/88833200</a><br><a href="https://juejin.im/post/5c068fd8f265da61524d2abc">https://juejin.im/post/5c068fd8f265da61524d2abc</a></li>
<li><p>做小型服务、小型网站的后端（基于Express、Koa框架）</p>
</li>
<li><p>做项目构建工具<br>构建工具gulp、Webpack，就是基于Node.js来实现的</p>
</li>
<li>做PC客户端软件（基于Electron框架）<br>Electron 框架就是基于 Node.js 的，可以用来开发客户端软件。</li>
<li>知名度较高的 Node.js 开源项目<br>express：Node.js 中著名的 web 服务框架。<br>Koa：下一代的 Node.js 的 Web 服务框架。所谓的“下一代”是相对于 Express 而言的。<br>Egg：2016 年，阿里巴巴研发了知名的 Egg.js 开源项目，号称企业级 Web 服务框架。Egg.js 是基于 Koa 开发的。<br>mocha：是现在最流行的 JavaScript 测试框架，在浏览器和 Node 环境都可以使用。<br>PM2：node 多进程管理。<br>jade：非常优秀的模板引擎，不仅限于 js 语言。<br>CoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。<br>Atom：编辑器。<br>VS Code：最酷炫的编辑器。<br>socket.io：实时通信框架</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://nodejs.org/en">Node.js官网</a><br><a href="https://github.com/coreybutler/nvm-windows/releases">NVM</a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h1 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h1><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1>]]></content>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/post/3bf3e06d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>串、数组、广义表</title>
    <url>/post/de9add19.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础</title>
    <url>/post/3d3ed3e0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>HTML是一种超文本标记语言，是用来描述网页的一种语言。HTML不是一种编程语言，而是一种标记语言。任何人都可以使用HTML来编写网页，HTML被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS是一种样式表语言，用来描述HTML或XML（包括如SVG、MathML、XHTML等）文档的呈现。CSS描述了在屏幕、纸质、语音合成器等其它媒体上的元素应该如何被渲染的问题。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型、多范式的动态脚本语言，支持面向对象编程、命令式编程、声明式编程范式。</p>
<h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/post/41e39f2b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/post/a4d4b8b8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p>
<p>特点：</p>
<ol>
<li>易于学习</li>
<li>易于阅读</li>
<li>易于维护</li>
<li>一个广泛的标准库</li>
<li>互动模式</li>
<li>可移植</li>
<li>可扩展</li>
<li>数据库</li>
<li>GUI编程</li>
<li>可嵌入</li>
</ol>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Anaconda<br>pycharm</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>Python基本数据类型一般分为6种：数值（Numbers）、字符串（String）、列表（List）、元组（Tuple）、字典（Dictionary）、集合（Set）</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Python语言支持以下类型的运算符:<br>算术运算符<br>比较（关系）运算符<br>赋值运算符<br>逻辑运算符<br>位运算符<br>成员运算符<br>身份运算符<br>运算符优先级</p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>in：如果在指定的序列中找到值返回 True，否则返回 False。<br>not in：如果在指定的序列中没有找到值返回 True，否则返回 False。</p>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>is：判断两个标识符是不是引用自一个对象<br>is not：判断两个标识符是不是引用自不同对象</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:</span><br><span class="line">   statements(s)</span><br></pre></td></tr></table></figure>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>空心等边三角形<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入列数： &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印空心等边三角形，这里去掉if-else条件判断就是实心的&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, rows + <span class="number">1</span>):<span class="comment">#变量i控制行数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, rows - i):<span class="comment">#(1,rows-i)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span> * i - <span class="number">1</span>):<span class="comment">#(1,2*i)</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">2</span> * i - <span class="number">2</span> <span class="keyword">or</span> i == rows:</span><br><span class="line">            <span class="keyword">if</span> i == rows:</span><br><span class="line">                <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:<span class="comment">#因为第一个数是从0开始的，所以要是偶数打印*，奇数打印空格</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)<span class="comment">#注意这里的&quot;, end=&#x27;&#x27; &quot;，一定不能省略，可以起到不换行的作用</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>菱形<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入列数： &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;打印空心等菱形，这里去掉if-else条件判断就是实心的&quot;</span>)</span><br><span class="line"></span><br><span class="line">rows = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入列数： &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):<span class="comment">#变量i控制行数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rows - i):<span class="comment">#(1,rows-i)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * i - <span class="number">1</span>):<span class="comment">#(1,2*i)</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">2</span> * i - <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="comment">#菱形的下半部分</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):<span class="comment">#(1,rows-i)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * (rows - i) - <span class="number">1</span>):<span class="comment">#(1,2*i)</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">2</span> * (rows - i) - <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>continue 用于跳过该次循环<br>break 用于退出循环</p>
<h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>pass 是空语句，不做任何事情，一般用做占位语句，是为了保持程序结构的完整</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。Python 访问子字符串，可以使用方括号配合索引来进行字符串切片。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数列表）:</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>可更改(mutable)与不可更改(immutable)对象<br>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><strong>不可变类型：</strong>变量赋值 a=10 后再赋值 a=5，这里实际是新生成一个 int 值对象 5，再让 a 指向它，而 10 被丢弃，不是改变 a 的值，相当于新生成了 a。</li>
<li><strong>可变类型：</strong>变量赋值 l=[1,2,3,4] 后再赋值 l[2]=5 则是将 list l 的第三个元素值更改，本身l没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 func(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 func(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li>
<li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 func(l)，则是将 l 真正的传过去，修改后 func 外部的 l 也会受影响</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>通过 id() 函数来查看内存地址变化<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_change</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 指向的是同一个对象</span></span><br><span class="line">    a=<span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 一个新对象</span></span><br><span class="line"> </span><br><span class="line">a=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">my_change(a)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_list</span>(<span class="params"> mylist </span>):</span><br><span class="line">   <span class="string">&quot;修改传入的列表&quot;</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;函数内取值: &quot;</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">change_list( mylist )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;函数外取值: &quot;</span>, mylist)</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="必须参数"><a href="#必须参数" class="headerlink" title="必须参数"></a>必须参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。</p>
<h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure></p>
<p>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params"> arg1, *vartuple </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(arg1)</span><br><span class="line">   <span class="built_in">print</span>(vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用print_info 函数</span></span><br><span class="line">print_info( <span class="number">100</span>, <span class="number">90</span>, <span class="number">80</span> )</span><br></pre></td></tr></table></figure><br>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。</p>
<p>加了两个星号 ** 的参数会以字典的形式导入。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">[formal_args,] **var_args_dict </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(arg1)</span><br><span class="line">   <span class="built_in">print</span>(vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用print_info 函数</span></span><br><span class="line">print_info(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>python 使用 lambda 来创建匿名函数。所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p>
<ul>
<li>lambda 只是一个表达式，函数体比 def 简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<p>语法：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure></p>
<h3 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h3><p>Python3.8+ 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>序列是Python中最基本和常见的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。序列都可以进行的操作包括索引，切片，加，乘，检查成员。</p>
<p>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型。</p>
<p>+号用于组合列表，*号用于重复列表。</p>
<p>list.append(obj)在列表末尾添加新的对象<br>list.count(obj)统计某个元素在列表中出现的次数<br>list.extend(seq)在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）<br>list.index(obj)从列表中找出某个值第一个匹配项的索引位置<br>list.insert(index, obj)将对象插入列表<br>list.pop([index=-1])移除列表中的一个元素（默认最后一个元素），并且返回该元素的值<br>list.remove(obj)移除列表中某个值的第一个匹配项<br>list.reverse()反向列表中元素<br>list.sort(cmp=None, key=None, reverse=False)对原列表进行排序</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）是一个无序的不重复元素序列。</p>
<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<p>创建格式：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s.add(x)</span><br><span class="line">或者</span><br><span class="line">s.update(x)</span><br></pre></td></tr></table></figure>
<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s.remove(x)</span><br><span class="line">或者</span><br><span class="line">s.discard(x)</span><br></pre></td></tr></table></figure>
<p>set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s.pop()</span><br></pre></td></tr></table></figure></p>
<h4 id="计算集合元素个数"><a href="#计算集合元素个数" class="headerlink" title="计算集合元素个数"></a>计算集合元素个数</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>
<h4 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>
<h4 id="判断元素是否在集合中存在"><a href="#判断元素是否在集合中存在" class="headerlink" title="判断元素是否在集合中存在"></a>判断元素是否在集合中存在</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure>
<h4 id="集合内置方法完整列表"><a href="#集合内置方法完整列表" class="headerlink" title="集合内置方法完整列表"></a>集合内置方法完整列表</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add()</td>
<td style="text-align:left">为集合添加元素</td>
</tr>
<tr>
<td style="text-align:left">clear()</td>
<td style="text-align:left">移除集合中的所有元素</td>
</tr>
<tr>
<td style="text-align:left">copy()</td>
<td style="text-align:left">拷贝一个集合</td>
</tr>
<tr>
<td style="text-align:left">difference()</td>
<td style="text-align:left">返回多个集合的差集</td>
</tr>
<tr>
<td style="text-align:left">difference_update()</td>
<td style="text-align:left">移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td style="text-align:left">discard()</td>
<td style="text-align:left">删除集合中指定的元素</td>
</tr>
<tr>
<td style="text-align:left">intersection()</td>
<td style="text-align:left">返回集合的交集</td>
</tr>
<tr>
<td style="text-align:left">intersection_update()</td>
<td style="text-align:left">返回集合的交集。、</td>
</tr>
<tr>
<td style="text-align:left">isdisjoint()</td>
<td style="text-align:left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td style="text-align:left">issubset()</td>
<td style="text-align:left">判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td style="text-align:left">issuperset()</td>
<td style="text-align:left">判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td style="text-align:left">pop()</td>
<td style="text-align:left">随机移除元素</td>
</tr>
<tr>
<td style="text-align:left">remove()</td>
<td style="text-align:left">移除指定元素</td>
</tr>
<tr>
<td style="text-align:left">symmetric_difference()</td>
<td style="text-align:left">返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td style="text-align:left">symmetric_difference_update()</td>
<td style="text-align:left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td style="text-align:left">union()</td>
<td style="text-align:left">返回两个集合的并集</td>
</tr>
<tr>
<td style="text-align:left">update()</td>
<td style="text-align:left">给集合添加元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号，列表使用方括号。</p>
<p>元组创建很只需要在括号中添加元素，并使用逗号隔开即可。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span><br><span class="line">tup3 = <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span></span><br><span class="line">tup4 = (<span class="number">50</span>,)<span class="comment">#元组中只包含一个元素时，需要在元素后面添加逗号</span></span><br><span class="line">tup5 = ()<span class="comment">#创建空元组</span></span><br></pre></td></tr></table></figure></p>
<p>访问元组：使用下标索引来访问元组中的值<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup1 = [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ShowMeAI&#x27;</span>, <span class="number">1997</span>, <span class="number">2022</span>]</span><br><span class="line">tup2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tup1[0]: &quot;</span>, tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tup2[1:5]: &quot;</span>, tup2[<span class="number">1</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure></p>
<p>修改元组：元组中的元素值是不允许修改的，但我们可以对元组进行连接组合<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup3)</span><br></pre></td></tr></table></figure></p>
<p>删除元组：元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ShowMeAI&#x27;</span>, <span class="number">1997</span>, <span class="number">2022</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"><span class="keyword">del</span> tup</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除tup后 : &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure></p>
<p>无关闭分隔符：任意无符号的对象，以逗号隔开，默认为元组<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;abc&#x27;</span>, -<span class="number">4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Value of x , y : &quot;</span>, x,y)</span><br></pre></td></tr></table></figure></p>
<p>元组内置函数：</p>
<ul>
<li>cmp(tuple1, tuple2)    比较两个元组元素。</li>
<li>len(tuple)    计算元组元素个数。</li>
<li>max(tuple)    返回元组中元素最大值。</li>
<li>min(tuple)    返回元组中元素最小值。</li>
<li>tuple(seq)    将列表转换为元组。</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure><br>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>访问字典里的值：把相应的键放入到方括号中<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;ShowMeAI&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>: <span class="string">&#x27;Blue&#x27;</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dict[&#x27;Name&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dict[&#x27;Color&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Color&#x27;</span>])</span><br></pre></td></tr></table></figure></p>
<p>修改字典：向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span> <span class="comment"># 更新</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;ShowMeAI&quot;</span> <span class="comment"># 添加</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;dict[&#x27;School&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<p>删除字典元素：能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用del命令<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[<span class="string">&#x27;Name&#x27;</span>]  <span class="comment"># 删除键是&#x27;Name&#x27;的条目</span></span><br><span class="line"><span class="built_in">dict</span>.clear()      <span class="comment"># 清空字典所有条目</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>          <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dict[&#x27;Age&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;Age&#x27;</span>] )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dict[&#x27;School&#x27;]: &quot;</span>, <span class="built_in">dict</span>[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure></p>
<p><strong>字典键的特性</strong><br>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<ul>
<li>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</li>
<li>键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</li>
</ul>
<p>字典内置函数&amp;方法：</p>
<ul>
<li>函数<ul>
<li>cmp(dict1, dict2)    比较两个字典元素。</li>
<li>len(dict)    计算字典元素个数，即键的总数。</li>
<li>str(dict)    输出字典可打印的字符串表示。</li>
<li>type(variable)    返回输入的变量类型，如果变量是字典就返回字典类型。</li>
</ul>
</li>
<li>方法<ul>
<li>dict.clear()    删除字典内所有元素</li>
<li>dict.copy()    返回一个字典的浅复制</li>
<li>dict.fromkeys(seq[, val])    创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</li>
<li>dict.get(key, default=None)    返回指定键的值，如果值不在字典中返回default值</li>
<li>dict.has_key(key)    如果键在字典dict里返回true，否则返回false</li>
<li>dict.items()    以列表返回可遍历的(键, 值) 元组数组</li>
<li>dict.keys()    以列表返回一个字典所有的键</li>
<li>dict.setdefault(key, default=None)    和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</li>
<li>dict.update(dict2)    把字典dict2的键/值对更新到dict里</li>
<li>dict.values()    以列表返回字典中的所有值</li>
<li>pop(key[,default])    删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</li>
<li>popitem()    返回并删除字典中的最后一对键和值。</li>
</ul>
</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：iter() 和 next()。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素2</span></span><br></pre></td></tr></table></figure></p>
<p>迭代器对象可以使用常规for语句进行遍历：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>也可以使用 next() 函数：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></p>
<p>创建一个迭代器<br>把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 。</p>
<p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 init(), 它会在对象初始化的时候执行。</p>
<p>iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">num_class = IterNumbers()</span><br><span class="line">iter_num = <span class="built_in">iter</span>(num_class)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(iter_num))</span><br></pre></td></tr></table></figure></p>
<p><strong>StopIteration</strong></p>
<p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IterNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">10</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">num_class = IterNumbers()</span><br><span class="line">iter_num = <span class="built_in">iter</span>(num_class)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> iter_num:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>): <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Python中，一个.py文件就称之为一个模块（Module）。<br>使用模块可以大大提高了代码的可维护性，而且当一个模块编写完毕，就可以被其他地方引用。我们在使用python完成很多复杂工作时，也经常引用其他第3方模块，受益于强大的python社区，几乎我们完成任何一项任务，都可以有对应的方便快捷可引用的库和模块来协助。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，以.py后缀结尾。模块可以被别的程序引入和使用其中的函数功能。</p>
<h3 id="模块的使用"><a href="#模块的使用" class="headerlink" title="模块的使用"></a>模块的使用</h3><p>使用模块有以下几种方法：</p>
<ul>
<li>import module1[, module2[,… moduleN]</li>
<li>from modname import name1[, name2[, … nameN]]</li>
<li>from modname import *</li>
<li>import modname as name</li>
<li>from modname import name as name</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>在磁盘上读写文件的功能都是由操作系统提供的，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3e8e16a04d34fa5bae4cfb68885e46b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?imageView2/2/w/800/q/85" alt></p>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>Python内置了open()函数，用于对文件进行读写操作。使用open()方法操作文件就像把大象塞进冰箱一样，可以分3步走，一是打开文件，二是操作文件，三是关闭文件。<br>open()方法的返回值是一个file对象，可以将它赋值给一个变量（文件句柄）。基本语法格式为:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(filename, mode)</span><br></pre></td></tr></table></figure><br>其中，filename是文件名，mode是打开文件的模式，常用的模式有：</p>
<ul>
<li>r，只读模式（默认）。</li>
<li>w，只写模式。【不可读；不存在则创建；存在则删除内容；】</li>
<li>a，追加模式。【可读；   不存在则创建；存在则只追加内容；】</li>
<li>“+” 表示可以同时读写某个文件</li>
<li>“b”表示以二进制模式打开文件</li>
<li>“t”表示以文本模式打开（默认）</li>
<li>“x”：创建一个新文件，如果文件已存在则返回异常</li>
</ul>
<p><strong>b模式</strong><br>二进制模式，通常用来读取图片、视频等二进制文件。注意，它在读写的时候是以bytes类型读写的，因此获得的是一个bytes对象而不是字符串。在这个读写过程中，需要自己指定编码格式。在使用带b的模式时一定要注意传入的数据类型，确保为bytes类型。</p>
<p><strong>+模式</strong><br>对于w+模式，在读写之前都会清空文件的内容，建议不要使用！</p>
<p>对于a+模式，永远只能在文件的末尾写入，有局限性，建议不要使用！</p>
<p>对于r+模式，也就是读写模式，配合seek()和tell()方法，可以实现更多操作。</p>
<h4 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h4><p>要读取非UTF-8编码的文件，需要给open()函数传入encoding参数</p>
<p>遇到有些编码不规范的文件，可能会抛出UnicodeDecodeError异常，这表示在文件中可能夹杂了一些非法编码的字符。遇到这种情况，可以提供errors参数，表示如果遇到编码错误后如何处理。</p>
<h4 id="文件对象操作"><a href="#文件对象操作" class="headerlink" title="文件对象操作"></a>文件对象操作</h4><h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><p>read()方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。</p>
<p>读取一定大小的数据, 然后作为字符串或字节对象返回。size是一个可选的数字类型的参数，用于指定读取的数据量。当size被忽略了或者为负值，那么该文件的所有内容都将被读取并且返回。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p>
<h5 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h5><p>readline()方法用于从文件读取整行，包括 “\n” 字符。如果返回一个空字符串，说明已经已经读取到最后一行。这种方法，通常是读一行，处理一行，并且不能回头。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.readline()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p>
<h5 id="readlines"><a href="#readlines" class="headerlink" title="readlines()"></a>readlines()</h5><p>readlines()方法用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 for… in … 结构进行处理。如果碰到结束符 EOF 则返回空字符串。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p>
<h5 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h5><p>write()方法用于向文件中写入指定字符串，返回的是写入的字符长度。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">num = f.write( <span class="string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p>
<h5 id="writelines"><a href="#writelines" class="headerlink" title="writelines()"></a>writelines()</h5><p>writelines()方法用于向文件中写入一序列的字符串。这一序列字符串可以是由迭代对象产生的，如一个字符串列表。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">seq = [<span class="string">&#x27;菜鸟教程 1\n&#x27;</span>, <span class="string">&#x27;菜鸟教程 2&#x27;</span>]</span><br><span class="line">f.writelines( seq )</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p>
<h5 id="tell"><a href="#tell" class="headerlink" title="tell()"></a>tell()</h5><p>返回文件读写指针当前所处的位置,它是从文件开头开始算起的字节数。</p>
<h5 id="seek"><a href="#seek" class="headerlink" title="seek()"></a>seek()</h5><p>如果要改变位置指针的位置, 可以使用f.seek(offset, from_what)方法。seek()经常和tell()方法配合使用。<br><strong>from_what</strong>的值，如果是0表示从文件开头计算，如果是1表示从文件读写指针的当前位置开始计算，2表示从文件的结尾开始计算，默认为0，例如：<br>offset：表示偏移量。</p>
<p>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符<br>seek(x,1) ： 表示从当前位置往后移动x个字符<br>seek(-x,2)：表示从文件的结尾往前移动x个字符</p>
<h5 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h5><p>关闭文件对象。当处理完一个文件后，调用f.close()来关闭文件并释放系统的资源。文件关闭后，如果尝试再次调用该文件对象，则会抛出异常。如果忘记调用close()，可能会导致只写了一部分数据到磁盘而丢失其他的内容。</p>
<h5 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h5><p>如果文件很小，read()一次性读取最方便。<br>如果不能确定文件大小，反复调用read(size)比较保险。<br>如果是配置文件，调用readlines()最方便。<br>普通情况，使用for循环更好，速度更快。</p>
<h4 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h4><p>with关键字用于Python的上下文管理器机制。为了防止诸如open这一类文件打开方法在操作过程出现异常或错误，或者最后忘了执行close方法，文件非正常关闭等可能导致文件泄露、破坏的问题。Python提供了with这个上下文管理器机制，保证文件会被正常关闭。在它的管理下，不需要再写close语句。注意缩进。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;log1&#x27;</span>) <span class="keyword">as</span> obj1, <span class="built_in">open</span>(<span class="string">&#x27;log2&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> obj2:</span><br><span class="line">    s=obj1.read()</span><br><span class="line">    obj2.write(s)</span><br></pre></td></tr></table></figure></p>
<h2 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h2><p>在实际开发中，经常需要对文件、目录进行操作，比如新建、删除、重命名、遍历目录等操作。Python的os模块提供了非常丰富的方法用来处理文件和目录。常见的操作整理如下：</p>
<ul>
<li>文件夹操作：包括文件夹的创建、修改（改名/移动），查询（查看、遍历）、删除等。</li>
<li>文件操作：包括文件的创建、修改、读取、删除等。</li>
<li>路径操作：文件夹或文件的路径操作，如绝对路径，文件名与路径分割，扩展名分割等</li>
</ul>
<p>要完成文件与目录的操作，首先导入对应的os模块，<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure></p>
<h4 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h4><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>查询操作<br>open/read/close ：文件读取<br>stat ：文件信息<br>注意 open/read/close 需要一起操作，其中 open 操作需要指定模式，上述是以读写模式打开文件，若文件不存在则创建文件。各模式具体如下：<br>flags — 该参数可以是以下选项，多个使用 “|” 隔开：</p>
<ul>
<li>os.O_RDONLY: 以只读的方式打开</li>
<li>os.O_WRONLY: 以只写的方式打开</li>
<li>os.O_RDWR : 以读写的方式打开</li>
<li>os.O_NONBLOCK: 打开时不阻塞</li>
<li>os.O_APPEND: 以追加的方式打开</li>
<li>os.O_CREAT: 创建并打开一个新文件</li>
<li>os.O_TRUNC: 打开一个文件并截断它的长度为零（必须有写权限）</li>
<li>os.O_EXCL: 如果指定的文件存在，返回错误</li>
<li>os.O_SHLOCK: 自动获取共享锁</li>
<li>os.O_EXLOCK: 自动获取独立锁</li>
<li>os.O_DIRECT: 消除或减少缓存效果</li>
<li>os.O_FSYNC : 同步写入</li>
<li>os.O_NOFOLLOW: 不追踪软链接</li>
</ul>
<p>创建操作<br>使用open创建文件，指定模式， 若文件不存在，则创建。</p>
<p>修改操作<br>open/write/close ：写入文件内容<br>rename，renames ： 与前面介绍的修改名称、移动操作一致。</p>
<p>删除操作<br>remove ：删除文件，<strong>注意不能删除目录（使用 rmdir/removedirs）</strong></p>
<h4 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h4><p>在使用文件或目录过程中，经常需要对文件及目录路径进行处理，因此，os 中有一个子模块 path，专门就是处理路径操作的。</p>
<ul>
<li>abspath(path)：返回path规范化的绝对路径。</li>
<li>basename(path)：返回path最后的文件名。如果path以/或\结尾，那么就会返回空值。</li>
<li>commonprefix(list)：返回list中，所有path共有的最长的路径。</li>
<li>dirname(path)：返回path的目录。其实就是os.path.split(path)的第一个元素。</li>
<li>exists(path)：如果path存在，返回True；如果path不存在，返回False。</li>
<li>expanduser(path)：把path中包含的”~”和”~user”转换成用户目录。</li>
<li>expandvars(path)：根据环境变量的值替换path中包含的”$name”和”${name}”。</li>
<li>getatime(path)：返回path所指向的文件或者目录的最后存取时间。</li>
<li>isfile/isdir ：判断是否为文件/目录</li>
<li>basename/dirname：获取路径尾部和路径头部。其实就是以路径中最后一个 / 为分割符，分为头（head） 和尾（tail）两部分，tail 是 basename 返回的内容，head 是 dirname 返回的内容。经常用于获取文件名，目录名等操作</li>
<li>join  合成路径，即把两个参数使用系统路径分割符进行连接，形成完整路径。</li>
<li>split  分割文件名和文件夹，即把 path 以最后一个斜线”/“为分隔符，切割为 head 和 tail ，以 (head, tail) 元组的形式返回。</li>
<li>splitext  分割文件名和扩展名，即把 path 以最后一个点”.”为分隔符，切割为文件名和扩展名，以 (filename, extension) 元组的形式返回。</li>
</ul>
<h4 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h4><p>批量修改文件名<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">batch_rename</span>(<span class="params">dir_path</span>):</span><br><span class="line">    itemlist = os.listdir(dir_path)</span><br><span class="line">    <span class="comment"># 获取目录文件列表</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> itemlist:</span><br><span class="line">        <span class="comment"># 连接成完整路径</span></span><br><span class="line">        item_path = os.path.join(dir_path, item)</span><br><span class="line">        <span class="built_in">print</span>(item_path)</span><br><span class="line">        <span class="comment"># 修改文件名</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(item_path):</span><br><span class="line">            splitext = os.path.splitext(item_path)</span><br><span class="line">            os.rename(item_path, splitext[<span class="number">0</span>] + <span class="string">&quot;-ShowMeAI&quot;</span> + splitext[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>遍历目录及子目录下所有指定扩展名的文件<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">walk_ext_file</span>(<span class="params">dir_path, ext_list</span>):</span><br><span class="line">   <span class="comment"># @dir_path参数：遍历的目录</span></span><br><span class="line">   <span class="comment"># @ext_list参数：拓展名列表，例[&#x27;.mp4&#x27;, &#x27;.mkv&#x27;, &#x27;.flv&#x27;]</span></span><br><span class="line">    <span class="comment"># 遍历</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path):</span><br><span class="line">        <span class="comment"># 获取文件名称及路径</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            file_path = os.path.join(root, file)</span><br><span class="line">            file_item = os.path.splitext(file_path)</span><br><span class="line">            <span class="comment"># 输出指定扩展名的文件路径</span></span><br><span class="line">            <span class="keyword">if</span> file_item[<span class="number">1</span>] <span class="keyword">in</span> ext_list:</span><br><span class="line">                <span class="built_in">print</span>(file_path)</span><br></pre></td></tr></table></figure></p>
<p>按修改时间排序指定目录下的文件<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_file_accord_to_time</span>(<span class="params">dir_path</span>):</span><br><span class="line">    <span class="comment"># 排序前</span></span><br><span class="line">    itemlist = os.listdir(dir_path)</span><br><span class="line">    <span class="built_in">print</span>(itemlist)</span><br><span class="line">    <span class="comment"># 正向排序</span></span><br><span class="line">    itemlist.sort(key=<span class="keyword">lambda</span> filename: os.path.getmtime(os.path.join(dir_path, filename)))</span><br><span class="line">    <span class="built_in">print</span>(itemlist)</span><br><span class="line">    <span class="comment"># 反向排序</span></span><br><span class="line">    itemlist.sort(key=<span class="keyword">lambda</span> filename: os.path.getmtime(os.path.join(dir_path, filename)), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(itemlist)</span><br><span class="line">    <span class="comment"># 获取最新修改的文件</span></span><br><span class="line">    <span class="built_in">print</span>(itemlist[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><h2 id="时间日期类操作"><a href="#时间日期类操作" class="headerlink" title="时间日期类操作"></a>时间日期类操作</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/post/a80d0031.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/post/4618cb0a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/post/ce5da845.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.acwing.com/">Acwing</a></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>分治</strong>：①确定分界点；②调整区间；③递归<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; = r) </span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//判断边界</span></span><br><span class="line">    <span class="type">int</span> i = l<span class="number">-1</span>; r = r+<span class="number">1</span>, x = [l+r&gt;&gt;<span class="number">1</span>];<span class="comment">//指针，分界点</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">            <span class="built_in">swap</span>(q[i], q[j]);<span class="comment">//交换两个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, i, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);<span class="comment">//注意边界问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：快速排序不稳定</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/787/">快速排序</a></strong></p>
<p>给定你一个长度为 n 的整数数列。请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。</p>
<p>输入格式<br>输入共两行，第一行包含整数 n 。第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p>
<p>输出格式<br>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<p>数据范围<br>1≤n≤100000</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>
<p>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><br>思路分析：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l<span class="number">-1</span>, j = r+<span class="number">1</span>, x = q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/description/788/">第k个数</a></strong></p>
<p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。</p>
<p>输入格式</p>
<p>第一行包含两个整数 n 和 k。</p>
<p>第二行包含 n 个整数（所有整数均在 1∼1091∼109 范围内），表示整数数列。</p>
<p>输出格式</p>
<p>输出一个整数，表示数列的第 k 小数。</p>
<p>数据范围</p>
<p>1≤n≤100000,<br>1≤k≤n</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k, q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="type">int</span> i = l<span class="number">-1</span>, j = r+<span class="number">1</span>, x = x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j-l+<span class="number">1</span> &gt;= k) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q, l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q, j+<span class="number">1</span>, r, k-(j-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>分治</strong>：①确定分界点；②递归排序；③归并，合二为一<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>归并排序稳定</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/789/">归并排序</a></strong></p>
<p>给定你一个长度为 n 的整数数列。 请你使用归并排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。</p>
<p>输入格式<br>输入共两行，第一行包含整数 n 。</p>
<p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。</p>
<p>输出格式<br>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<p>数据范围<br>1≤n≤100000</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><br>思路分析：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>本质：<strong>边界</strong></p>
<h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><span class="comment">//数组动态存储</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/793/">高精度加法</a></strong><br>思路：<br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/794/">高精度减法</a></strong><br>给定两个正整数（不含前导 0 ），计算它们的差，计算结果可能为负数。</p>
<p>输入格式<br>共两行，每行包含一个整数。</p>
<p>输出格式<br>共一行，包含所求的差。</p>
<p>数据范围<br>1≤整数长度≤105</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><br>思路：<br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/795/">高精度乘法</a></strong><br>给定两个非负整数（不含前导 0 ） A 和 B ，请你计算 A×B 的值。</p>
<p>输入格式<br>共两行，第一行包含整数 A ，第二行包含整数 B 。</p>
<p>输出格式<br>共一行，包含 A×B 的值。</p>
<p>数据范围<br>1≤A的长度≤100000 ,<br>0≤B≤10000</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;<span class="comment">//商</span></span><br><span class="line">    r = <span class="number">0</span>;<span class="comment">//初始化余数为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/796/">高精度除法</a></strong><br>给定两个非负整数（不含前导 0 ） A，B ，请你计算 A/B 的商和余数。</p>
<p>输入格式<br>共两行，第一行包含整数 A ，第二行包含整数 B 。</p>
<p>输出格式<br>共两行，第一行输出所求的商，第二行输出所求余数。</p>
<p>数据范围<br>1≤A的长度≤100000 ,<br>1≤B≤10000 ,<br>B 一定不为 0</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/797/">前缀和</a></strong><br>输入一个长度为 n 的整数序列。接下来再输入 m 个询问，每个询问输入一对 l,r 。 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<p>输入格式<br>第一行包含两个整数 n 和 m 。<br>第二行包含 n 个整数，表示整数数列。<br>接下来 m 行，每行包含两个整数 l 和 r ，表示一个询问的区间范围。</p>
<p>输出格式<br>共 m 行，每行输出一个询问的结果。</p>
<p>数据范围<br>1≤l≤r≤n ,<br>1≤n,m≤100000 ,<br>−1000≤数列中元素的值≤1000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt;a[r]-a[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/803/">二进制中1的个数</a></strong><br>给定一个长度为 n<br>的数列，请你求出数列中每个数的二进制表示中 1 的个数。</p>
<p>输入格式<br>第一行包含整数 n 。<br>第二行包含 n 个整数，表示整个数列。</p>
<p>输出格式<br>共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。<br>数据范围<br>1≤n≤100000 ,<br>0≤数列中元素的值≤109<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">        <span class="type">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= i &amp; -i)</span><br><span class="line">            s ++ ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line">**题目：</span><br><span class="line">思路：</span><br><span class="line">代码：</span><br><span class="line">~~~c++</span><br></pre></td></tr></table></figure>
<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**题目：<br>思路：<br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/post/ee040603.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h1><p>图：G=(V,E)  V:顶点（数据元素）的有穷非空集合    E:边的有穷集合</p>
<p>无向图：每条边都是无方向的</p>
<p>有向图：每条边都是有方向的</p>
<p>完全图：任意两个点都有一条边相连</p>
<p>稀疏图：如果边或弧的个数满足e &lt; n log2n</p>
<p>稠密图：</p>
<p>路径：接续的边构成的顶点序列</p>
<p>路径长度：路径上边或弧的数目/权值之和</p>
<p>回路(环)：第一个顶点和最后一个顶点相同的路径</p>
<p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径</p>
<p>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径</p>
<p>连通图(强连通图)：在无(有)向图G=(V,{E})中，若任何两个顶点v，u都存在从v到u的路径，则称G是连通图(强连通图)</p>
<p>权与网：图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网</p>
<p>子图：若有两个图G=(V,E),G1=(V1,E2)，若V1是V的子集且E2是E的子集，称G1是G的子图</p>
<h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT&#123;</span><br><span class="line">    数据对象V:;</span><br><span class="line">    数据关系R:R=&#123;VR&#125;</span><br><span class="line">    基本操作P:</span><br><span class="line">    CreatGraph(&amp;G,V,VR)</span><br><span class="line">        初始条件：V是图的顶点集，VR是图中弧的集合</span><br><span class="line">        操作结果：按V和VR的定义构造图G</span><br><span class="line">    BFSTraverse(G)</span><br><span class="line">        初始条件：图G存在</span><br><span class="line">        操作结果：对图进行深度优先遍历</span><br><span class="line">    DFSTraverse(G)</span><br><span class="line">        初始条件：图G存在</span><br><span class="line">        操作结果：对图进行广度优先遍历</span><br><span class="line">&#125;ADT Graph</span><br></pre></td></tr></table></figure>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>图的逻辑结构：多对多</p>
<p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即<strong>图没有顺序存储结构</strong>，但可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法。另一方面，由于图的任意两个顶点间都可能存在关系，因此，可以用链式存储表示图。图的链式存储有多种，有邻接表、十字链表和邻接多重表</p>
<ol>
<li><p><strong>邻接矩阵</strong></p>
<p><strong>邻接矩阵（数组）表示法</strong></p>
<p>邻接矩阵是表示顶点之间相邻关系的矩阵。设G（V，E）是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵。</p>
<p><img src="https://img-blog.csdnimg.cn/97522e6906ef4913bb0b4fcdbdcf36b9.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/079231c04e2641b78e9b8db50d9e07f4.png#pic_center" alt></p>
<p>在有向图的邻接矩阵中，</p>
<ul>
<li>第i行含义︰以结点v;为起点的边(即出度边);</li>
<li>第i列含义:以结点v;为终点的边(即入度边)。</li>
</ul>
<p>有向图的邻接矩阵可能是不对称的。</p>
<ul>
<li>顶点的出度=第i行元素之和</li>
<li>顶点的入度=第i列元素之和</li>
<li>顶点的度=第i行元素之和+第i列元素之和</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c12873e1d7794b12802953ca6dea50c1.png#pic_center" alt></p>
<p>无向图的邻接矩阵是对称的;</p>
<ul>
<li>顶点i的度=第i 行（列)中1的个数;</li>
<li>图的边数=所有非0元素之和的一半;</li>
<li>完全图的邻接矩阵中，对角元素为0，其余1。</li>
</ul>
<p>若G是网，则邻接矩阵可以定义为：</p>
<p><img src="https://img-blog.csdnimg.cn/4f0bd60aab4d459a918215b44eef9e45.png#pic_center" alt></p>
<p>其中，wi,j表示边上的权值;∞表示计算机允许的、大于所有边上权值的数。</p>
<p><img src="https://img-blog.csdnimg.cn/6fd74f7f3ea24ebbacb2d89879db1178.png#pic_center" alt></p>
</li>
</ol>
<p>邻接矩阵表示法的特点:</p>
<ul>
<li>优点:容易实现图的操作。<br>如:求某顶点的度、判断顶点之间是否有边、找顶点的邻接点…</li>
<li><p>缺点:n个顶点需要n*n个单元存储边;空间效率为O(n2)。<br>对稀疏图而言尤其浪费空间。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的邻接矩阵存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767     <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100        <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType; <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;     <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125; AMGraph;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>采用邻接矩阵表示法创建无向网：</p>
<pre><code>  1. 输入总顶点数和总边数。
  2. 依次输入点的信息存入顶点表中。
  3. 初始化邻接矩阵，使每个权值初始化为极大值。
  4. 构造邻接矩阵。依次输人每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。
</code></pre>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i];          <span class="comment">//依次输入点的信息</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = MaxInt;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)&#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);        <span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;            <span class="comment">//边&lt;v1, v2&gt;的权值置为w</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j]; <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;                                <span class="comment">// for</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// CreateUDN</span></span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度是O(n^2)。</p>
<p>若要建立无向图，只需对上述算法做两处小的改动:一是<strong>初始化邻接矩阵时，将边的权值均初始化为0</strong>;二是<strong>构造邻接矩阵时，将权值w改为常量值1</strong>即可。同样，将该算法稍做修改即可建立一个有向网或有向图</p>
<ol>
<li><p><strong>邻接表</strong></p>
<p>邻接表(Adjacency List）是图的一种链式存储结构。在邻接表中，对图中每个顶点v;建立一个单链表，把与v相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成:表头结点表和边表</p>
<p><img src="https://img-blog.csdnimg.cn/d1027b1a3cad48f6b2ec2bdfa3704b19.png#pic_center" alt></p>
<ul>
<li><p>无向图</p>
<p>无向图的边结点表示与顶点结点有边相连的关系</p>
<p><img src="https://img-blog.csdnimg.cn/534bbdd59a674d96a0049d0659f6bba5.png#pic_center" alt></p>
</li>
<li><p>有向图</p>
<p>有向图的边结点表示顶点结点为起点，有以边结点为终点的关系</p>
<p><img src="https://img-blog.csdnimg.cn/8deb9cf11caf4b97b816347b2017ecb5.png#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图的邻接表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100 <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;              <span class="comment">// 该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span> <span class="comment">// 指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;          <span class="comment">// 和边相关的信息</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;     <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *firstarc;   <span class="comment">// 指向第一条依附该顶点的边</span></span><br><span class="line">&#125; VNode, AdjList[MVNum]; <span class="comment">// AdjList表示邻接表类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;   <span class="comment">// vertices—vertex的复数</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure>
<p>特点<br>1.图的邻接表表示不为1（链表前后元素可以调换）。</p>
<p>2.对于无向图，顶点的度是链表的长度-1。</p>
</li>
</ul>
<p>3.对于有向图，顶点的出度是链表的长度-1。入度需要遍历整个邻接表。</p>
<p>4.存储空间主要与顶点数n和边数e有关，无向图空间复杂度为O（n+2e），有向图为O（n+e）。</p>
<p>5.当边数小于n（n-1）/2即有向图最多边数的一半时，就可以用三元组压缩存储</p>
<p><strong>采用邻接表表示法创建无向图</strong></p>
<ol>
<li>输人总顶点数和总边数。</li>
<li>依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li>
<li><p>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123;<span class="comment">//采用邻接表表示法，创建无向图G</span></span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入顶点数和弧数</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">          G.vertices[i].firstarc = <span class="literal">NULL</span>; <span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)&#123; <span class="comment">//输入各边，构造邻接表，头插法</span></span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2; <span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">          i = LocateVex(G, v1);</span><br><span class="line">          j = LocateVex(G, v2);</span><br><span class="line">          p1 = new ArcNode; <span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">          p1-&gt;adjvex = j;   <span class="comment">//邻接点序号为j</span></span><br><span class="line">          p1-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">          G.vertices[i].firstarc = p1;<span class="comment">//将新结点*p1插入到顶点vi的边表头部</span></span><br><span class="line">          p2 = new ArcNode;<span class="comment">//生成一个新的边结点*p2</span></span><br><span class="line">          p2-&gt;adjvex = i;<span class="comment">//邻接点序号为j</span></span><br><span class="line">          p2-&gt;nextarc = G.vertices[j].firstarc; <span class="comment">//插入弧结点到单链表</span></span><br><span class="line">          G.vertices[j].firstarc = p2;<span class="comment">//将新结点*p2插入到顶点vj的边表头部</span></span><br><span class="line">      &#125;<span class="comment">//头插法</span></span><br><span class="line">      <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其时间复杂度为O(n+e)</p>
<p>建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号<i,j>，仅需生成一个邻接点序号为j的边表结点，并将其插入到v的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</i,j></p>
<p><strong>邻接矩阵与邻接表的比较</strong>:</p>
<p><img src alt></p>
<blockquote>
<p>例题1 <img src="https://img-blog.csdnimg.cn/9d43c13493ec41bab804a3904bc51f75.png#pic_center" alt></p>
<p>例题2 <img src="https://img-blog.csdnimg.cn/5295de9604764fcf9c07dbf032b016f2.png#pic_center" alt></p>
</blockquote>
</li>
<li><p><strong>十字链表</strong></p>
<p>十字链表(Orthogonal List)是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。</p>
<p>|  名称   |               解释               |<br>   | :——-: | :———————————————: |<br>| tailvex |    指示弧尾顶点在图中的位置。    |<br>| headtex |    指示弧头顶点在图中的位置。    |<br>|  hlink  | 是指向弧头相同的下一条弧的指针。 |<br>|  tlink  | 是指向弧尾相同的下一条弧的指针。 |<br>|  Info   |       指向该弧的相关信息。       |</p>
<p><img src="https://img-blog.csdnimg.cn/3f6e27895ee541ffb35fb0ff9e26a537.png#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有向图的十字链表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> tailvex, headvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>, *<span class="title">tlink</span>;</span></span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125; ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span> <span class="comment">// ArcBox为弧结点变量</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcBox *firstin, *firstout;</span><br><span class="line">&#125; VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">// VexNode为顶点变量</span></span><br><span class="line">    VexNode xlist[MAX_VERTEX_NUM]; <span class="comment">// 表头向</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;            <span class="comment">// 有向图的当前顶点数和弧数</span></span><br><span class="line">&#125; OLGraph;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例 <img src="https://img-blog.csdnimg.cn/a6aea7ac55ed4f42bfcdb5bb37200f2a.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/a920d93055314208999e55367e9ff6e7.png#pic_center" alt></p>
</blockquote>
<p>邻接表、逆邻接表、十字链表<br>对于有向图而言，邻接表是将当前顶点走向其他顶点的路径信息存储在边表当中，既将出度信息存储于边表，所以求出度十分容易，出度就是边表中的链节个数，但是邻接表却难求出度。逆邻接表将入度信息存储于边表，所以容易求入度，但逆邻接表却难求出度。所以在我们如果需要频繁的求出度与入度的时候，就会引用——十字链表。十字链表是将邻接表与逆邻接表合二为一，易求出度也易求入度。总结如下：<br>邻接表：易求出度，不易求入度<br>逆邻接表：易求入度，不易求出度<br>十字链表：合二为一，易求出度也易求入度</p>
</li>
<li><p><strong>邻接多重表</strong></p>
<p>邻接多重表是无向图的另一种链式存储结构，由于用邻接表存储无向图时，虽然容易求出顶点和边的各种信息，但在邻接表中每一条边有两个结点，分别在第i和第j个链表中，给图的某些操作带来不便。在邻接多重表中，每一条边只有一个边结点，为有关边的处理提供了方便。</p>
<p>|    名称    |                  解释                  |<br>   | :————: | :——————————————————: |<br>|    mark    | 为标志域，可用以标记该条边是否被搜索过 |<br>| ivex和jvex |   为该边依附的两个顶点在图中的位置;    |<br>|    ilnk    |     指向下一条依附于顶点ivex的边;      |<br>|   jlink    |      指向下一条依附于顶点jvex的边      |<br>|    info    |   为指向和边相关的各种信息的指针域。   |</p>
<p><img src="https://img-blog.csdnimg.cn/1d52ad2eb0564c46af086ad8ff60083d.png#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无向图的邻接多重表存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    unvisited,</span><br><span class="line">    viseited</span><br><span class="line">&#125; ViseitIF;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VisitIf mark;               <span class="comment">//访问标志域</span></span><br><span class="line">    <span class="type">int</span> ivex, jvex;             <span class="comment">//该边依附的两个顶点在表头数组中位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span> <span class="comment">//分别指向依附于ivex和jvex的下一条边</span></span><br><span class="line">    InfoType *info;</span><br><span class="line">&#125; Ebox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexBox</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data; <span class="comment">//存与顶点有关的信息</span></span><br><span class="line">    EBox *firstedge; <span class="comment">//指向第一条依附于该顶点的边</span></span><br><span class="line">&#125; VexBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VexBox adjmulist[MAX_VERTEX_NUM]; <span class="comment">// 表头向量</span></span><br><span class="line">    <span class="type">int</span> vexnum, edgenum;              <span class="comment">// 无向图的当前顶点数和弧数</span></span><br><span class="line">&#125; AMLGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题：画出无向图G的多重邻接表<img src="https://img-blog.csdnimg.cn/c9411620611f4952a1d84b33c3bc19cf.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/a38fd52e3137451e8ffdd29969663cd1.png#pic_center" alt></p>
</blockquote>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/22495a9e70204f52bbd695cb5c10a458.png#pic_center" alt></p>
<ol>
<li><p>补充：<strong>边集数组法</strong></p>
<p>边集数组是由两个一维数组构成的，一个是存储顶点的信息；另一个存储边的信息，这个数组的元素存储边的起点，终点，权重。</p>
<p>在边集数组中要确定一个顶点的度要扫描整个边集数组，效率很低，不过边集数组可以很容易的帮助我们找到修改边的信息，显然边集数组法更适合需要对边进行处理的情况。</p>
</li>
</ol>
<p>代码汇总</p>
<p><strong>Graph.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 65535</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">//顶点的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">//边上权值的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType vexs[MAXSIZE][MAXSIZE];<span class="comment">//顶点数组</span></span><br><span class="line">	EdgeType arr[MAXSIZE][MAXSIZE];<span class="comment">//邻接矩阵 也可以用来存放权值</span></span><br><span class="line">	<span class="type">int</span> numNodes;<span class="comment">//顶点的个数</span></span><br><span class="line">	<span class="type">int</span> numEdges;<span class="comment">//边的个数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createMGraph</span><span class="params">(MGraph* G)</span>;<span class="comment">//无向网的建立</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMGraph</span><span class="params">(MGraph G)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> adjvex;<span class="comment">//确定这个点的下标</span></span><br><span class="line">	EdgeType w;<span class="comment">//储存头结点到这个结点的邻接边的权值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;EdgeNode;<span class="comment">//每个头结点的邻接链表的节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];<span class="comment">//结点名</span></span><br><span class="line">	EdgeNode* firstedgenode;<span class="comment">//指向第一个邻接点</span></span><br><span class="line">&#125;VertexNode,AdjList[MAXSIZE];</span><br><span class="line"><span class="comment">//定义结点数组的元素，并直接把大小为MAXSIZE的结点数组这种类型定义为AdjList</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList adjlist;<span class="comment">//头节点数组</span></span><br><span class="line">	<span class="type">int</span> numNode;<span class="comment">//结点个数</span></span><br><span class="line">	<span class="type">int</span> numEdge;<span class="comment">//边的个数</span></span><br><span class="line">&#125;GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAdjlistGraph</span><span class="params">(GraphAdjList* G)</span>;<span class="comment">//以邻接表法创无向权图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAdjlistGraph</span><span class="params">(GraphAdjList G)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//十字链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLarc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> startvex;<span class="comment">//弧的起点</span></span><br><span class="line">	<span class="type">int</span> endvex;<span class="comment">//弧的终点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OLarc</span>* <span class="title">nextsameSarc</span>;</span><span class="comment">//指向起点相同的下一条弧</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OLarc</span>* <span class="title">nextsameEarc</span>;</span><span class="comment">//指向终点相同的下一条弧</span></span><br><span class="line">	EdgeType w;</span><br><span class="line">&#125;OLarc;<span class="comment">//每个弧节点</span></span><br><span class="line"><span class="comment">//对每个结点，形成两个链表，一个是全部都以这个结点开头的弧的弧形成的链表，用指针nextsameSarc连起来</span></span><br><span class="line"><span class="comment">//另一个是全部都以这个结点为结尾的弧形成的链表，用指针nextsameEarc连起来。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];<span class="comment">//结点名</span></span><br><span class="line">	OLarc* firstin;<span class="comment">//指向第一个入结点弧</span></span><br><span class="line">	OLarc* firstout;<span class="comment">//指向第一个出结点弧</span></span><br><span class="line">&#125;OLNode,OList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	OList olist;</span><br><span class="line">	<span class="type">int</span> numNodes;<span class="comment">//结点数</span></span><br><span class="line">	<span class="type">int</span> numarcs;<span class="comment">//弧数</span></span><br><span class="line">&#125;OLGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createOLGraph</span><span class="params">(OLGraph* G)</span>;<span class="comment">//利用十字链表创建一个有向带权图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printOLGraph</span><span class="params">(OLGraph G)</span>;<span class="comment">//展示该图的弧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接多重表</span></span><br><span class="line"><span class="comment">//仿照十字链表的方式，对边表结点的结构进行一些改造。(不过我后面看来 这个删除操作还是很复杂= =)</span></span><br><span class="line"><span class="comment">//把邻接表中用来放边的另一端的结构体修改成如下结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMEdge</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> start;</span><br><span class="line">	<span class="type">int</span> end;<span class="comment">//用start和end表示一个边</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AMEdge</span>* <span class="title">startlink</span>;</span><span class="comment">//指向下一个依附于这个start顶点的边的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AMEdge</span>* <span class="title">endlink</span>;</span><span class="comment">//指向下一个依附于这个end顶点的边的指针</span></span><br><span class="line">&#125;AMEdge;</span><br><span class="line"><span class="comment">//这样，我们就用一个结点就表示了一个无向图中的边，而不是像邻接表法中那样对一个边用两个结点来表示它。</span></span><br><span class="line"><span class="comment">//然后仿照邻接表法构建其他的结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];<span class="comment">//结点的名字</span></span><br><span class="line">	AMEdge* pEdge;<span class="comment">//指向第一个依附于此结点的边</span></span><br><span class="line">&#125;AMvertex,AMList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AMList Amlist;</span><br><span class="line">	<span class="type">int</span> numvertex;</span><br><span class="line">	<span class="type">int</span> numedge;</span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAMGraph</span><span class="params">(AMGraph* G)</span>;<span class="comment">//创建一个无权有向图</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph G)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteEdge</span><span class="params">(AMGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边集数组法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType str[MAXSIZE];</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> start;</span><br><span class="line">	<span class="type">int</span> end;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Node vertex[MAXSIZE];</span><br><span class="line">	Edge edge[MAXSIZE];</span><br><span class="line">&#125;ESAGraph;</span><br></pre></td></tr></table></figure>
<p><strong>Graph.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createMGraph</span><span class="params">(MGraph* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入顶点数和边数,以a空格b的形式输入:&quot;</span>);</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	G-&gt;numNodes = n;</span><br><span class="line">	G-&gt;numEdges = m;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入%d个顶点\n&quot;</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;vexs[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">			G-&gt;arr[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j, w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入边(Vi,Vj)的下标(i,j)和权w，以i,j,w的形式输入:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;i, &amp;j, &amp;w);</span><br><span class="line">		G-&gt;arr[i][j] = w;</span><br><span class="line">		G-&gt;arr[j][i] = G-&gt;arr[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMGraph</span><span class="params">(MGraph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个顶点是%s\n&quot;</span>, i + <span class="number">1</span>, G.vexs[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.numNodes; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (G.arr[i][j] != INF)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;边(%s,%s)的权值是%d\n&quot;</span>, G.vexs[i], G.vexs[j], G.arr[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建邻接表</span></span><br><span class="line"><span class="comment">//在邻接表法的基础上，对每个结点，形成两个链表，一个是全部都以这个结点开头的弧的弧形成的链表，用指针nextsameSarc连起来。另一个是全部都以这个结点为结尾的弧形成的链表，用指针nextsameEarc连起来。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAdjlistGraph</span><span class="params">(GraphAdjList* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入图G的结点数和边数,以a空格b的形式输入:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;(G-&gt;numNode), &amp;(G-&gt;numEdge));</span><br><span class="line">    <span class="comment">//输入结点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numNode; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入序号为%d的结点:&quot;</span>, i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;adjlist[i].str);</span><br><span class="line">		G-&gt;adjlist[i].firstedgenode = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//输入边</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numEdge; k++)&#123;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		EdgeNode* e = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入边(vi,vj)上的序号i和j和权值w,以i,j,w的形式输入:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;i, &amp;j,&amp;(e-&gt;w));</span><br><span class="line">		e-&gt;adjvex = j;</span><br><span class="line">		<span class="comment">//头插法把e插入链表中</span></span><br><span class="line">        e-&gt;next = G-&gt;adjlist[i].firstedgenode;</span><br><span class="line">		G-&gt;adjlist[i].firstedgenode = e;</span><br><span class="line">		<span class="comment">//因为是无向图，所以要把e插入到头结点为j的链表汇总</span></span><br><span class="line">        <span class="type">int</span> tmp = e-&gt;w;</span><br><span class="line">		e= (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">		e-&gt;adjvex = i;</span><br><span class="line">		e-&gt;next = G-&gt;adjlist[j].firstedgenode;</span><br><span class="line">		G-&gt;adjlist[j].firstedgenode = e;</span><br><span class="line">		e-&gt;w = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接表法存储的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAdjlistGraph</span><span class="params">(GraphAdjList G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNode; i++)&#123;</span><br><span class="line">		EdgeNode* p = G.adjlist[i].firstedgenode;</span><br><span class="line">        <span class="comment">//遍历每个以数组元素为头结点的链表 以此来输出自己的边。</span></span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;边(%s,%s)的权值为%d\n&quot;</span>, G.adjlist[i].str, G.adjlist[p-&gt;adjvex].str, p-&gt;w);</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建十字链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createOLGraph</span><span class="params">(OLGraph* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入图的顶点个数和弧的个数，以a空格b的形式输入：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;(G-&gt;numNodes), &amp;(G-&gt;numarcs));</span><br><span class="line">    <span class="comment">//输入结点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numNodes; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入序号为%d的节点：&quot;</span>,i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;olist[i].str);</span><br><span class="line">		G-&gt;olist[i].firstin = G-&gt;olist[i].firstout = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//对每个弧(vi,vj)，利用头插法把这个弧插入到以数组中下标i对应的元素开头的相同起点链表中</span></span><br><span class="line">    <span class="comment">//利用头插法把这个弧插入到以数组中下标j对应的元素开头的相同终点链表中。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numarcs; k++)&#123;</span><br><span class="line">		OLarc* e = (OLarc*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OLarc));</span><br><span class="line">		<span class="type">int</span> i, j, w;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入弧(vi,vj)的顶点序号i和j以及它的权重w，以i,j,w形式输入&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;i, &amp;j, &amp;w);</span><br><span class="line">		e-&gt;startvex = i;</span><br><span class="line">		e-&gt;endvex = j;</span><br><span class="line">		e-&gt;w = w;</span><br><span class="line">		e-&gt;nextsameSarc = G-&gt;olist[i].firstout;</span><br><span class="line">		G-&gt;olist[i].firstout = e;</span><br><span class="line">		e-&gt;nextsameEarc = G-&gt;olist[j].firstin;</span><br><span class="line">		G-&gt;olist[j].firstin = e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印十字链表存储的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printOLGraph</span><span class="params">(OLGraph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numNodes; i++)&#123;</span><br><span class="line">		<span class="type">int</span> ID = <span class="number">0</span>;<span class="comment">//入度</span></span><br><span class="line">		<span class="type">int</span> OD = <span class="number">0</span>;<span class="comment">//出度</span></span><br><span class="line">		OLarc* p1 = G.olist[i].firstin;</span><br><span class="line">		<span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;弧&lt;%s,%s&gt;的权是%d\n&quot;, G.olist[p1-&gt;startvex].str, G.olist[i].str);</span></span><br><span class="line">			p1 = p1-&gt;nextsameEarc;</span><br><span class="line">			ID++;</span><br><span class="line">		&#125;</span><br><span class="line">		OLarc* p2 = G.olist[i].firstout;</span><br><span class="line">		<span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;弧&lt;%s,%s&gt;的权是%d\n&quot;</span>, G.olist[i].str, G.olist[p2-&gt;endvex].str,p2-&gt;w);</span><br><span class="line">			p2 = p2-&gt;nextsameSarc;</span><br><span class="line">			OD++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;结点%s的入度是%d,出度是%d\n&quot;</span>, G.olist[i].str, ID, OD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建邻接多重表</span></span><br><span class="line"><span class="comment">//这里创建的方法仿照十字链表，每输入一个边（Vi，Vj）后，利用头插法把这个边插入到以数组下标i对应的元素为头结点的链表中，并且插入i时把这个边的指向下一个依附于这个i顶点的边的指针指向链表头结点的下一个元素，然后把指向链表头结点的下一个元素的指针指向这个边；然后对以数组下标i对应的元素为头结点的链表进行同样的操作，不过要把startlink指针换成endlink指针。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createAMGraph</span><span class="params">(AMGraph* G)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入该无向图的顶点数和边数，以i空格j格式输入:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;G-&gt;numvertex, &amp;G-&gt;numedge);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numvertex; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入序号为%d的结点的名字\n&quot;</span>, i);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;Amlist[i].str);</span><br><span class="line">		G-&gt;Amlist[i].pEdge = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numedge; k++)&#123;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入边(Vi,Vj)的顶点序号i和j,以格式i,j输入:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">		AMEdge* e = (AMEdge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AMEdge));</span><br><span class="line">		e-&gt;start = i;</span><br><span class="line">		e-&gt;end = j;</span><br><span class="line">		e-&gt;startlink = G-&gt;Amlist[i].pEdge;</span><br><span class="line">		G-&gt;Amlist[i].pEdge = e;</span><br><span class="line">		e-&gt;endlink = G-&gt;Amlist[j].pEdge;</span><br><span class="line">		G-&gt;Amlist[j].pEdge = e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印邻接多重表存储的图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.numvertex; i++)&#123;</span><br><span class="line">		AMEdge* p = G.Amlist[i].pEdge;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;结点%s的邻接边为：&quot;</span>,G.Amlist[i].str);</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%s,%s) &quot;</span>, G.Amlist[p-&gt;start].str, G.Amlist[p-&gt;end].str);</span><br><span class="line">            <span class="comment">//根据p这个边的start端点是i还是end端点是i来判断走startlink还是endlink</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				p = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				p = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除图中的边</span></span><br><span class="line"><span class="comment">//这里需要传G的指针进去，因为当我们把一个点的相邻边都删除完了以后，需要把这个链表中头结点中指向下一个元素的指针的值改成空，我们要修改指针的值，所以要传G的指针进去，相当于传了头结点中指向下一个元素的指针的二级指针。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteEdge</span><span class="params">(AMGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G-&gt;numedge != <span class="number">0</span>)&#123;</span><br><span class="line">		AMEdge* p = G-&gt;Amlist[i].pEdge;</span><br><span class="line">		AMEdge* tmp = <span class="literal">NULL</span>;</span><br><span class="line">		AMEdge* tmp1 = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> ((!(p-&gt;start == i &amp;&amp; p-&gt;end == j)) &amp;&amp; (!(p-&gt;start == j &amp;&amp; p-&gt;end == i)))&#123;</span><br><span class="line">			tmp = p;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				p = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				p = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp1 = p;</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				G-&gt;Amlist[i].pEdge = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				G-&gt;Amlist[i].pEdge = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == i)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == i)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == i)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == i)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = G-&gt;Amlist[j].pEdge;</span><br><span class="line">		tmp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> ((!(p-&gt;start == i &amp;&amp; p-&gt;end == j)) &amp;&amp; (!(p-&gt;start == j &amp;&amp; p-&gt;end == i)))&#123;</span><br><span class="line">			tmp = p;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == j)&#123;</span><br><span class="line">				p = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == j)&#123;</span><br><span class="line">				p = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == j)&#123;</span><br><span class="line">				G-&gt;Amlist[j].pEdge = p-&gt;startlink;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == j)&#123;</span><br><span class="line">				G-&gt;Amlist[j].pEdge = p-&gt;endlink;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;start == j)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == j)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == j)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;startlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;end == j)&#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp-&gt;start == j)&#123;</span><br><span class="line">					tmp-&gt;startlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (tmp-&gt;end == j)&#123;</span><br><span class="line">					tmp-&gt;endlink = p-&gt;endlink;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(tmp1);</span><br><span class="line">		G-&gt;numedge--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;图中的边已经都删除了\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>test.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Graph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">	MGraph G;</span><br><span class="line">	createMGraph(&amp;G);</span><br><span class="line">	printMGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">	GraphAdjList G;</span><br><span class="line">	createAdjlistGraph(&amp;G);</span><br><span class="line">	printAdjlistGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">	OLGraph G;</span><br><span class="line">	createOLGraph(&amp;G);</span><br><span class="line">	printOLGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	createAMGraph(&amp;G);</span><br><span class="line">	printAMGraph(G);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的边,以i,j格式输入&quot;</span>);</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">		deleteEdge(&amp;G, i, j);</span><br><span class="line">		printAMGraph(G);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	test1();</span><br><span class="line">	test2();</span><br><span class="line">	test3();</span><br><span class="line">	test4();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>图的遍历：从图中某个顶点V。出发，沿着一些边访问图中所有的顶点，且使每个顶点被访问一次且只访问一次</p>
<ol>
<li><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索( Depth First Search，DFS)遍历类似于树的先序遍历，是树的先序遍历的推广。</p>
<p>对于一个连通图，深度优先搜索遍历的过程如下：</p>
<ol>
<li><p>从图中某个顶点v出发，访问v。</p>
</li>
<li><p>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤,直至刚访问过的顶点没有未被访问的邻接点为止。</p>
</li>
<li><p>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p>
</li>
<li><p>重复步骤（2）和（3)，直至图中所有顶点都被访问过，搜索结束。</p>
<p><img src="https://img-blog.csdnimg.cn/a510d5470cc247dfa2fcf56f4fb3469b.png#pic_center" alt></p>
</li>
</ol>
<p>对无向连通图，如果将一次深度优先搜索时前进操作所经过的边保留下来则可构成一棵深度优先搜索生成树。</p>
<p><img src="https://img-blog.csdnimg.cn/a44a9d7a871b44c09d087e2090402098.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>深度优先搜索遍历的算法实现</strong></p>
<p>深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为“false”，一旦某个顶点被访问，则其相应的分量置为“true”。</p>
<ol>
<li>从图中某个顶点v出发，访问v，并置visited[y]的值为true。</li>
<li>依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历,直到图中所有顶点都被访问过。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索遍历连通图的递归算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100        <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType; <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;     <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MVNum];                   <span class="comment">//访问标志数组，其初值为&quot;false&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span>;       <span class="comment">//返回v的第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span>; <span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(Graph G, VerTexType v)</span>&#123;</span><br><span class="line">    <span class="comment">//确定点v在G中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// LocateVex</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(Graph &amp;G)</span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入总顶点数，总边数 , 以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如 a：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如：a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)&#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">        VerTexType v1, v2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);            <span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j] = <span class="number">1</span>; <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;                                    <span class="comment">// for</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123; <span class="comment">//从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w))</span><br><span class="line">        <span class="comment">//依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点</span></span><br><span class="line">        <span class="comment">// NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(G, w); <span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = w; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************深度优先搜索遍历连通图的递归算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Graph G;</span><br><span class="line">    CreateUDN(G);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向连通图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">    VerTexType c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == G.vexs[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= G.vexnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点不存在，请重新输入！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == G.vexs[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先搜索遍历连通图结果：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DFS(G, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索遍历非连通图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100        <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType; <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;     <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------图的邻接矩阵-----------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];     <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;         <span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125; Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MVNum];                   <span class="comment">//访问标志数组，其初值为&quot;false&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span>;       <span class="comment">//返回v的第一个邻接点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span>; <span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(Graph G, VerTexType v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//确定点v在G中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(Graph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum; <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.arcnum; ++k)</span><br><span class="line">    &#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">        VerTexType v1, v2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);            <span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j] = <span class="number">1</span>; <span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;                                    <span class="comment">// for</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w))</span><br><span class="line">        <span class="comment">//依次检查v的所有邻接点w ，FirstAdjVex(G, v)表示v的第一个邻接点</span></span><br><span class="line">        <span class="comment">// NextAdjVex(G, v, w)表示v相对于w的下一个邻接点，w≥0表示存在邻接点</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[w])</span><br><span class="line">            DFS(G, w); <span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对非连通图G做深度优先遍历</span></span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = <span class="literal">false</span>;        <span class="comment">//访问标志数组初始化</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v) <span class="comment">//循环调用算法6.3</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            DFS(G, v); <span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//返回v的第一个邻接点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G, <span class="type">int</span> v, <span class="type">int</span> w)</span>&#123;</span><br><span class="line">    <span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = w; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************深度优先搜索遍历非连通图**************&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Graph G;</span><br><span class="line">    CreateUDN(G);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先搜索遍历非连通图结果：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DFSTraverse(G);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（ Breadth First Search，BFS）遍历类似于树的按层次遍历的过程。</p>
<p>广度优先搜索遍历的过程如下：</p>
<ol>
<li><p>从图中某个顶点v出发，访问v。</p>
</li>
<li><p>依次访问v的各个未曾访问过的邻接点。</p>
</li>
<li><p>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。</p>
</li>
<li><p>重复步骤3，直至图中所有已被访问的顶点的邻接点都被访问到</p>
<p><img src="https://img-blog.csdnimg.cn/b38d873f7db345fb9e1af669a1ca2a33.png#pic_center" alt></p>
</li>
</ol>
<p>广度优先生成树</p>
<p><img src="https://img-blog.csdnimg.cn/5d8d5d18139b45ceb9cea446061845b4.png#pic_center" alt></p>
<p>广度优先搜索遍历连通图</p>
<ol>
<li>从图中某个顶点v出发，访问v，并置 visited[y]的值为true，然后将v进队。</li>
<li>只要队列不空，则重复下述操作:<ul>
<li>队头顶点u出队;</li>
<li>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先搜索遍历连通图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100                       	<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100						<span class="comment">//最大队列长度</span></span></span><br><span class="line">						</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;              		<span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;                  		<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="type">bool</span> visited[MVNum];           				<span class="comment">//访问标志数组，其初值为&quot;false&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----图的邻接矩阵存储表示----- </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];            		<span class="comment">//顶点表</span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];      		<span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;                		<span class="comment">//图的当前点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----队列的定义及操作--------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ArcType *base;							<span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line">	<span class="type">int</span> front;								<span class="comment">//头指针，若队列不空，指向队头元素</span></span><br><span class="line">	<span class="type">int</span> rear;								<span class="comment">//尾指针，若队列不空，指向队尾元素的下一个位置</span></span><br><span class="line">&#125;sqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(sqQueue &amp;Q)</span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空队列Q</span></span><br><span class="line">	Q.base = new ArcType[MAXQSIZE];</span><br><span class="line">	<span class="keyword">if</span>(!Q.base)     <span class="built_in">exit</span>(<span class="number">1</span>);				<span class="comment">//存储分配失败</span></span><br><span class="line">	Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(sqQueue &amp;Q, ArcType e)</span>&#123;</span><br><span class="line">	<span class="comment">//插入元素e为Q的新的队尾元素</span></span><br><span class="line">	<span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	Q.base[Q.rear] = e;</span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(sqQueue Q)</span>&#123;</span><br><span class="line">	<span class="comment">//判断是否为空队</span></span><br><span class="line">	<span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(sqQueue &amp;Q, ArcType &amp;u)</span>&#123;</span><br><span class="line">	<span class="comment">//队头元素出队并置为u </span></span><br><span class="line">	u = Q.base[Q.front];</span><br><span class="line">	Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(Graph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(Graph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)   </span><br><span class="line">			G.arcs[i][j] = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的顶点</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = <span class="number">1</span>;	<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(Graph G , <span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="comment">//返回v的第一个邻接点</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G.arcs[v][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(Graph G , <span class="type">int</span> u , <span class="type">int</span> w)</span>&#123;</span><br><span class="line">	<span class="comment">//返回v相对于w的下一个邻接点</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = w ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(G.arcs[u][i] == <span class="number">1</span> &amp;&amp; visited[i] == <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">(Graph G, <span class="type">int</span> v)</span>&#123; </span><br><span class="line">    <span class="comment">//按广度优先非递归遍历连通图G </span></span><br><span class="line">	sqQueue Q;</span><br><span class="line">	ArcType u;</span><br><span class="line">	ArcType w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; G.vexs[v] &lt;&lt; <span class="string">&quot;  &quot;</span>;    visited[v] = <span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true </span></span><br><span class="line">    InitQueue(Q); <span class="comment">//辅助队列Q初始化，置空         </span></span><br><span class="line">    EnQueue(Q, v); <span class="comment">//v进队 </span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(Q))&#123; <span class="comment">//队列非空 </span></span><br><span class="line">		DeQueue(Q, u);  <span class="comment">//队头元素出队并置为u</span></span><br><span class="line">		<span class="keyword">for</span>(w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))&#123;</span><br><span class="line">			<span class="comment">//依次检查u的所有邻接点w ，FirstAdjVex(G, u)表示u的第一个邻接点 </span></span><br><span class="line">			<span class="comment">//NextAdjVex(G, u, w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点 </span></span><br><span class="line">			<span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为u的尚未访问的邻接顶点 </span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vexs[w] &lt;&lt; <span class="string">&quot;  &quot;</span>;   visited[w] = <span class="literal">true</span>;	<span class="comment">//访问w，并置访问标志数组相应分量值为true </span></span><br><span class="line">				EnQueue(Q, w);	<span class="comment">//w进队 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************算法广度优先搜索遍历连通图**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Graph G;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向连通图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">	VerTexType c;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c == G.vexs[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &gt;= G.vexnum)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该点不存在，请重新输入！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入遍历连通图的起始点：&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(c == G.vexs[i])</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;深度优先搜索遍历连通图结果：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	BFS(G , i);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以邻接表为存储结构的图的广度优先搜索遍历代码</span></span><br><span class="line"><span class="comment">//邻接表存储的定义表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>		<span class="comment">//边表结点定义 </span></span><br><span class="line">	<span class="type">int</span> adjvex;  <span class="comment">//该边所指向的结点的位置</span></span><br><span class="line">	ArcNode *nextarc;   <span class="comment">//指向下一条边的指针</span></span><br><span class="line">	<span class="type">int</span> info;			<span class="comment">//该边的相关信息（如权值），这一句用的不多，可不写 </span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>				<span class="comment">//顶点表结点定义 </span></span><br><span class="line">	<span class="type">char</span> data;			<span class="comment">//顶点信息 </span></span><br><span class="line">	ArcNode *firstarc;	<span class="comment">//指向第一条边的指针 </span></span><br><span class="line">&#125;VNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">//邻接表结构体定义 </span></span><br><span class="line">	VNode adjlist[maxSize];  <span class="comment">//邻接表</span></span><br><span class="line">	<span class="type">int</span> n,e;				<span class="comment">//顶点数和边数 </span></span><br><span class="line">&#125;AGraph;			<span class="comment">//图的邻接表类型 </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visit[maxSize];			<span class="comment">//数组visit作为顶点的访问标记，初始时所有元素均为0，表示所有顶点均为被访问</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//邻接表存储的图的深度优先搜索遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	visit[i]=<span class="number">1</span>;			<span class="comment">//标记已访问 </span></span><br><span class="line">	Visit(v);			<span class="comment">//访问顶点v </span></span><br><span class="line">	p=G.adjlist[v]-&gt;firstarc; 	<span class="comment">//p指向顶点v的第一条边</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visit[p-&gt;adjvex]==<span class="number">0</span>)&#123;</span><br><span class="line">			DFS(G,p-&gt;adjvex);		<span class="comment">//若该顶点未被访问，则递归访问它 </span></span><br><span class="line">			p=p-&gt;nextarc;			<span class="comment">//完事儿之后p再指向顶点v的下一条边的终点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以邻接矩阵为存储结构的图的广度优先搜索遍历代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 32768</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> visited[MAX_VERTEX_NUM];	<span class="comment">//访问标志数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">	<span class="type">int</span> vexnum;	</span><br><span class="line">&#125;Graph;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMatrix</span><span class="params">(Graph *G)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入顶点数：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;G-&gt;vexnum;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入矩阵：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G-&gt;vexnum;++j)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;G-&gt;arcs[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;访问&quot;</span>&lt;&lt;v+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	visited[v]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">0</span>;w&lt;G.vexnum;++w)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[w]&amp;&amp;G.arcs[v][w]==<span class="number">1</span>)&#123;	<span class="comment">//w跟v相连，且w未被访问过 </span></span><br><span class="line">			DFS(G,w);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseGraph</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">		visited[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">			DFS(G,i);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Graph G;</span><br><span class="line">	CreateMatrix(&amp;G);</span><br><span class="line">	TraverseGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以邻接表为存储结构的图的广度优先搜索遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AGraph *G, <span class="type">int</span> v, <span class="type">int</span> visit[maxSize])</span>&#123;</span><br><span class="line">	<span class="comment">//visit[]数组被初始化为全为0</span></span><br><span class="line">	 ArcNode *p;</span><br><span class="line">	 <span class="type">int</span> que[maxSize];		<span class="comment">//初始化一个队列 </span></span><br><span class="line">	 <span class="type">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line">	 <span class="type">int</span> j; </span><br><span class="line">	 Visit(v);  <span class="comment">//访问v顶点</span></span><br><span class="line">	 visit[v]=<span class="number">1</span>;  <span class="comment">//标记为已访问</span></span><br><span class="line">	 rear=(rear+<span class="number">1</span>)%maxSize;		<span class="comment">//顶点v入队 </span></span><br><span class="line">	 que[rear]=v;</span><br><span class="line">	 </span><br><span class="line">	 p=G-&gt;adjlist[v] </span><br><span class="line">	<span class="keyword">while</span>(front!=rear)&#123;		<span class="comment">//当队不为空时，继续遍历。队为空时，遍历结束 </span></span><br><span class="line">	 	front=(front+<span class="number">1</span>)%maxSize;		<span class="comment">//顶点出队 </span></span><br><span class="line">	 	j=que[front]; </span><br><span class="line">	 </span><br><span class="line">	 	p=G-&gt;adjlist[j].firstarc; 		<span class="comment">//P指向出队顶点j的第一条边</span></span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		 	<span class="keyword">if</span>(visit[p-&gt;adjvex==<span class="number">0</span>])&#123;		<span class="comment">//当前邻接顶点未被访问，则进队 </span></span><br><span class="line">		 		Visit(p-&gt;adjvex);			</span><br><span class="line">		 		visit[p-&gt;adjvex]=<span class="number">1</span>;</span><br><span class="line">		 		rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">				que[rear]=p-&gt;adjvex; </span><br><span class="line">			&#125; </span><br><span class="line">			p=p-&gt;nextarc;			<span class="comment">//p指向j的下一条边 </span></span><br><span class="line">	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>极小连通子图:该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通。</p>
<p>生成树:包含图G所有顶点的极小连通子图</p>
<p>生成树的顶点集合与图的顶点集合相等，顶点数为n；不存在回路，边数为n-1</p>
<p><img src="https://img-blog.csdnimg.cn/7aa8f27f6d864a329b6750fd66fbb135.png#pic_center" alt></p>
<p>在网的多个生成树中，寻找一个各边权值之和最小的生成树，即最小生成树</p>
<p>最小生成树的构造—MST：</p>
<ul>
<li><p>设N = (V, E)是一个连通网，U是顶点集V的一个非空子集。若边（u, v）是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边（u, v）的最小生成树</p>
<p>性质解释</p>
<p>在生成树的构造过程中，图中n个顶点分属两个集合：</p>
<ul>
<li>已落在生成树上的顶点集：U</li>
<li>尚未落在生成树上的顶点集：V-U</li>
</ul>
<p>接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边</p>
</li>
</ul>
<p>构造最小生成树的准则：</p>
<ul>
<li>必须只使用该网中的边来构造最小生成树;</li>
<li>必须使用且仅使用n-1条边来联结网络中的n个顶点</li>
<li>不能使用产生回路的边</li>
</ul>
<p>利用 <strong>普里姆（Prim）算法</strong>和 <strong>克鲁斯卡尔（Kruskal）算法</strong>可以生成一个连通网的最小代价生成树。</p>
<h3 id="普里姆算法（加点法）"><a href="#普里姆算法（加点法）" class="headerlink" title="普里姆算法（加点法）"></a>普里姆算法（加点法）</h3><p>算法思想：</p>
<ol>
<li>设N = (V, E) 是连通网，TE是N上最小生成树中边的集合。</li>
<li>初始令U = {u0}，(u0∈V)，TE={}。</li>
<li>在所有u∈U，v∈V-U的边{u, v}∈ E中，找一条代价最小的边(u0, v0)。</li>
<li>将(u0, v0)并入集合TE，同时v0并入U。</li>
<li>重复上述操作直至U=V为止，则T=(V, TE)为N的最小生成树。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/10cec169fbfb44fab90d75fc961930d2.png" alt></p>
<p>代码：</p>
<p>图采用邻接矩阵存储，二维数组closedeg，记录从U到V-U具有最小代价的边。<br>对每个顶点vi, v-U在辅助数组存在一个相应的分量closedge[i-1]，它包括两个域:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType adjvex; <span class="comment">// 最小边的顶点</span></span><br><span class="line">    VRType lowcost;    <span class="comment">// 最小边的权值</span></span><br><span class="line">&#125; closedge[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>
<p>adjvex:依附于这条最小代价边的另一个顶点。</p>
<ul>
<li>等于0表示顶点i已在U中;</li>
<li>大于0表示顶点i还在V-U中。</li>
</ul>
<p>所以，每次循环须在lowcost &gt;0(在集合V-U中)的那些顶点中选择lowcost最小的顶点加入到集合U中，同时将相关顶点的closedge作相应的调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普里姆算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767 <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VerTexType adjvex;<span class="comment">//最小边在U中的那个顶点</span></span><br><span class="line">	ArcType lowcost;<span class="comment">//最小边上的权值</span></span><br><span class="line">&#125;closedge[MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -图的邻接表存储表示- - - - - 						</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i) <span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)   </span><br><span class="line">			G.arcs[i][j] = MaxInt;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 5&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(AMGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//返回权值最小的点</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> min = MaxInt;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(min &gt; closedge[i].lowcost &amp;&amp; closedge[i].lowcost != <span class="number">0</span>)&#123;</span><br><span class="line">			min = closedge[i].lowcost;</span><br><span class="line">			index = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Prim</span><span class="params">(AMGraph G, VerTexType u)</span>&#123; </span><br><span class="line">    <span class="comment">//无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边  </span></span><br><span class="line">	<span class="type">int</span> k , j , i;</span><br><span class="line">	VerTexType u0 , v0;</span><br><span class="line">    k =LocateVex(G, u); <span class="comment">//k为顶点u的下标 </span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123; <span class="comment">//对V-U的每一个顶点vi，初始化closedge[i] </span></span><br><span class="line">		<span class="keyword">if</span>(j != k)&#123;  </span><br><span class="line">			closedge[j].adjvex = u;</span><br><span class="line">			closedge[j].lowcost = G.arcs[k][j];<span class="comment">//&#123;adjvex, lowcost&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedge[k].lowcost = <span class="number">0</span>;<span class="comment">//初始，U = &#123;u&#125;</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//选择其余n-1个顶点，生成n-1条边(n= G.vexnum) </span></span><br><span class="line">		k = Min(G);  </span><br><span class="line">		<span class="comment">//求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边 </span></span><br><span class="line">		u0 = closedge[k].adjvex;<span class="comment">//u0为最小边的一个顶点，u0∈U </span></span><br><span class="line">		v0 = G.vexs[k];<span class="comment">//v0为最小边的另一个顶点，v0∈V-U </span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;边  &quot;</span> &lt;&lt;u0 &lt;&lt; <span class="string">&quot;---&gt;&quot;</span> &lt;&lt; v0 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出当前的最小边(u0, v0) </span></span><br><span class="line">		closedge[k].lowcost = <span class="number">0</span>;<span class="comment">//第k个顶点并入U集 </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j) </span><br><span class="line">			<span class="keyword">if</span>(G.arcs[k][j] &lt; closedge[j].lowcost)&#123;<span class="comment">//新顶点并入U后重新选择最小边 </span></span><br><span class="line">				closedge[j].adjvex = G.vexs[k];</span><br><span class="line">				closedge[j].lowcost = G.arcs[k][j];</span><br><span class="line">			&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************普里姆算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无向图G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;******利用普里姆算法构造最小生成树结果：******&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	MiniSpanTree_Prim(G , <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克鲁斯卡尔算法（加边法）"><a href="#克鲁斯卡尔算法（加边法）" class="headerlink" title="克鲁斯卡尔算法（加边法）"></a>克鲁斯卡尔算法（加边法）</h3><p>算法思想：</p>
<p>假设连通网N=(V,E)，将Ⅳ中的边按权值从小到大的顺序排列。</p>
<ol>
<li>初始状态为只有n个顶点而无边的非连通图T=(V, {),图中每个顶点自成一个连通分量。</li>
<li>在E中选择权值最小的边，若该边依附的顶点落在T中不同的连通分量上（即不形成回路)，则将此边加人到T中，否则舍去此边而选择下一条权值最小的边。</li>
<li>重复②，直至T中所有顶点都在同一连通分量上为止。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/81d94ba28cd74f2498b44bd559a04e04.png" alt></p>
<p>代码：</p>
<p>算法的实现要引人以下辅助的数据结构</p>
<ol>
<li><p>结构体数组Edge:存储边的信息，包括边的两个顶点信息和权值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助数组Edges的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VerTexType Head; <span class="comment">//边的始点</span></span><br><span class="line">    VerTexType Tail; <span class="comment">//边的终点</span></span><br><span class="line">    ArcType lowcost; <span class="comment">//边上的权值</span></span><br><span class="line">&#125; Edge[arcnnum];</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vexset[i]:标识各个顶点所属的连通分量。对每个顶点v,EV，在辅助数组中存在一个相应元素Vexset[i]表示该顶点所在的连通分量。初始时Vexset[i]=i，表示各顶点自成一个连通分量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助数组Vexset的定义</span></span><br><span class="line"><span class="type">int</span> Vexset[MVNum];</span><br></pre></td></tr></table></figure>
<ol>
<li>将数组Edge中的元素按权值从小到大排序。</li>
<li>依次查看数组Edge中的边,循环执行以下操作:<ul>
<li>依次从排好序的数组 Edge 中选出一条边(U1,U2);</li>
<li>在Vexset中分别查找v1和v2所在的连通分量vs1和 vs2，进行判断:<ul>
<li>如果vs1,和vs2不等、表明所选的两个顶点分属不同的连通分量,输出此边,并合并vs1,和 vs2两个连通分量;</li>
<li>如果vs1,和 vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//克鲁斯卡尔算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------图的邻接矩阵---------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助数组Edges的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VerTexType Head;<span class="comment">//边的始点</span></span><br><span class="line">	VerTexType Tail;<span class="comment">//边的终点</span></span><br><span class="line">	ArcType lowcost;<span class="comment">//边上的权值</span></span><br><span class="line">&#125;Edge[(MVNum * (MVNum - <span class="number">1</span>)) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Vexset[MVNum];<span class="comment">//辅助数组Vexset的定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i]; <span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j) </span><br><span class="line">			G.arcs[i][j] = MaxInt; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 6&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">		Edge[k].lowcost = w;</span><br><span class="line">		Edge[k].Head = v1;</span><br><span class="line">		Edge[k].Tail = v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------冒泡排序-------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sort</span><span class="params">(AMGraph G)</span>&#123;</span><br><span class="line">	<span class="type">int</span> m = G.arcnum - <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>((m &gt; <span class="number">0</span>) &amp;&amp; flag == <span class="number">1</span>)&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(Edge[j].lowcost &gt; Edge[j+ <span class="number">1</span>].lowcost)&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				VerTexType temp_Head = Edge[j].Head;</span><br><span class="line">				Edge[j].Head = Edge[j+ <span class="number">1</span>].Head;</span><br><span class="line">				Edge[j + <span class="number">1</span>].Head = temp_Head;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				VerTexType temp_Tail = Edge[j].Tail;</span><br><span class="line">				Edge[j].Tail = Edge[j+ <span class="number">1</span>].Tail;</span><br><span class="line">				Edge[j + <span class="number">1</span>].Tail = temp_Tail;</span><br><span class="line">				</span><br><span class="line">				ArcType temp_lowcost = Edge[j].lowcost;</span><br><span class="line">				Edge[j].lowcost = Edge[j+ <span class="number">1</span>].lowcost;</span><br><span class="line">				Edge[j + <span class="number">1</span>].lowcost = temp_lowcost;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Kruskal</span><span class="params">(AMGraph G)</span>&#123; </span><br><span class="line">    <span class="comment">//无向网G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边     </span></span><br><span class="line">    <span class="type">int</span> i , j , v1 , v2 , vs1 , vs2;</span><br><span class="line">	Sort(G);<span class="comment">//将数组Edge中的元素按权值从小到大排序 </span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//辅助数组，表示各顶点自成一个连通分量 </span></span><br><span class="line">        Vexset[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.arcnum; ++i)&#123;      </span><br><span class="line">		<span class="comment">//依次查看排好序的数组Edge中的边是否在同一连通分量上     </span></span><br><span class="line">		v1 =LocateVex(G, Edge[i].Head);<span class="comment">//v1为边的始点Head的下标 </span></span><br><span class="line">		v2 =LocateVex(G, Edge[i].Tail);<span class="comment">//v2为边的终点Tail的下标 </span></span><br><span class="line">		vs1 = Vexset[v1];<span class="comment">//获取边Edge[i]的始点所在的连通分量vs1 </span></span><br><span class="line">		vs2 = Vexset[v2];<span class="comment">//获取边Edge[i]的终点所在的连通分量vs2 </span></span><br><span class="line">		<span class="keyword">if</span>(vs1 != vs2)&#123;<span class="comment">//边的两个顶点分属不同的连通分量 </span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; Edge[i].Head &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; Edge[i].Tail &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出此边 </span></span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)<span class="comment">//合并vs1和vs2两个分量，即两个集合统一编号 </span></span><br><span class="line">				<span class="keyword">if</span>(Vexset[j] == vs2) Vexset[j] = vs1;<span class="comment">//集合编号为vs2的都改为vs1 </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************克鲁斯卡尔算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*****无向网G创建完成！*****&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	MiniSpanTree_Kruskal(G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算法名</th>
<th>普里姆算法</th>
<th>克鲁斯卡尔算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法思想</td>
<td>选择点</td>
<td>选择边</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n2)（n为顶点数）</td>
<td>O(eloge)（e为边数）</td>
</tr>
<tr>
<td>适应范围</td>
<td>稠密图</td>
<td>稀疏图</td>
</tr>
</tbody>
</table>
</div>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>对于图来说，从一个顶点到另一个顶点可能存在多条路径，每条路径的所包含的边数可能不同。把所包含的边数最少的那条称为最短路径。</p>
<p>最短路径:对于网(带权的图)来说，从一个顶点到另一个顶点所经过的边的权值之和称为带权路径长度，把带权路径长度最短的那条称为最短路径</p>
<h3 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h3><p><strong>从某个源点到其余各顶点的最短路径</strong></p>
<ol>
<li>初始化:先找出从源点v0到各终点v的直达路径(v0,vk)，即通过一条弧到达的路径。</li>
<li>选择:从这些路径中找出一条长度最短的路径(v0,u) 。</li>
<li>更新:然后对其余各条路径进行适当调整。</li>
</ol>
<p>若在图中存在弧(u，vk) ，(v0，u) +(u，vk)&lt; (v0，vk) ,则以路径(v0,u,vk)代替（v0，vk)。<br>在调整后的各条路径中，再找长度最短的路径。</p>
<p>主要存储结构︰邻接矩阵G[n] (或者邻接表)</p>
<p>辅助存储结构︰</p>
<ul>
<li>数组S[n]:记录相应顶点是否已被确定最短距离<br>true:确定 false:未确定</li>
<li>数组D[n]:记录源点到相应顶点路径长度<br>初值:如果v0到vi有弧，则D[i]为弧上权值;否则为∞</li>
<li>数组Path[n]:记录相应顶点的前驱顶点<br>初值:如果v0到vi有弧，则Path[i]为v0，否则为-1</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最短路径--迪杰斯特拉算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *D=new <span class="type">int</span>[MVNum];<span class="comment">//用于记录最短路的长度</span></span><br><span class="line"><span class="type">bool</span> *S=new <span class="type">bool</span>[MVNum];<span class="comment">//标记顶点是否进入S集合</span></span><br><span class="line"><span class="type">int</span> *Path=new <span class="type">int</span>[MVNum];<span class="comment">//用于记录最短路顶点的前驱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------图的邻接矩阵-----------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称:，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)   </span><br><span class="line">			G.arcs[i][j] = MaxInt; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 7&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">		G.arcs[j][i] = G.arcs[i][j];<span class="comment">//置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_DIJ</span><span class="params">(AMGraph G, <span class="type">int</span> v0)</span>&#123; </span><br><span class="line">    <span class="comment">//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 </span></span><br><span class="line">    <span class="type">int</span> v , i , w , min;</span><br><span class="line">	<span class="type">int</span> n = G.vexnum;<span class="comment">//n为G中顶点的个数 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; n; ++v)&#123;<span class="comment">//n个顶点依次初始化 </span></span><br><span class="line">		S[v] = <span class="number">0</span>;<span class="comment">//S初始为空集 </span></span><br><span class="line">		D[v] = G.arcs[v0][v];<span class="comment">//将v0到各个终点的最短路径长度初始化为弧上的权值 </span></span><br><span class="line">		<span class="keyword">if</span>(D[v] &lt; MaxInt)  Path [v] = v0;<span class="comment">//如果v0和v之间有弧，则将v的前驱置为v0 </span></span><br><span class="line">		<span class="keyword">else</span> Path [v] = <span class="number">-1</span>;<span class="comment">//如果v0和v之间无弧，则将v的前驱置为-1 </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	S[v0]=<span class="literal">true</span>;<span class="comment">//将v0加入S </span></span><br><span class="line">	D[v0]=<span class="number">0</span>;<span class="comment">//源点到源点的距离为0 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*―初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/</span> </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; n; ++i)&#123;<span class="comment">//对其余n-1个顶点，依次进行计算 </span></span><br><span class="line">        min= MaxInt; </span><br><span class="line">        <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; n; ++w) </span><br><span class="line">			<span class="keyword">if</span>(!S[w] &amp;&amp; D[w] &lt; min)&#123;<span class="comment">//选择一条当前的最短路径，终点为v </span></span><br><span class="line">				v = w; </span><br><span class="line">				min = D[w];</span><br><span class="line">			&#125;</span><br><span class="line">		S[v]=<span class="literal">true</span>;<span class="comment">//将v加入S </span></span><br><span class="line">		<span class="keyword">for</span>(w = <span class="number">0</span>;w &lt; n; ++w)<span class="comment">//更新从v0出发到集合V?S上所有顶点的最短路径长度 </span></span><br><span class="line">			<span class="keyword">if</span>(!S[w] &amp;&amp; (D[v] + G.arcs[v][w] &lt; D[w]))&#123; </span><br><span class="line">				D[w] = D[v] + G.arcs[v][w];<span class="comment">//更新D[w] </span></span><br><span class="line">				Path [w] = v;<span class="comment">//更改w的前驱为v </span></span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayPath</span><span class="params">(AMGraph G , <span class="type">int</span> begin ,<span class="type">int</span> temp )</span>&#123;</span><br><span class="line">	<span class="comment">//显示最短路</span></span><br><span class="line">	<span class="keyword">if</span>(Path[temp] != <span class="number">-1</span>)&#123;</span><br><span class="line">		DisplayPath(G , begin ,Path[temp]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[Path[temp]] &lt;&lt; <span class="string">&quot;--&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************迪杰斯特拉算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G; </span><br><span class="line">	<span class="type">int</span> i , j ,num_start , num_destination;</span><br><span class="line">	VerTexType start , destination;</span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*****无向网G创建完成！*****&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j != G.vexnum - <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(G.arcs[i][j] != MaxInt)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; G.arcs[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;∞&quot;</span> &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(G.arcs[i][j] != MaxInt)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; G.arcs[i][j] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;∞&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入起始点、终点名称：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">	num_start = LocateVex(G , start);</span><br><span class="line">	num_destination = LocateVex(G , destination);</span><br><span class="line">	ShortestPath_DIJ(G , num_start);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt;<span class="string">&quot;最短路径为：&quot;</span>;</span><br><span class="line">	DisplayPath(G , num_start , num_destination);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; G.vexs[num_destination]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h3><p><strong>每一对顶点之间的最短路径</strong></p>
<p>求最短路径步骤:</p>
<ol>
<li>初始时设置一个n阶方阵,令其对角线元素为0，若存在弧<Vi，Vj>，则对应元素为权值;否则为无穷大。</Vi，Vj></li>
<li>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之;否则，维持原值。所有顶点试探完毕，算法结束。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//弗洛伊德算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Path[MVNum][MVNum];<span class="comment">//最短路径上顶点vj的前一顶点的序号</span></span><br><span class="line"><span class="type">int</span> D[MVNum][MVNum];<span class="comment">//记录顶点vi和vj之间的最短路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------图的邻接矩阵---------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">	VerTexType vexs[MVNum];<span class="comment">//顶点表 </span></span><br><span class="line">	ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵 </span></span><br><span class="line">	<span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(AMGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span>&#123; </span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建有向网G </span></span><br><span class="line">	<span class="type">int</span> i , j , k;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;   </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt </span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123;  </span><br><span class="line">			<span class="keyword">if</span>(j != i)</span><br><span class="line">				G.arcs[i][j] = MaxInt;  </span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及权值，如a b 3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//构造邻接矩阵 </span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		ArcType w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);<span class="comment">//确定v1和v2在G中的位置，即顶点数组的下标 </span></span><br><span class="line">		G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyed</span><span class="params">(AMGraph G)</span>&#123; </span><br><span class="line">    <span class="comment">//用Floyd算法求有向网G中各对顶点i和j之间的最短路径 </span></span><br><span class="line">	<span class="type">int</span> i , j , k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)<span class="comment">//各对结点之间初始已知路径及距离 </span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)&#123; </span><br><span class="line">            D[i][j] = G.arcs[i][j]; </span><br><span class="line">            <span class="keyword">if</span>(D[i][j] &lt; MaxInt &amp;&amp; i != j)  Path[i][j]=i;<span class="comment">//如果i和j之间有弧，则将j的前驱置为i </span></span><br><span class="line">            <span class="keyword">else</span> Path [i][j] = <span class="number">-1</span>;<span class="comment">//如果i和j之间无弧，则将j的前驱置为-1 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.vexnum; ++k) </span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i) </span><br><span class="line">				<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">					<span class="keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])&#123;<span class="comment">//从i经k到j的一条路径更短 </span></span><br><span class="line">						D[i][j] = D[i][k]+D[k][j];<span class="comment">//更新D[i][j] </span></span><br><span class="line">						Path[i][j] = Path[k][j];<span class="comment">//更改j的前驱为k </span></span><br><span class="line">					&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayPath</span><span class="params">(AMGraph G , <span class="type">int</span> begin ,<span class="type">int</span> temp )</span>&#123;</span><br><span class="line">	<span class="comment">//显示最短路径</span></span><br><span class="line">	<span class="keyword">if</span>(Path[begin][temp] != <span class="number">-1</span>)&#123;</span><br><span class="line">		DisplayPath(G , begin ,Path[begin][temp]);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; G.vexs[Path[begin][temp]] &lt;&lt; <span class="string">&quot;--&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************弗洛伊德算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	AMGraph G;</span><br><span class="line">	<span class="type">char</span> start , destination;</span><br><span class="line">	<span class="type">int</span> num_start , num_destination;</span><br><span class="line"></span><br><span class="line">	CreateUDN(G);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有向网G创建完成！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ShortestPath_Floyed(G);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入路径的起点与终点的名称：&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">	num_start = LocateVex(G , start);</span><br><span class="line">	num_destination = LocateVex(G , destination);</span><br><span class="line"></span><br><span class="line">	DisplayPath(G , num_start , num_destination);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; G.vexs[num_destination] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最短路径的长度为：&quot;</span> &lt;&lt; D[num_start][num_destination] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对一项工程，我们最关心两个问题:</p>
<p>①工程能否顺利完成;(拓扑排序)<br>②整个工程完成所必需的最短工期。(关键路径)</p>
<p>有向无环图——无环的有向图，简称DAG图( directed acycling graph)</p>
<p>AOV网:用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网。</p>
<p>AOV网应该是一个有向无环图即DAG图</p>
<p>拓扑排序：就是将AOV网中所有顶点排成一个线性序列(称为拓扑序列)，该序列满足∶<br>若在AOV网中由顶点vi到vj有一条路径，则在该线性序列中的顶点vi必定在vj之前</p>
<ol>
<li>在有向图中选一个无前驱的顶点且输出它（即入度为0)</li>
<li>从图中删除该顶点和所有以它为起点的边</li>
<li>重复(1)(2)，直至不存在无前驱的顶点</li>
<li>若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在环，否则输出的顶点序列为一个拓扑序列</li>
</ol>
<p>拓扑排序实现</p>
<ul>
<li>求出个顶点的入度存入数组indegree[i]中，并将入度为0的顶点入栈。</li>
<li>只要栈不空，重复以下操作<ul>
<li>将栈顶顶点vi出栈并保存在拓扑序列数组topo中;</li>
<li>对顶点vi的每个邻接点vk的入度减1，如果vk的入度变为0，则将vk入栈</li>
</ul>
</li>
<li>如果输出顶点个数少于AOV网的顶点个数，则网址存在有向环，无法进行拓扑排序，否则拓扑排序成功。</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -图的邻接表存储表示- - - - - </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针 </span></span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息 </span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">//邻接表 </span></span><br><span class="line">	AdjList converse_vertices;<span class="comment">//逆邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -顺序栈的定义- - - - -</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *base;</span><br><span class="line">	<span class="type">int</span> *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;spStack;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> indegree[MVNum];<span class="comment">//数组indegree存放个顶点的入度</span></span><br><span class="line">spStack S;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------栈的相关操作----------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(spStack &amp;S)</span>&#123;</span><br><span class="line">	<span class="comment">//初始化栈</span></span><br><span class="line">	S.base = new <span class="type">int</span>[MVNum];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = MVNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(spStack &amp;S , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="comment">//进栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top - S.base == S.stacksize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	*S.top++ = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(spStack &amp;S , <span class="type">int</span> &amp;i)</span>&#123;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	i = *--S.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(spStack S)</span>&#123;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(ALGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vertices[i].data == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123; </span><br><span class="line">	<span class="comment">//创建有向图G的邻接表、逆邻接表</span></span><br><span class="line">	<span class="type">int</span> i , k;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">		G.converse_vertices[i].data = G.vertices[i].data;</span><br><span class="line">		<span class="comment">//初始化表头结点的指针域为NULL </span></span><br><span class="line">		G.vertices[i].firstarc=<span class="literal">NULL</span>;			</span><br><span class="line">		G.converse_vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点，如a b&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		<span class="type">int</span> i , j;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);</span><br><span class="line">		<span class="comment">//确定v1和v2在G中位置，即顶点在G.vertices中的序号 </span></span><br><span class="line"></span><br><span class="line">		ArcNode *p1=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p1-&gt;adjvex=j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">		p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line"></span><br><span class="line">		ArcNode *p2=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p2-&gt;adjvex=i;<span class="comment">//逆邻接点序号为i</span></span><br><span class="line">		p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindInDegree</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">	<span class="type">int</span> i , count;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; i++)&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		ArcNode *p = G.converse_vertices[i].firstarc;</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				p = p-&gt;nextarc;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		indegree[i] = count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">TopologicalSort</span><span class="params">(ALGraph G , <span class="type">int</span> topo[])</span>&#123; </span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line">    <span class="comment">//若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR </span></span><br><span class="line">	<span class="type">int</span> i , m;</span><br><span class="line">    FindInDegree(G);<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">    InitStack(S);<span class="comment">//栈S初始化为空 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!indegree[i]) Push(S, i);<span class="comment">//入度为0者进栈 </span></span><br><span class="line">	m = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始为0 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;<span class="comment">//栈S非空 </span></span><br><span class="line">		Pop(S, i);<span class="comment">//将栈顶顶点vi出栈</span></span><br><span class="line">		topo[m]=i;<span class="comment">//将vi保存在拓扑序列数组topo中 </span></span><br><span class="line">		++m;<span class="comment">//对输出顶点计数 </span></span><br><span class="line">		ArcNode *p = G.vertices[i].firstarc;<span class="comment">//p指向vi的第一个邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			<span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//vk为vi的邻接点   </span></span><br><span class="line">			--indegree[k];<span class="comment">//vi的每个邻接点的入度减1 </span></span><br><span class="line">			<span class="keyword">if</span>(indegree[k] ==<span class="number">0</span>)  Push(S, k);<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向顶点vi下一个邻接结点 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m &lt; G.vexnum)  <span class="keyword">return</span> ERROR;<span class="comment">//该有向图有回路 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************拓扑排序**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateUDG(G);</span><br><span class="line">	<span class="type">int</span> *topo = new <span class="type">int</span> [G.vexnum];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有向图的邻接表、逆邻接表创建完成!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(TopologicalSort(G , topo))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该有向图的拓扑有序序列为：&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; G.vexnum; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j != G.vexnum - <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vertices[topo[j]].data &lt;&lt; <span class="string">&quot; , &quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vertices[topo[j]].data &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;网中存在环，无法进行拓扑排序！&quot;</span> &lt;&lt;<span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>AOE网(Activity On Edges)—用边表示活动的网络用一个有向图表示一个工程的各子工程及其相互制约的关系，弧表示活动，权表示活动持续的时间，顶点表示事件（活动的开始或结束时间)，称这种有向图为边表示活动的网，简称AOE网;AOE网用来估算工程的完成时间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">源点</td>
<td style="text-align:center">入度为0的顶点（只有1个)</td>
</tr>
<tr>
<td style="text-align:center">汇点</td>
<td style="text-align:center">出度为0的顶点(只有1个)</td>
</tr>
<tr>
<td style="text-align:center">路径长度</td>
<td style="text-align:center">路径上各活动持续时间之和</td>
</tr>
<tr>
<td style="text-align:center">整个工程完成的时间</td>
<td style="text-align:center">从有向图的源点到汇点的最长路径</td>
</tr>
<tr>
<td style="text-align:center">关键路径</td>
<td style="text-align:center">路径长度最长的路径</td>
</tr>
<tr>
<td style="text-align:center">关键活动</td>
<td style="text-align:center">关键路径上的活动，边上的权值增加将使有向图上的最长路径的长度增加。</td>
</tr>
<tr>
<td style="text-align:center">ve(j)</td>
<td style="text-align:center">表示事件V的最早发生时间</td>
</tr>
<tr>
<td style="text-align:center">vl(j)</td>
<td style="text-align:center">表示事件V,的最迟发生时间</td>
</tr>
<tr>
<td style="text-align:center">e(i)</td>
<td style="text-align:center">表示活动ai的最早开始时间</td>
</tr>
<tr>
<td style="text-align:center">l(i)</td>
<td style="text-align:center">表示活动ai的最迟开始时间</td>
</tr>
<tr>
<td style="text-align:center">l(i)-e(i)</td>
<td style="text-align:center">表示完成活动ai的时间余量</td>
</tr>
</tbody>
</table>
</div>
<p>注意:在一个AOE网中，可以有不止一条的关键路径。</p>
<p><img src="https://img-blog.csdnimg.cn/9c0693cd56b74b6f9f3bfd950265aa7a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57Sg6ZSm5rWB5bm044Gk,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键路径算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BDNum MVNum * (MVNum - 1)<span class="comment">//最大边数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1	</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -图的邻接表存储表示- - - - - </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边结点 </span></span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">	<span class="type">int</span> weight;<span class="comment">//权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针 </span></span><br><span class="line">&#125;ArcNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> </span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">    AdjList vertices;<span class="comment">//邻接表 </span></span><br><span class="line">	AdjList converse_vertices;<span class="comment">//逆邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- - - - -顺序栈的定义- - - - -</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *base;</span><br><span class="line">	<span class="type">int</span> *top;</span><br><span class="line">	<span class="type">int</span> stacksize;</span><br><span class="line">&#125;spStack;</span><br><span class="line"><span class="comment">//- - - - - - - - - - - - - - - -</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> indegree[MVNum];<span class="comment">//数组indegree存放个顶点的入度</span></span><br><span class="line"><span class="type">int</span> ve[BDNum];<span class="comment">//事件vi的最早发生时间</span></span><br><span class="line"><span class="type">int</span> vl[BDNum];<span class="comment">//事件vi的最迟发生时间</span></span><br><span class="line"><span class="type">int</span> topo[MVNum];<span class="comment">//记录拓扑序列的顶点序号</span></span><br><span class="line">spStack S;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------栈的操作--------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(spStack &amp;S)</span>&#123;</span><br><span class="line">	<span class="comment">//栈的初始化</span></span><br><span class="line">	S.base = new <span class="type">int</span>[MVNum];</span><br><span class="line">	<span class="keyword">if</span>(!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = MVNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(spStack &amp;S , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top - S.base == S.stacksize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	*S.top++ = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(spStack &amp;S , <span class="type">int</span> &amp;i)</span>&#123;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	i = *--S.top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(spStack S)</span>&#123;</span><br><span class="line">	<span class="comment">//判断栈是否为空</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateVex</span><span class="params">(ALGraph G , VerTexType v)</span>&#123;</span><br><span class="line">	<span class="comment">//确定点v在G中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(G.vertices[i].data == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>&#123; </span><br><span class="line">	<span class="comment">//创建有向图G的邻接表、逆邻接表</span></span><br><span class="line">	<span class="type">int</span> i , k;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入总顶点数，总边数，以空格隔开:&quot;</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数，总边数 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入点的名称，如a&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;<span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;个点的名称:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">		G.converse_vertices[i].data = G.vertices[i].data;</span><br><span class="line">		<span class="comment">//初始化表头结点的指针域为NULL </span></span><br><span class="line">		G.vertices[i].firstarc=<span class="literal">NULL</span>;			</span><br><span class="line">		G.converse_vertices[i].firstarc=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入边依附的顶点及其权值，如a b 3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum;++k)&#123;<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">		VerTexType v1 , v2;</span><br><span class="line">		<span class="type">int</span> i , j , w;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; (k + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;条边依附的顶点及其权值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">		i = LocateVex(G, v1);  j = LocateVex(G, v2);</span><br><span class="line">		<span class="comment">//确定v1和v2在G中位置，即顶点在G.vertices中的序号 </span></span><br><span class="line"></span><br><span class="line">		ArcNode *p1=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p1-&gt;adjvex=j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">		p1-&gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;</span><br><span class="line">		p1-&gt;weight = w;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line"></span><br><span class="line">		ArcNode *p2=new ArcNode;<span class="comment">//生成一个新的边结点*p1 </span></span><br><span class="line">		p2-&gt;adjvex=i;<span class="comment">//逆邻接点序号为i</span></span><br><span class="line">		p2-&gt;nextarc = G.converse_vertices[j].firstarc;  G.converse_vertices[j].firstarc=p2;</span><br><span class="line">		p2-&gt;weight = w;</span><br><span class="line">		<span class="comment">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindInDegree</span><span class="params">(ALGraph G)</span>&#123;</span><br><span class="line">	<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">	<span class="type">int</span> i , count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; G.vexnum ; i++)&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		ArcNode *p = G.converse_vertices[i].firstarc;</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)&#123;</span><br><span class="line">				p = p-&gt;nextarc;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		indegree[i] = count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">TopologicalOrder</span><span class="params">(ALGraph G , <span class="type">int</span> topo[])</span>&#123; </span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储结构 </span></span><br><span class="line">    <span class="comment">//若G无回路，则生成G的一个拓扑序列topo[]并返回OK，否则ERROR </span></span><br><span class="line">	<span class="type">int</span> i , m;</span><br><span class="line">    FindInDegree(G);<span class="comment">//求出各顶点的入度存入数组indegree中 </span></span><br><span class="line">    InitStack(S);<span class="comment">//栈S初始化为空 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!indegree[i]) Push(S, i);<span class="comment">//入度为0者进栈 </span></span><br><span class="line">	m = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始为0 </span></span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty(S))&#123;<span class="comment">//栈S非空 </span></span><br><span class="line">		Pop(S, i);<span class="comment">//将栈顶顶点vi出栈</span></span><br><span class="line">		topo[m]=i;<span class="comment">//将vi保存在拓扑序列数组topo中 </span></span><br><span class="line">		++m;<span class="comment">//对输出顶点计数 </span></span><br><span class="line">		ArcNode *p = G.vertices[i].firstarc;<span class="comment">//p指向vi的第一个邻接点 </span></span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			<span class="type">int</span> k = p-&gt;adjvex;\<span class="comment">//vk为vi的邻接点   </span></span><br><span class="line">			--indegree[k];<span class="comment">//vi的每个邻接点的入度减1 </span></span><br><span class="line">			<span class="keyword">if</span>(indegree[k] ==<span class="number">0</span>)  Push(S, k);<span class="comment">//若入度减为0，则入栈 </span></span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向顶点vi下一个邻接结点 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m &lt; G.vexnum)  <span class="keyword">return</span> ERROR;<span class="comment">//该有向图有回路 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">CriticalPath</span><span class="params">(ALGraph G)</span>&#123; </span><br><span class="line">    <span class="comment">//G为邻接表存储的有向网，输出G的各项关键活动</span></span><br><span class="line">	<span class="type">int</span> n , i , k , j , e , l;</span><br><span class="line">    <span class="keyword">if</span> (!TopologicalOrder(G, topo))  <span class="keyword">return</span> ERROR; </span><br><span class="line">    <span class="comment">//调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环，返回ERROR </span></span><br><span class="line">    n = G.vexnum;<span class="comment">//n为顶点个数 </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//给每个事件的最早发生时间置初值0 </span></span><br><span class="line">		ve[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*――――――――――按拓扑次序求每个事件的最早发生时间－――――－―――――*/</span> </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;                 </span><br><span class="line">		k = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k             </span></span><br><span class="line">		ArcNode *p = G.vertices[k].firstarc;<span class="comment">//p指向k的第一个邻接顶点  </span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;<span class="comment">//依次更新k的所有邻接顶点的最早发生时间   </span></span><br><span class="line">			j = p-&gt;adjvex;<span class="comment">//j为邻接顶点的序号                   </span></span><br><span class="line">			<span class="keyword">if</span>(ve[j] &lt; ve[k] + p-&gt;weight)<span class="comment">//更新顶点j的最早发生时间ve[j] </span></span><br><span class="line">				ve[j] = ve[k] + p-&gt;weight;     </span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向k的下一个邻接顶点  </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//给每个事件的最迟发生时间置初值ve[n-1] </span></span><br><span class="line">		vl[i]=ve[n<span class="number">-1</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*――――――――――按逆拓扑次序求每个事件的最迟发生时间－――――－―――――*/</span> </span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;               </span><br><span class="line">		k = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k             </span></span><br><span class="line">		ArcNode *p = G.vertices[k].firstarc;<span class="comment">//p指向k的第一个邻接顶点  </span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;<span class="comment">//根据k的邻接点，更新k的最迟发生时间   </span></span><br><span class="line">			j = p-&gt;adjvex;<span class="comment">//j为邻接顶点的序号                   </span></span><br><span class="line">			<span class="keyword">if</span>(vl[k] &gt; vl[j] - p-&gt;weight)<span class="comment">//更新顶点k的最迟发生时间vl[k] </span></span><br><span class="line">				vl[k] = vl[j] - p-&gt;weight;       </span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向k的下一个邻接顶点  </span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*――――――――――――判断每一活动是否为关键活动－――――――－―――――*/</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;关键活动路径为:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;<span class="comment">//每次循环针对vi为活动开始点的所有活动 </span></span><br><span class="line">        ArcNode *p = G.vertices[i].firstarc;    <span class="comment">//p指向i的第一个邻接顶点  </span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			j = p-&gt;adjvex;<span class="comment">//j为i的邻接顶点的序号    </span></span><br><span class="line">			e = ve[i];<span class="comment">//计算活动&lt;vi, vj&gt;的最早开始时间 </span></span><br><span class="line">			l = vl[j] - p-&gt;weight;<span class="comment">//计算活动&lt;vi, vj&gt;的最迟开始时间 </span></span><br><span class="line">			<span class="keyword">if</span>(e == l)<span class="comment">//若为关键活动，则输出&lt;vi, vj&gt; </span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; G.vertices[i].data &lt;&lt; <span class="string">&quot;--&gt;&quot;</span> &lt;&lt; G.vertices[j].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p指向i的下一个邻接顶点  </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;************关键路径算法**************&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateUDG(G);</span><br><span class="line">	<span class="type">int</span> *topo = new <span class="type">int</span> [G.vexnum];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有向图创建完成!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!CriticalPath(G))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;网中存在环，无法进行拓扑排序！&quot;</span> &lt;&lt;<span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搜素与图论</title>
    <url>/post/f352056c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深度优先搜素（DFS）"><a href="#深度优先搜素（DFS）" class="headerlink" title="深度优先搜素（DFS）"></a>深度优先搜素（DFS）</h1><p>①想好递归方程；②处理好枚举数据，对已遍历的数据要标记；③<strong>还原现场</strong>，这是回溯的决定性条件<br>爆搜，顺序<br>回溯（注意恢复现场），剪枝<br><strong>题目：<a href="https://www.acwing.com/problem/content/844/">排列数字</a></strong><br>给定一个整数 n ，将数字 1∼n 排成一排，将会有很多种排列方法。<br>现在，请你按照字典序将所有的排列方法输出。</p>
<p>输入格式<br>共一行，包含一个整数 n 。</p>
<p>输出格式<br>按字典序输出所有排列方案，每个方案占一行。</p>
<p>数据范围<br>1≤n≤7</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><br>思路：<br>构建一棵数，每一层依次增加一个没有枚举的数，当到达底层的时候就是一个答案。<br><img src="https://cdn.acwing.com/media/article/image/2021/02/20/55289_0cd4222d73-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt></p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];<span class="comment">//存储每次到底层的路径</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//存储每次已经遍历的点,默认是false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;<span class="comment">//u表示当前的层数</span></span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;<span class="comment">//已经到达最底层了，溯回并输出路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//溯回上一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;<span class="comment">//如果该数字未被访问，就使用</span></span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;<span class="comment">//标记第i个数已经被使用</span></span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);<span class="comment">//进入下一层</span></span><br><span class="line">            st[i] = <span class="literal">false</span>;<span class="comment">//还原现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/845/">n-皇后问题</a></strong><br>n− 皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。<br><img src="https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png" alt><br>现在给定整数 n ，请你输出所有的满足条件的棋子摆法。</p>
<p>输入格式<br>共一行，包含整数 n 。</p>
<p>输出格式<br>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。<br>其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。<br>每个方案输出完成后，输出一个空行。<br>注意：行末不能有多余空格。<br>输出方案的顺序任意，只要不重复且没有遗漏即可。</p>
<p>数据范围<br>1≤n≤9</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Q..</span><br><span class="line">...Q</span><br><span class="line">Q...</span><br><span class="line">..Q.</span><br><span class="line"></span><br><span class="line">..Q.</span><br><span class="line">Q...</span><br><span class="line">...Q</span><br><span class="line">.Q..</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>思路：<br>每一行必定有一个皇后，对行进行深度遍历。<br>对于第 r 行的第 i 个位置，判断每个点是否可以放皇后，如果可以，则放皇后，然后处理 r + 1 行。<br>直到 r = n，程序指行完毕。<br><img src="https://git.acwing.com/Hasity/jnu/-/raw/master/acwing/n-hh.png" alt></p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法一：按列枚举</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> row[N] , col[N] , dg[N] , udg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( u == n )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) <span class="built_in">puts</span>( g[i] );</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - i + u] )&#123;<span class="comment">//当满足列没有皇后，对角线没有皇后，反对角线没有皇后</span></span><br><span class="line">                g[u][i] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//这一格子放置皇后</span></span><br><span class="line">                col[i] = dg[u + i] = udg[n - i + u] = <span class="literal">true</span>;<span class="comment">//此时这一列，这一对角线，这一反对角线就不能放置皇后了</span></span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);<span class="comment">//递归到下一层</span></span><br><span class="line">                col[i] = dg[u + i] = udg[n - i + u] = <span class="literal">false</span>;<span class="comment">//递归出来后返回上一层，并还原现场</span></span><br><span class="line">                g[u][i] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//把皇后给做掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n; j++) g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二：遍历每一个格子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> row[N] , col[N] , dg[N] , udg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y , <span class="type">int</span> s)</span></span>&#123;<span class="comment">//表示第x行第y列，放置了s个皇后</span></span><br><span class="line">    <span class="keyword">if</span>( y == n ) y = <span class="number">0</span> , x++;<span class="comment">//当当前x行已经到达边界，转到下一行，列数归零</span></span><br><span class="line">    <span class="keyword">if</span>( x == n )&#123;<span class="comment">//当到最后一个行，如果此时已经存在了n个皇后，就输出结果</span></span><br><span class="line">        <span class="keyword">if</span>( s == n )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) <span class="built_in">puts</span>( g[i] );</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放皇后</span></span><br><span class="line">    <span class="keyword">if</span>( !row[x] &amp;&amp; !col[y] &amp;&amp; !dg[y+x] &amp;&amp; !udg[y-x+n] )&#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[y-x+n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y+<span class="number">1</span>, s+<span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x+y] = udg[y - x + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不放置皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>( x , y+<span class="number">1</span> , s );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n; j++) g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="宽度优先搜索（BFS）"><a href="#宽度优先搜索（BFS）" class="headerlink" title="宽度优先搜索（BFS）"></a>宽度优先搜索（BFS）</h1><p>仅当所有边权重相同时，用bfs求最短路<br><strong>题目：<a href="https://www.acwing.com/problem/content/846/">走迷宫</a></strong><br>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1 ，其中 0 表示可以走的路，1 表示不可通过的墙壁。<br>最初，有一个人位于左上角 (1,1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。<br>请问，该人从左上角移动至右下角 (n,m)处，至少需要移动多少次。<br>数据保证 (1,1)处和 (n,m)处的数字为 0 ，且一定至少存在一条通路。</p>
<p>输入格式<br>第一行包含两个整数 n 和 m 。<br>接下来 n 行，每行包含 m 个整数（0 或 1 ），表示完整的二维数组迷宫。</p>
<p>输出格式<br>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p>
<p>数据范围<br>1≤n,m≤100</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">0 1 0 0 0</span><br><span class="line">0 1 0 1 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 1 1 1 0</span><br><span class="line">0 0 0 1 0</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//记录图</span></span><br><span class="line"><span class="type">int</span> d[N][N];<span class="comment">//记录各点到起点的距离</span></span><br><span class="line">PII q[N*N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);<span class="comment">//初始化距离为1</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first+dx[i], y = t.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/847/">八数码</a></strong><br>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在这 3×3 的网格中。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">x 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure><br>在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 x</span><br></pre></td></tr></table></figure><br>例如，示例中图形就可以通过让 x 先后与右、下、右三个方向的数字交换成功得到正确排列。<br>交换过程如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3   1 2 3   1 2 3   1 2 3</span><br><span class="line">x 4 6   4 x 6   4 5 6   4 5 6</span><br><span class="line">7 5 8   7 5 8   7 x 8   7 8 x</span><br></pre></td></tr></table></figure><br>现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。</p>
<p>输入格式<br>输入占一行，将 3×3 的初始网格描绘出来。<br>例如，如果初始网格如下所示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">x 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure><br>则输入为：1 2 3 x 4 6 7 5 8</p>
<p>输出格式<br>输出占一行，包含一个整数，表示最少交换次数。<br>如果不存在解决方案，则输出 −1 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 1 5 x 7 6 8</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><br>思路：<br>从起点开始，往前走第一步，记录下所有第一步能走到的点，然后从所第一步能走到的点开始，往前走第二步，记录下所有第二步能走到的点，重复下去，直到走到终点。输出步数即可。<br>暴力穷举。穷举出所有给定序列通过交换能得到的新序列，在穷举过程中保存交换次数。<br>在穷举过程中，如果出现了结果序列，就输出交换次数。<br>否则不能得到结果序列，输出 -1。<br><img src="https://git.acwing.com/Hasity/jnu/-/raw/master/acwing/485.png" alt></p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h1><h2 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h2><p>树是无环的连通图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p>
<p>有向图的存储结构：</p>
<ul>
<li>邻接矩阵：g[a][b] 存储边a-&gt;b</li>
<li>邻接表<ul>
<li>用 h 数组保存各个节点能到的第一个节点的编号。开始时，h[i] 全部为 -1。 </li>
<li>用 e 数组保存节点编号，ne 数组保存 e 数组对应位置的下一个节点所在的索引。 </li>
<li>用 idx 保存下一个 e 数组中，可以放入节点位置的索引 </li>
<li>插入边使用的头插法，例如插入：a-&gt;b。首先把b节点存入e数组，e[idx] = b。然后 b 节点的后继是h[a]，ne[idx] = h[a]。最后，a 的后继更新为 b 节点的编号，h[a] = idx，索引指向下一个可以存储节点的位置，idx ++<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure>
<h2 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度 O(n+m), n 表示点数，m 表示边数<br><strong>题目：<a href="https://www.acwing.com/problem/content/848/">树的重心</a></strong><br>给定一颗树，树中包含 n 个结点（编号 1∼n ）和 n−1 条无向边。 请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。<br>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</li>
</ul>
</li>
</ul>
<p>输入格式<br>第一行包含整数 n ，表示树的结点数。<br>接下来 n−1 行，每行包含两个整数 a 和 b ，表示点 a 和点 b 之间存在一条边。</p>
<p>输出格式<br>输出一个整数 m ，表示将重心删除后，剩余各个连通块中点数的最大值。</p>
<p>数据范围<br>1≤n≤105</p>
<p>输入样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 2</span><br><span class="line">1 7</span><br><span class="line">1 4</span><br><span class="line">2 8</span><br><span class="line">2 5</span><br><span class="line">4 3</span><br><span class="line">3 9</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br>思路：<br><img src="https://cdn.acwing.com/media/article/image/2020/05/22/652_ab4f9f7c9b-1.png" alt><br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, M = N*<span class="number">2</span>;<span class="comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">//h[N]邻接表存储树;e[M]存储元素;ne[M]存储列表的next值;idx单链表指针</span></span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//记录节点是否被访问过，访问过则标记为true</span></span><br><span class="line"><span class="type">int</span> ans = N;<span class="comment">//表示重心的所有的子树中，最大的子树的结点数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a所对应的单链表中插入b  a作为根 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以u为根的子树中节点的个数，包括u节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//标记一下，已经被搜索过了</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//存储删掉某个节点之后，最大的连通子图节点数</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>; <span class="comment">//存储以u为根的树的节点数, 包括u</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;<span class="comment">//访问u的每个子节点</span></span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);<span class="comment">//u节点的单棵子树节点数</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, s);<span class="comment">//记录最大联通子图的节点数</span></span><br><span class="line">            sum += s;<span class="comment">//以j为根的树的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);<span class="comment">//选择u节点为重心，最大的 连通子图节点数</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res, ans);<span class="comment">//遍历过的假设重心中，最小的最大联通子图的节点数</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//初始化h数组 -1表示尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="树与图的宽度优先遍历"><a href="#树与图的宽度优先遍历" class="headerlink" title="树与图的宽度优先遍历"></a>树与图的宽度优先遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n+m), n 表示点数，m 表示边数<br><strong>题目：<a href="https://www.acwing.com/problem/content/849/">图中点的层次</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。<br>所有边的长度都是 1 ，点的编号为 1∼n 。<br>请你求出 1 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1 。</p>
<p>输入格式<br>第一行包含两个整数 n 和 m 。<br>接下来 m 行，每行包含两个整数 a 和 b ，表示存在一条从 a 走到 b 的长度为 1 的边。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p>
<p>数据范围<br>1≤n,m≤105</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], idx, ne[N];</span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//存储每个节点离起点的距离</span></span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">//存储层次遍历序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//0号节点是编号为1的节点</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//存储每个节点离起点的距离</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;<span class="comment">//队列不为空时</span></span><br><span class="line">        <span class="type">int</span> t = q[hh++];<span class="comment">//取出队列头部节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)&#123;<span class="comment">//j没有被扩展过</span></span><br><span class="line">            <span class="comment">//数组模拟队列</span></span><br><span class="line">                d[j]=d[t]+<span class="number">1</span>; <span class="comment">//d[j]存储j节点离起点的距离，并标记为访问过</span></span><br><span class="line">                q[++tt] = j; <span class="comment">//把j结点，压入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>有向图宽搜的应用<br>一个有向图，如果图中有入度为 0 的点，就把这个点删掉，同时也删掉这个点所连的边。<br>一直进行上面出处理，如果所有点都能被删掉，则这个图可以进行拓扑排序。</p>
<p><strong>一个有效的无环图一定至少存在一个入度为0的点（证明：反证法）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n+m), n 表示点数，m 表示边数<br><strong>题目：<a href="https://www.acwing.com/problem/content/850/">有向图的拓扑排序</a></strong><br>给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n ，图中可能存在重边和自环。<br>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1 。<br>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p>
<p>输入格式<br>第一行含两个整数 n 和 m 。<br>接下来 m 行，每行包含两个整数 x 和 y ，表示存在一条从点 x 到点 y 的有向边 (x,y)。</p>
<p>输出格式<br>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。<br>否则输出 −1 。</p>
<p>数据范围<br>1≤n,m≤105</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><br>思路：<br>首先记录各个点的入度<br>然后将入度为 0 的点放入队列<br>将队列里的点依次出队列，然后找出所有出队列这个点发出的边，删除边，同事边的另一侧的点的入度 -1。<br>如果所有点都进过队列，则可以拓扑排序，输出所有顶点。否则输出-1，代表不可以进行拓扑排序。</p>
<p>代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//图的点数和边数</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">//邻接表存储图</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//保存各个点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;<span class="comment">//遍历一遍顶点的入度</span></span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0</span>)&#123;<span class="comment">//如果入度为0,则可以入队列</span></span><br><span class="line">            q[++tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tt &gt;= hh)&#123;<span class="comment">//循环处理队列中点的</span></span><br><span class="line">        <span class="type">int</span> a = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[a]; i != <span class="number">-1</span>; i = ne[i])&#123;<span class="comment">//循环删除a发出的边</span></span><br><span class="line">            <span class="type">int</span> b = e[i];<span class="comment">//a有一条边指向b</span></span><br><span class="line">            d[b]--;<span class="comment">//删除边后，b的入度减1</span></span><br><span class="line">            <span class="keyword">if</span>(d[b] == <span class="number">0</span>)<span class="comment">//如果b的入度减为0,则b可以输出入队列</span></span><br><span class="line">                q[++tt] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tt == n<span class="number">-1</span>)&#123;<span class="comment">//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//队列中保存所有入度为0的点，依次输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果队列中的点的个数与图中点的个数不相同，则进行拓扑排序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        d[b]++;<span class="comment">//顶点b的入度+1</span></span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p><strong>建图</strong>   <strong>抽象</strong></p>
<ul>
<li>单源最短路<ul>
<li>所有边权都是正数<ul>
<li>朴素Dijkstra算法<br>时间复杂度：O(n^2)，稠密图</li>
<li>堆优化版的Dijkstra算法<br>时间复杂度：O(mlogn)，稀疏图</li>
</ul>
</li>
<li>存在负权边<ul>
<li>Bellman-ford算法<br>时间复杂度：O(nm)</li>
<li>SPFA算法<br>时间复杂度：一般0(m)，最坏0(nm)</li>
</ul>
</li>
</ul>
</li>
<li>多源汇最短路<br>Floyd算法<br>时间复杂度：O(n^3)<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂是 O(n^2+m), n 表示点数，m 表示边数</li>
</ul>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路 I</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1 。</p>
<p>输入格式<br>第一行包含整数 n 和 m 。<br>接下来 m 行每行包含三个整数 x,y,z ，表示存在一条从点 x 到点 y 的有向边，边长为 z 。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。 如果路径不存在，则输出 −1 。</p>
<p>数据范围<br>1≤n≤500 , 1≤m≤105 , 图中涉及边长均不超过10000。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));<span class="comment">//存储每一个点到源点的距离</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//源点到自己的距离为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;<span class="comment">//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))&#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);<span class="comment">//将点之间的距离的每一个值设置成很大的数</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);<span class="comment">//解决多条边的问题，保留最短边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="堆优化版的Dijkstra"><a href="#堆优化版的Dijkstra" class="headerlink" title="堆优化版的Dijkstra"></a>堆优化版的Dijkstra</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(mlogn), n 表示点数，m 表示边数</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/852/">Dijkstra求最短路 II</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。<br>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1 。</p>
<p>输入格式<br>第一行包含整数 n 和 m 。<br>接下来 m 行每行包含三个整数 x,y,z ，表示存在一条从点 x 到点 y 的有向边，边长为 z 。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。<br>如果路径不存在，则输出 −1 。</p>
<p>数据范围<br>1≤n,m≤1.5×105 , 图中涉及边长均不小于 0 ，且不超过 10000 。<br>数据保证：如果最短路存在，则最短路的长度不超过 109 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance+w[i])&#123;</span><br><span class="line">                dist[j] = distance+w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman-ford"></a>Bellman-ford</h2><p>松弛操作，三角不等式：dist[b]&lt;=dist[a]+w<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度 O(nm), n 表示点数，m 表示边数<br><strong><em>注意：在模板题中需要对以上模板稍作修改，加上备份数组</em></strong>，不加备份可能导致串联</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/855/">有边数限制的最短路</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。<br>注意：图中可能 存在负权回路 。</p>
<p>输入格式<br>第一行包含三个整数 n,m,k 。 接下来 m 行，每行包含三个整数 x,y,z ，表示存在一条从点 x 到点 y 的有向边，边长为 z 。 点的编号为 1∼n 。</p>
<p>输出格式<br>输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。<br>如果不存在满足条件的路径，则输出 impossible。</p>
<p>数据范围<br>1≤n,k≤500 ,<br>1≤m≤10000 ,<br>1≤x,y≤n ，<br>任意边长的绝对值不超过 10000 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, M = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="type">int</span> dist[M], last[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = edges[j];</span><br><span class="line">            dist[t.b] = <span class="built_in">min</span>(dist[t.b], last[t.a]+t.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span>&gt;&gt;<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dist[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>在Bellman-Ford的基础上通过宽搜进行优化，在迭代时使用一个队列，先将起点放到队列中，只要队列不空，队列中存变小的数，更新其对应的</p>
<h3 id="spfa-算法（队列优化的Bellman-Ford算法）"><a href="#spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="spfa 算法（队列优化的Bellman-Ford算法）"></a>spfa 算法（队列优化的Bellman-Ford算法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/description/853/">spfa求最短路</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。<br>数据保证不存在负权回路。</p>
<p>输入格式<br>第一行包含整数 n 和 m 。<br>接下来 m 行每行包含三个整数 x,y,z ，表示存在一条从点 x 到点 y 的有向边，边长为 z 。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。<br>如果路径不存在，则输出 impossible。</p>
<p>数据范围<br>1≤n,m≤105 , 图中涉及边长绝对值均不超过 10000 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 -3</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;  <span class="comment">// 添加一条边a-&gt;b，边权为c</span></span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;  <span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//存储当点是否在队列中，防止队列中存储重复的点</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i =ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t]+w[i])&#123;</span><br><span class="line">                dist[j] = dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="spfa判断图中是否存在负环"><a href="#spfa判断图中是否存在负环" class="headerlink" title="spfa判断图中是否存在负环"></a>spfa判断图中是否存在负环</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 O(nm), n 表示点数，m 表示边数</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/854/">spfa判断负环</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你判断图中是否存在负权回路。</p>
<p>输入格式<br>第一行包含整数 n 和 m 。<br>接下来 m 行每行包含三个整数 x,y,z ，表示存在一条从点 x 到点 y 的有向边，边长为 z 。</p>
<p>输出格式<br>如果图中存在负权回路，则输出 Yes，否则输出 No。</p>
<p>数据范围<br>1≤n≤2000 ,<br>1≤m≤10000 ,<br>图中涉及边长绝对值均不超过 10000 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 -1</span><br><span class="line">2 3 4</span><br><span class="line">3 1 -4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;  <span class="comment">// 添加一条边a-&gt;b，边权为c</span></span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t]+w[i])&#123;</span><br><span class="line">                dist[j] = dist[t]+w[i];</span><br><span class="line">                cnt[j] = cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 O(n3), n 表示点数</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/856/">Floyd求最短路</a></strong><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。<br>再给定 k 个询问，每个询问包含两个整数 x 和 y ，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 impossible。<br>数据保证图中不存在负权回路。</p>
<p>输入格式<br>第一行包含三个整数 n,m,k 。<br>接下来 m 行，每行包含三个整数 x,y,z ，表示存在一条从点 x 到点 y 的有向边，边长为 z 。<br>接下来 k 行，每行包含两个整数 x,y ，表示询问点 x 到点 y 的最短距离。</p>
<p>输出格式<br>共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。</p>
<p>数据范围<br>1≤n≤200 ,<br>1≤k≤n^2<br>1≤m≤20000 ,<br>图中涉及边长绝对值均不超过 10000 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 1</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impossible</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        <span class="keyword">if</span> (t &gt; M&gt;&gt;<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h1><p>朴素版prim算法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度是 O(n^2+m), n 表示点数，m 表示边数</p>
<p>题目 ：<a href="https://www.acwing.com/problem/content/860/">Prim算法求最小生成树</a><br>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。<br>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。<br>给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V| ，m=|E| 。<br>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。</p>
<p>输入格式<br>第一行包含两个整数 n 和 m 。<br>接下来 m 行，每行包含三个整数 u,v,w ，表示点 u 和点 v 之间存在一条权值为 w 的边。</p>
<p>输出格式<br>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p>
<p>数据范围<br>1≤n≤500 ,<br>1≤m≤105 ,<br>图中涉及边的边权的绝对值均不超过 10000 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">2 3 2</span><br><span class="line">3 4 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t]==INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 O(mlogm), n 表示点数，m 表示边数</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/861/">Kruskal算法求最小生成树</a></strong><br>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。<br>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。<br>给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V| ，m=|E| 。<br>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。</p>
<p>输入格式<br>第一行包含两个整数 n 和 m 。<br>接下来 m 行，每行包含三个整数 u,v,w ，表示点 u 和点 v 之间存在一条权值为 w 的边。</p>
<p>输出格式<br>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p>
<p>数据范围<br>1≤n≤105 ,<br>1≤m≤2∗105 ,<br>图中涉及边的边权的绝对值均不超过 1000 。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">2 3 2</span><br><span class="line">3 4 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 O(n+m), n 表示点数，m 表示边数</p>
<p><strong>题目：<a href></a></strong></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是 O(nm), n 表示点数，m 表示边数</p>
<p><strong>题目：<a href></a></strong></p>
<p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/post/a444b428.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="排序概述.png" alt="排序概述"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>排序的分类</p>
<p>内部排序和外部排序 ：待排序记录全部存放在计算机内存中进行排序的过程称为内部排序；在排序过程中需对外存进行访问的排序过程</p>
<h2 id="待排序记录的存储方式"><a href="#待排序记录的存储方式" class="headerlink" title="待排序记录的存储方式"></a>待排序记录的存储方式</h2><ol>
<li>顺序表：实现排序需要移动记录</li>
<li>链表：实现排序不需要移动记录，仅需修改指针即可。这种排序方式称为链表排序</li>
<li>地址排序：在排序过程中不移动记录本身，而移动地址向量这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置</li>
</ol>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的原理：</p>
<p>一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法 。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动 。</p>
<p>选择排序的基本思想是：</p>
<p>将未排序的元素一个一个地插入到有序的集合中，插入时把所有有序集合从后向前扫一遍，找到合适的位置插入</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><img src="https://img-blog.csdnimg.cn/00b85e13a79f40a1b508e527b60f1f87.gif" alt></p>
<p>算法思想：</p>
<p>具体实现：</p>
<ol>
<li><p>单趟的实现（将x插入到 [0,end] 的有序区间）</p>
<p>即一般情况下的插入，我们随机列举了一些数字，待插入的数字分为两种情况</p>
<ul>
<li>待插入的数字是在前面有序数字的中间数，直接比较将x赋值给end+1位置</li>
<li>x是最小的一个数，end就会到达-1的位置，最后直接将x赋值给end+1位置</li>
</ul>
</li>
<li><p>整个数组排序的实现</p>
<p>我们一开始并不知道数组是不是有序的，所以我们控制下标，end从0开始，将end+1位置的值始终保存到x中，循环进行单趟排序即可，最后结束时end=n-2，n-1位置的数字保存到x中</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	assert(a);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;<span class="comment">//因为x元素位置是i的下一个位置，为防止x越界，需要使 i &lt; n-1</span></span><br><span class="line">		<span class="type">int</span> end = i;<span class="comment">//已经有序的最后一个元素(一个元素不需要排序，所以默认从0开始)</span></span><br><span class="line">		<span class="type">int</span> x = a[end + <span class="number">1</span>];<span class="comment">//需要排序的元素</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//单趟</span></span><br><span class="line">		<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//若前一个数字大于x，则需将他向右移动</span></span><br><span class="line">			<span class="keyword">if</span> (a[end] &gt; x)&#123;</span><br><span class="line">				a[end + <span class="number">1</span>] = a[end];</span><br><span class="line">                <span class="comment">//继续判断前面的元素</span></span><br><span class="line">				--end;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//前面元素小于x</span></span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//将x插入正确位置(两种情况)</span></span><br><span class="line">        <span class="comment">//1.前面的数字小于x</span></span><br><span class="line">        <span class="comment">//2.前面的数字都大于x，x放在下标为0处</span></span><br><span class="line">		a[end + <span class="number">1</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>元素集合越接近有序，直接插入排序算法的时间效率越高</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)，不借助额外的空间，只用到常数个变量</li>
<li>稳定性：稳定</li>
</ol>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>算法思想：</p>
<p>折半插入排序的思想是借用了折半查找的思路，通过在已经有序的序列（默认序列第一个元素为有序序列）中利用二分查找快速定位插入位置，这样经过n-1趟插入就能完成排序，<strong>当元素较多时，折半插入排序效率更优于直接插入排序</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201228144603329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h0MTk5NzEx,size_16,color_FFFFFF,t_70#pic_center" style="zoom:80%;"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySearch</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span> </span>&#123;<span class="comment">//折半插入排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;<span class="comment">//默认第一个元素为有序序列，所以从1开始循环</span></span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;<span class="comment">//如果当前元素大于等于有序序列所有元素，不需要进行查找插入</span></span><br><span class="line">			<span class="type">int</span>  key = arr[i];<span class="comment">//标记待插入元素</span></span><br><span class="line">			<span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">				<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">					right = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					left = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt; right; j--) &#123;<span class="comment">//顺序后移</span></span><br><span class="line">				arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			arr[right + <span class="number">1</span>] = key;<span class="comment">//插入元素</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size)</span> </span>&#123;<span class="comment">//数组打印</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span> &#125;;</span><br><span class="line">	<span class="comment">//int arr[] = &#123; 15,1,1,45,12,125,15,45,20,-3 &#125;;</span></span><br><span class="line">	<span class="type">int</span> size = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span>;</span><br><span class="line">	<span class="built_in">PrintArr</span>(arr, size);</span><br><span class="line">	<span class="built_in">BinarySearch</span>(arr, size);</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;排序后：&quot;</span>;</span><br><span class="line">	<span class="built_in">PrintArr</span>(arr, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//折半插入排序 是针对 在 整个顺序表 或 数组的&quot;有序区&quot;里 用&#x27;二分查找法&#x27;</span></span><br><span class="line"><span class="comment">//先查找到 待插入元素A[i]应该插入的位置，然后再移动比A[i]大的元素，最后插入A[i]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//所以这里的&quot;折半&quot;,是对数组 或 顺序表 &quot;有序区&quot; 的折半,而不是对整个数组的折半.</span></span><br><span class="line"><span class="comment">//！！ A[i]最后插入的位置一定是A[low]或者A[high+1]; (这里low = high +1)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//这个大的for循环作用: 提供需要排序的元素(从A[2]~A[n-1]) (时间复杂度：O(n))</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; n;i++)&#123;    <span class="comment">//这里i从2开始，那是因为A[1]是默认排好了的</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];             <span class="comment">//将要排序的元素先放在A[0]里</span></span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//下面要开始找目前A[0]中的元素 所 应该排的位置</span></span><br><span class="line">        <span class="comment">//用二分查找法查找</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;  <span class="comment">//本轮循环作用：找A[0]应该插入的位置 (时间复杂度:O(log2n))</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;    <span class="comment">//注意,这个&#x27;时间复杂度&#x27;是&quot;比较&quot;！！</span></span><br><span class="line">            <span class="keyword">if</span>(A[<span class="number">0</span>] &lt; A[mid])</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;        <span class="comment">//这一轮循环结束时,(如果没有重复元素，必定是查找失败的)</span></span><br><span class="line">                 <span class="comment">//这时low &gt; high 且 low = high + 1;</span></span><br><span class="line">                 <span class="comment">//因为二分查找的区间是顺序表，所以low所指的元素&gt;A[0]&gt;high所指的元素</span></span><br><span class="line">                 <span class="comment">//因此这轮的A[0]最后会被插在A[low]的位置中(或者说A[high + 1])</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>;j &lt;= low;j--)&#123;        <span class="comment">//本轮循环作用： 移动元素</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];                    <span class="comment">//这轮循环的时间复杂度：O(n)</span></span><br><span class="line">        &#125;                                <span class="comment">//注意！这个&#x27;时间复杂度&#x27;是&quot;移动元素&quot;！！</span></span><br><span class="line">        A[low] = A[<span class="number">0</span>];        <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>时间复杂度：<ul>
<li>最坏：O(n^2)</li>
<li>最好：O(n)</li>
<li>平均：O(n^2)</li>
</ul>
</li>
<li>空间复杂度：O(1)</li>
</ol>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="https://img-blog.csdnimg.cn/444ef28aec974877aef0525aa7ea5ff3.gif" alt></p>
<p>算法思想：</p>
<ol>
<li>先选定个小于n的数字作为gap，所有距离为gap的数分为一组进行预排序（直接插入排序）</li>
<li>再选一个小于gap的数，重复①的操作</li>
<li>当gap=1时，相当于整个数组就是一组，再进行一次插入排序即可整体有序</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	assert(a);</span><br><span class="line">	<span class="type">int</span> gap = n;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//gap /= 2;</span></span><br><span class="line">		gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; i++)&#123;</span><br><span class="line">			<span class="type">int</span> end = i;</span><br><span class="line">			<span class="type">int</span> x = a[end + gap];</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[end] &gt; x)&#123;</span><br><span class="line">					a[end + gap] = a[end];</span><br><span class="line">					end -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			a[end + gap] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>希尔排序是对直接插入排序的优化。</li>
<li>当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组接近有序的，整体而言，可以达到优化的效果</li>
<li>时间复杂度O(n^1.5)</li>
<li>空间复杂度O(1)</li>
<li>稳定性：不稳定</li>
</ol>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://img-blog.csdnimg.cn/a5e3abf018e74af8a5c3ac1891fb393a.gif" alt></p>
<p>算法思想：</p>
<p>一趟过程中，前后两个数依次比较，将较大的数字往后推，下一次只需要比较剩下的n-1个数，如此往复</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//n-1趟排序</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//一趟冒泡排序</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">				Swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//若某一趟排序中没有元素交换则说明所有元素已经有序，不需要再排序</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想：</p>
<p>任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="hoare版本"><a href="#hoare版本" class="headerlink" title="hoare版本"></a>hoare版本</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/7de14d7887bbb5c76e6ab6194c599621.gif" alt></p>
<p>算法思想：</p>
<ol>
<li>选定一个基准值，最好选定最左边或者最右边，选中间会给自己找麻烦</li>
<li>确定两个指针left 和right 分别从左边和右边向中间遍历数组</li>
<li>如果选最右边为基准值，那么left指针先走，如果遇到大于基准值的数就停下来</li>
<li>然后右边的指针再走，遇到小于基准值的数就停下来</li>
<li>交换left和right指针对应位置的值</li>
<li>重复以上步骤，直到left = right ，最后将基准值与left(right)位置的值交换</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序hoare版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = right;<span class="comment">//选定基准值</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">		<span class="comment">//选右边为基准值，左指针先走</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[key])&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//右指针再走</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[key])&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		Swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">	&#125;</span><br><span class="line">	Swap(&amp;a[left], &amp;a[key]);</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> keyi = PartSort1(a, left, right);</span><br><span class="line">	QuickSort(a, left, keyi - <span class="number">1</span>);</span><br><span class="line">	QuickSort(a, keyi + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/62ae666f81812fb76a8f6676d33c4215.gif" alt></p>
<p>算法思想：</p>
<ol>
<li>先将选定的基准值(最左边)直接取出，然后留下一个坑</li>
<li>当右指针遇到小于基准值的数时，直接将该值放入坑中，而右指针指向的位置形成新的坑位</li>
<li>然后左指针遇到大于基准值的数时，将该值放入坑中，左指针指向的位置形成坑位</li>
<li>重复该步骤，直到左右指针相等。最后将基准值放入坑位之中</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序挖坑法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = a[left];<span class="comment">//取出基准值</span></span><br><span class="line">	<span class="type">int</span> hole = left;<span class="comment">//保存坑的位置</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[hole] = a[right];</span><br><span class="line">		hole = right;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		a[hole] = a[left];</span><br><span class="line">		hole = left;</span><br><span class="line">	&#125;</span><br><span class="line">	a[hole] = key;</span><br><span class="line">	<span class="keyword">return</span> hole;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> keyi = PartSort2(a, left, right);</span><br><span class="line">	QuickSort(a, left, keyi - <span class="number">1</span>);</span><br><span class="line">	QuickSort(a, keyi + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前后指针法"><a href="#前后指针法" class="headerlink" title="前后指针法"></a>前后指针法</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/6fc207992e96086431fa77fc0dd17117.gif" alt></p>
<p>算法思想：</p>
<ol>
<li>选定基准值，定义prev和cur指针(cur = prev + 1)</li>
<li>cur先走，遇到小于基准值的数停下，然后将prev向后移动一个位置</li>
<li>将prev对应值与cur对应值交换</li>
<li>重复上面的步骤，直到cur走出数组范围</li>
<li>最后将基准值与prev对应位置交换</li>
<li>递归排序以基准值为界限的左右区间</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序前后指针法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="comment">//1.将基准值定在left</span></span><br><span class="line">	<span class="type">int</span> keyi = left;</span><br><span class="line">	<span class="type">int</span> prev = left;</span><br><span class="line">	<span class="type">int</span> cur =  left + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur] &lt; a[keyi] &amp;&amp; ++prev != cur)&#123;</span><br><span class="line">			Swap(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">		&#125;</span><br><span class="line">		cur++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	Swap(&amp;a[prev], &amp;a[keyi]);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//2.将基准值定在right</span></span><br><span class="line">	<span class="comment">/*int keyi = right;</span></span><br><span class="line"><span class="comment">	int prev = left - 1;</span></span><br><span class="line"><span class="comment">	int cur = prev + 1;</span></span><br><span class="line"><span class="comment">	while (cur &lt;= right)&#123;</span></span><br><span class="line"><span class="comment">		if (a[cur] &lt; a[keyi] &amp;&amp; ++prev != cur)&#123;</span></span><br><span class="line"><span class="comment">			Swap(&amp;a[cur], &amp;a[prev]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		cur++;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Swap(&amp;a[keyi], &amp;a[++prev]);</span></span><br><span class="line"><span class="comment">	return prev;*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> keyi = PartSort2(a, left, right);</span><br><span class="line">	QuickSort(a, left, keyi - <span class="number">1</span>);</span><br><span class="line">	QuickSort(a, keyi + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在基准值的选择上，如果选择的基准值为恰好为最小值，会进行不必要的递归。</p>
<p>在排序大量有序数据或者接近有序数据时，效率会比较低，甚至可能会出现程序崩溃的情况。</p>
<p>这是因为在排序有序数据时，快速排序的递归调用次数过多，会导致栈溢出的情况。</p>
<p>为了解决这些问题，这里有两种优化方法：</p>
<ol>
<li>三数取中法选基准值</li>
<li>递归到小的子区间时，可以考虑使用插入排序</li>
</ol>
<h4 id="三位数取中法"><a href="#三位数取中法" class="headerlink" title="三位数取中法"></a>三位数取中法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三数取中</span></span><br><span class="line"><span class="comment">//即在在起始位置，中间位置，末尾位置中选出中间值，作为基准值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MidIndex</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//防止mid越界</span></span><br><span class="line">	<span class="comment">//int mid = left+(right - left) / 2;</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (a[left] &lt; a[right])&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; a[left])&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; a[right])&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &gt; a[left])&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; a[right])&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归到小子区间"><a href="#递归到小子区间" class="headerlink" title="递归到小子区间"></a>递归到小子区间</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序前后指针法</span></span><br><span class="line"><span class="comment">//类似于二叉树，每个子树都会进行一次递归调用，越到下面递归调用会越多。为了减少递归调用，当到递归到下层时，我们可以使用其他的排序来替代。这里我们使用插入排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PartSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = MidIndex(a, left, right);</span><br><span class="line">	<span class="comment">//将基准位置调整至最左边</span></span><br><span class="line">	Swap(&amp;a[mid], &amp;a[left]);</span><br><span class="line">	<span class="comment">//1.将基准值定在left</span></span><br><span class="line">	<span class="type">int</span> keyi = left;</span><br><span class="line">	<span class="type">int</span> prev = left;</span><br><span class="line">	<span class="type">int</span> cur =  left + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur] &lt; a[keyi] &amp;&amp; ++prev != cur)&#123;</span><br><span class="line">			Swap(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">		&#125;</span><br><span class="line">		cur++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	Swap(&amp;a[prev], &amp;a[keyi]);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//2.将基准值定在right</span></span><br><span class="line">	<span class="comment">/*int keyi = right;</span></span><br><span class="line"><span class="comment">	int prev = left - 1;</span></span><br><span class="line"><span class="comment">	int cur = prev + 1;</span></span><br><span class="line"><span class="comment">	while (cur &lt;= right)&#123;</span></span><br><span class="line"><span class="comment">		if (a[cur] &lt; a[keyi] &amp;&amp; ++prev != cur)&#123;</span></span><br><span class="line"><span class="comment">			Swap(&amp;a[cur], &amp;a[prev]);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		cur++;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	Swap(&amp;a[keyi], &amp;a[++prev]);</span></span><br><span class="line"><span class="comment">	return prev;*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//小区间优化，，减少递归次数</span></span><br><span class="line">	<span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; <span class="number">10</span>)&#123;</span><br><span class="line">		InsertSort(a + left, right -left + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> keyi = PartSort3(a, left, right);</span><br><span class="line">		QuickSort(a, left, keyi - <span class="number">1</span>);</span><br><span class="line">		QuickSort(a, keyi + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>快速排序非递归实现，需要借助栈，栈中<strong>存放</strong>的是需要排序的<strong>左右区间</strong>。</p>
<p>非递归可以彻底<strong>解决栈溢出</strong>的问题</p>
<p>算法思想：</p>
<ol>
<li>将数组左右下标入栈，</li>
<li>若栈不为空，两次取出栈顶元素，分别为闭区间的左右界限</li>
<li>将区间中的元素按照前后指针法排序(其余两种也可)得到基准值的位置</li>
<li>再以基准值为界限，若基准值左右区间中有元素，则将区间入栈</li>
<li>重复上述步骤直到栈为空</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序 非递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//创建栈</span></span><br><span class="line">	Stack st;</span><br><span class="line">	StackInit(&amp;st);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//原始数组区间入栈</span></span><br><span class="line">	StackPush(&amp;st, right);</span><br><span class="line">	StackPush(&amp;st, left);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将栈中区间排序</span></span><br><span class="line">	<span class="keyword">while</span> (!StackEmpty(&amp;st))&#123;</span><br><span class="line">        <span class="comment">//注意：如果right先入栈，栈顶为left</span></span><br><span class="line">		left = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">		right = StackTop(&amp;st);</span><br><span class="line">		StackPop(&amp;st);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//得到基准值</span></span><br><span class="line">		<span class="type">int</span> mid = PartSort3(a, left, right);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 以基准值为分割点，形成左右两部分</span></span><br><span class="line">		<span class="keyword">if</span> (right &gt; mid+<span class="number">1</span>)&#123;</span><br><span class="line">			StackPush(&amp;st, right);</span><br><span class="line">			StackPush(&amp;st, mid + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; mid - <span class="number">1</span>)&#123;</span><br><span class="line">			StackPush(&amp;st, mid - <span class="number">1</span>);</span><br><span class="line">			StackPush(&amp;st, left);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	StackDestroy(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>快速排序整体的综合性能和使用场景都较好</li>
<li>时间复杂度：O(n*logn)</li>
<li>空间复杂度：O(logn)</li>
<li>稳定性：不稳定</li>
</ol>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p><img src="https://img-blog.csdnimg.cn/8e90e3d6567746f7a88ec1b8c76129e2.gif" alt></p>
<p>算法思想：</p>
<p>每次从数组中选出最大的或者最小的，存放在数组的最右边或者最左边，直到全部有序</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	assert(a);</span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;<span class="comment">//保存数组的起始位置</span></span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;<span class="comment">//保存换数组的末尾位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)&#123;</span><br><span class="line">		<span class="type">int</span> maxi = begin;<span class="comment">//保存最大元素下标</span></span><br><span class="line">		<span class="type">int</span> mini = begin;<span class="comment">//保存最小元素下标</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//遍历数组寻找最小和最大元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; a[mini])&#123;</span><br><span class="line">				mini = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &gt; a[maxi])&#123;</span><br><span class="line">				maxi = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//将最小元素交换到起始位置</span></span><br><span class="line">		Swap(a+begin, a+mini);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断最大值的位置是否在起始位置</span></span><br><span class="line">		<span class="keyword">if</span> (maxi == begin)&#123;</span><br><span class="line">			maxi = mini;    </span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将最大元素交换到末尾位置</span></span><br><span class="line">		Swap(a+end, a+maxi);</span><br><span class="line">        <span class="comment">//移动数组起始和末尾位置</span></span><br><span class="line">		begin++;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>直接选择排序效率较低</li>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ol>
<h2 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h2><p>锦标赛排序也叫树形选择排序，是一种按照锦标赛的思想进行选择的排序方法，该方法是在简单选择排序方法上的改进。简单选择排序，花费的时间大部分都浪费在值的比较上面，而锦标赛排序刚好用树保存了前面比较的结果，下一次比较时直接利用前面比较的结果，这样就大大减少比较的时间，从而降低了时间复杂度</p>
<p>算法思想：首先对 n 个记录的关键字进行两两比较，然后在其中 不大于 n/2 的整数个较小者之间再进行两两比较，直到选出最小关键字的记录为止。可以用一棵有 n 个叶子结点的完全二叉树表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span> <span class="comment">//malloc()等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">//EOF(=^Z或F6),NULL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;process.h&gt;</span> <span class="comment">//exit()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> InfoType;<span class="comment">//定义其它数据项的类型</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX 999</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------    待排记录的数据类型     ------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20<span class="comment">//一个用作示例的小顺序表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType; <span class="comment">//定义关键字类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">	InfoType otherinfo;<span class="comment">//其它数据项，具体类型在主程中定义</span></span><br><span class="line">&#125;RedType;<span class="comment">//记录类型</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	RedType r[MAXSIZE + <span class="number">1</span>];<span class="comment">//r[0]闲置或用作哨兵单元</span></span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表类型</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">TreeSort</span><span class="params">(SqList *L)</span>&#123;<span class="comment">//树形选择排序</span></span><br><span class="line">	<span class="type">int</span> i, j, j1, k, k1, l, n = (*L).length;</span><br><span class="line">	RedType *t;</span><br><span class="line">	l = (<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span><span class="comment">//完全二叉树的层数</span></span><br><span class="line">	k = (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, l) - <span class="number">1</span>;<span class="comment">//l层完全二叉树的结点总数</span></span><br><span class="line">	k1 = (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, l - <span class="number">1</span>) - <span class="number">1</span>;<span class="comment">//l-1层完全二叉树的结点总数</span></span><br><span class="line">	t = (RedType*)<span class="built_in">malloc</span>(k * <span class="keyword">sizeof</span>(RedType));<span class="comment">//二叉树采用顺序存储结构</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//将L.r赋给叶子结点</span></span><br><span class="line">		t[k1 + i - <span class="number">1</span>] = (*L).r[i];</span><br><span class="line">	<span class="keyword">for</span> (i = k1 + n; i &lt; k; i++)<span class="comment">//给多余的叶子的关键字赋无穷大</span></span><br><span class="line">		t[i].key = INT_MAX;</span><br><span class="line">	j1 = k1;</span><br><span class="line">	j = k;</span><br><span class="line">	<span class="keyword">while</span> (j1)&#123;<span class="comment">//给非叶子结点赋值</span></span><br><span class="line">		<span class="keyword">for</span> (i = j1; i &lt; j; i += <span class="number">2</span>)</span><br><span class="line">			t[i].key &lt; t[i + <span class="number">1</span>].key ? (t[(i + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>] = t[i]) : (t[(i + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>] = t[i + <span class="number">1</span>]);</span><br><span class="line">		j = j1;</span><br><span class="line">		j1 = (j1 - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		(*L).r[i + <span class="number">1</span>] = t[<span class="number">0</span>];<span class="comment">//将当前最小值赋给L.r[i]</span></span><br><span class="line">		j1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; l; j++)<span class="comment">//沿树根找结点t[0]在叶子中的序号j1</span></span><br><span class="line">			t[<span class="number">2</span> * j1 + <span class="number">1</span>].key == t[j1].key ? (j1 = <span class="number">2</span> * j1 + <span class="number">1</span>) : (j1 = <span class="number">2</span> * j1 + <span class="number">2</span>);</span><br><span class="line">		t[j1].key = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span> (j1)&#123;</span><br><span class="line">			j1 = (j1 + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;<span class="comment">//序号为j1的结点的双亲结点序号</span></span><br><span class="line">			t[<span class="number">2</span> * j1 + <span class="number">1</span>].key &lt;= t[<span class="number">2</span> * j1 + <span class="number">2</span>].key ? (t[j1] = t[<span class="number">2</span> * j1 + <span class="number">1</span>]) : (t[j1] = t[<span class="number">2</span> * j1 + <span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(SqList L)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L.length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, L.r[i].key, L.r[i].otherinfo);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 8</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	RedType d[N] = &#123; &#123;<span class="number">49</span>,<span class="number">1</span>&#125;,&#123;<span class="number">38</span>,<span class="number">2</span>&#125;,&#123;<span class="number">65</span>,<span class="number">3</span>&#125;,&#123;<span class="number">97</span>,<span class="number">4</span>&#125;,&#123;<span class="number">76</span>,<span class="number">5</span>&#125;,&#123;<span class="number">13</span>,<span class="number">6</span>&#125;,&#123;<span class="number">27</span>,<span class="number">7</span>&#125;,&#123;<span class="number">49</span>,<span class="number">8</span>&#125; &#125;;</span><br><span class="line">	SqList l;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		l.r[i + <span class="number">1</span>] = d[i];</span><br><span class="line">	l.length = N;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序前:\n&quot;</span>);</span><br><span class="line">	print(l);</span><br><span class="line">	TreeSort(&amp;l);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;排序后:\n&quot;</span>);</span><br><span class="line">	print(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*树的结构*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span>&#123;</span><br><span class="line">	<span class="type">bool</span> from; <span class="comment">//判断来源, 左true, 右false</span></span><br><span class="line">	<span class="type">int</span> m_nValue;</span><br><span class="line">	BinaryTreeNode* m_pLeft;</span><br><span class="line">	BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*构建叶子节点*/</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">buildList</span> <span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; L)</span></span>&#123;</span><br><span class="line">	BinaryTreeNode* btnList = <span class="keyword">new</span> BinaryTreeNode[L.<span class="built_in">size</span>()];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;L.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		btnList[i].from = <span class="literal">true</span>;</span><br><span class="line">		btnList[i].m_nValue = L[i];</span><br><span class="line">		btnList[i].m_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">		btnList[i].m_pRight = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> btnList;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*不足偶数时, 需补充节点*/</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">addMaxNode</span> <span class="params">(BinaryTreeNode* list, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*最大节点*/</span></span><br><span class="line">	BinaryTreeNode* maxNode = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>(); <span class="comment">//最大节点, 用于填充</span></span><br><span class="line">	maxNode-&gt;from = <span class="literal">true</span>;</span><br><span class="line">	maxNode-&gt;m_nValue = INT_MAX;</span><br><span class="line">	maxNode-&gt;m_pLeft = <span class="literal">NULL</span>;</span><br><span class="line">	maxNode-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*复制数组*/</span></span><br><span class="line">	BinaryTreeNode* childNodes = <span class="keyword">new</span> BinaryTreeNode[n+<span class="number">1</span>]; <span class="comment">//增加一个节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		childNodes[i].from = list[i].from;</span><br><span class="line">		childNodes[i].m_nValue = list[i].m_nValue;</span><br><span class="line">		childNodes[i].m_pLeft = list[i].m_pLeft;</span><br><span class="line">		childNodes[i].m_pRight = list[i].m_pRight;</span><br><span class="line">	&#125;</span><br><span class="line">	childNodes[n] = *maxNode;</span><br><span class="line">	<span class="keyword">delete</span>[] list;</span><br><span class="line">	list = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> childNodes;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*根据左右子树大小, 创建树*/</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">buildTree</span> <span class="params">(BinaryTreeNode* childNodes, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> childNodes;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (n%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">		childNodes = <span class="built_in">addMaxNode</span>(childNodes, n);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> num = n/<span class="number">2</span> + n%<span class="number">2</span>;</span><br><span class="line">	BinaryTreeNode* btnList = <span class="keyword">new</span> BinaryTreeNode[num];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; ++i) &#123;</span><br><span class="line">		btnList[i].m_pLeft = &amp;childNodes[<span class="number">2</span>*i];</span><br><span class="line">		btnList[i].m_pRight = &amp;childNodes[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">		<span class="type">bool</span> less = btnList[i].m_pLeft-&gt;m_nValue &lt;= btnList[i].m_pRight-&gt;m_nValue;</span><br><span class="line">		btnList[i].from = less;</span><br><span class="line">		btnList[i].m_nValue = less ?</span><br><span class="line">				btnList[i].m_pLeft-&gt;m_nValue : btnList[i].m_pRight-&gt;m_nValue;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">buildTree</span>(btnList, num);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*返回树根, 重新计算数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rebuildTree</span> <span class="params">(BinaryTreeNode* tree)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> result = tree[<span class="number">0</span>].m_nValue;</span><br><span class="line"> </span><br><span class="line">	std::stack&lt;BinaryTreeNode*&gt; nodes;</span><br><span class="line">	BinaryTreeNode* node = &amp;tree[<span class="number">0</span>];</span><br><span class="line">	nodes.<span class="built_in">push</span>(node);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (node-&gt;m_pLeft != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		node = node-&gt;from ? node-&gt;m_pLeft : node-&gt;m_pRight;</span><br><span class="line">		nodes.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	node-&gt;m_nValue = INT_MAX;</span><br><span class="line">	nodes.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (!nodes.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node = nodes.<span class="built_in">top</span>();</span><br><span class="line">		nodes.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">bool</span> less = node-&gt;m_pLeft-&gt;m_nValue &lt;= node-&gt;m_pRight-&gt;m_nValue;</span><br><span class="line">		node-&gt;from = less;</span><br><span class="line">		node-&gt;m_nValue = less ?</span><br><span class="line">				node-&gt;m_pLeft-&gt;m_nValue : node-&gt;m_pRight-&gt;m_nValue;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*从上到下打印树*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTree</span> <span class="params">(BinaryTreeNode* tree)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	BinaryTreeNode* node = &amp;tree[<span class="number">0</span>];</span><br><span class="line">	std::queue&lt;BinaryTreeNode*&gt; temp1;</span><br><span class="line">	std::queue&lt;BinaryTreeNode*&gt; temp2;</span><br><span class="line"> </span><br><span class="line">	temp1.<span class="built_in">push</span>(node);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (!temp1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node = temp1.<span class="built_in">front</span>();</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;m_pLeft != <span class="literal">NULL</span> &amp;&amp; node-&gt;m_pRight != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			temp2.<span class="built_in">push</span>(node-&gt;m_pLeft);</span><br><span class="line">			temp2.<span class="built_in">push</span>(node-&gt;m_pRight);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		temp1.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (node-&gt;m_nValue == INT_MAX) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;MAX&quot;</span>  &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			std::cout &lt;&lt; node-&gt;m_nValue  &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (temp1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			std::cout &lt;&lt; std::endl;</span><br><span class="line">			temp1 = temp2;</span><br><span class="line">			std::queue&lt;BinaryTreeNode*&gt; empty;</span><br><span class="line">			std::<span class="built_in">swap</span>(temp2, empty);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; L = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">	BinaryTreeNode* tree = <span class="built_in">buildTree</span>(<span class="built_in">buildList</span>(L), L.<span class="built_in">size</span>());</span><br><span class="line"> </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Begin : &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">printTree</span>(tree); std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;L.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		<span class="type">int</span> value = <span class="built_in">rebuildTree</span> (tree);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Round[&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;] : &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">printTree</span>(tree); std::cout &lt;&lt; std::endl;</span><br><span class="line">		result.<span class="built_in">push_back</span>(value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;result : &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (std::<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;L.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		std::cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>时间复杂度O(nlogn),</li>
<li>空间复杂度n</li>
<li>稳定性：不稳定</li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>基本思想：</p>
<ol>
<li>将待排序的序列构造成一个大堆，根据大堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；</li>
<li>将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大堆；</li>
<li>重复步骤2，如此反复，从第一次构建大堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大堆的尾部。最后，就得到一个有序的序列了。</li>
</ol>
<p>==排升序，建大堆==</p>
<p>==排降序，建小堆==<br>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> root)</span>&#123;<span class="comment">//向下调整</span></span><br><span class="line">    <span class="comment">//从根节点开始，选出左右孩子值较大的一个</span></span><br><span class="line">    <span class="comment">//如果选出的孩子的值大于父亲的值，那么就交换两者的值</span></span><br><span class="line">    <span class="comment">//将大的孩子看做新的父亲，继续向下调整，直到调整到叶子节点为止</span></span><br><span class="line">	assert(a);</span><br><span class="line">	<span class="type">int</span> parent = root;</span><br><span class="line">	<span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; n)&#123;</span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child])&#123;<span class="comment">//如果这里右孩子存在，且更大，那么默认较大的孩子就改为右孩子</span></span><br><span class="line"></span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[child] &gt; a[parent])&#123;</span><br><span class="line">			Swap(&amp;a[child], &amp;a[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	assert(a);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="comment">//从倒数第一个非叶子节点开始，从后往前，依次将其作为父亲，依次向下调整，一直调整到根的位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		AdjustDown(a, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//交换   堆排序（利用堆删的思想进行）</span></span><br><span class="line">    <span class="comment">//建好堆之后，将堆顶的数字与最后一个数字交换</span></span><br><span class="line">    <span class="comment">//将最后一个数字不看，剩下的n-1个数字再向下调整成堆再进行第1步</span></span><br><span class="line">    <span class="comment">//直到最后只剩一个数停止，这样就排成有序的了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		Swap(&amp;a[i], &amp;a[<span class="number">0</span>]);</span><br><span class="line">		AdjustDown(a, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>堆排序使用堆来选数，效率就高了很多。</li>
<li>时间复杂度：O(n*logn)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ol>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p><img src="https://img-blog.csdnimg.cn/1a63567f7ebb40479e25919faf3cf131.gif" alt></p>
<p>算法思想：</p>
<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide andConquer）的一个非常典型的应用。</p>
<p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<p>若将两个有序表合并成一个有序表，称为二路归并</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right,<span class="type">int</span>* tmp)&#123;</span><br><span class="line">    <span class="comment">//区间中没有元素时不再合并</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//划分数组，每次一分为二</span></span><br><span class="line">	<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	_MergeSort(a, left, mid,tmp);<span class="comment">//划分左区间</span></span><br><span class="line">	_MergeSort(a, mid + <span class="number">1</span>, right,tmp);<span class="comment">//划分右区间</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//合并有序序列</span></span><br><span class="line">	<span class="type">int</span> begin1 = left, end1 = mid;<span class="comment">//有序序列1</span></span><br><span class="line">	<span class="type">int</span> begin2 = mid + <span class="number">1</span>, end2 = right;<span class="comment">//有序序列2</span></span><br><span class="line">	<span class="type">int</span> i = left;</span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)&#123;<span class="comment">//注意结束条件为一个序列为空时就停止</span></span><br><span class="line">		<span class="keyword">if</span> (a[begin1] &lt; a[begin2])&#123;</span><br><span class="line">			tmp[i++] = a[begin1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[i++] = a[begin2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//两序列不可能同时为空，将剩余元素合并</span></span><br><span class="line">	<span class="keyword">while</span> (begin1 &lt;= end1)&#123;</span><br><span class="line">		tmp[i++] = a[begin1++];</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (begin2 &lt;= end2)&#123;</span><br><span class="line">		tmp[i++] = a[begin2++];</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将合并后的序列拷贝到原数组中</span></span><br><span class="line">    <span class="comment">//在这里拷贝的原因是 保证返回到上一层递归后两个子序列中的元素是有序的</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (j = left; j &lt;= right; j++)&#123;</span><br><span class="line">		a[j] = tmp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 归并排序递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">    <span class="comment">//因为需要将两个有序序列合并，需借助额外数组</span></span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	_MergeSort(a, <span class="number">0</span>, n - <span class="number">1</span>,tmp);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	tmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h2><p>算法思想：</p>
<p>与递归实现的思想是类似的</p>
<p>序列划分过程和递归是相反的，不是一次一分为二，而是先1个元素一组，再2个元素一组，4个元素一组….直到将所有的元素归并完。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序非递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">	<span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//初始化每组的元素个数为1</span></span><br><span class="line">	<span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (gap &lt; n)&#123;<span class="comment">//gap为n时就只有一个序列了，所以gap&lt;n</span></span><br><span class="line">        <span class="comment">//归并每两组归并一次</span></span><br><span class="line">		<span class="type">int</span> index = <span class="number">0</span>; <span class="comment">//记录tmp数组中的元素下标</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=<span class="number">2</span>*gap)<span class="comment">//两组中的元素个数为2*gap&#123;</span></span><br><span class="line">            <span class="comment">//控制两组边界</span></span><br><span class="line">			<span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//当原数组中元素个数不是2^n时，最后两组组会出现元素不匹配的情况</span></span><br><span class="line">            <span class="comment">//情况1：end1&gt;=n或begin2&gt;=n,即最后两组中只有一组有元素，则不需归并</span></span><br><span class="line">			<span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//情况2：end2&gt;=n，即最后两组中，第二组元素个数小于第一组，则需要调整第二组边界</span></span><br><span class="line">			<span class="keyword">if</span> (end2 &gt;= n)&#123;</span><br><span class="line">				end2 = n - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//归并</span></span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[begin1] &lt; a[begin2])&#123;</span><br><span class="line">					tmp[index++] = a[begin1++];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					tmp[index++] = a[begin2++];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1)&#123;</span><br><span class="line">				tmp[index++] = a[begin1++];</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">while</span> (begin2 &lt;= end2)&#123;</span><br><span class="line">				tmp[index++] = a[begin2++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//一趟排完后，将归并后的有序序列拷贝到原数组中</span></span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; index; j++)&#123;</span><br><span class="line">			a[j] = tmp[j];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//每次循环每组元素个数增大2倍</span></span><br><span class="line">		gap *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">free</span>(tmp);</span><br><span class="line">	tmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序总结：</p>
<ol>
<li>归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题</li>
<li>时间复杂度：O(n*logn)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ol>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基本思想：分配+收集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">int</span> digit, <span class="type">int</span> size, <span class="type">int</span> max)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> *result = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">	<span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[max];</span><br><span class="line">	<span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digit; ++i, radix *= <span class="number">10</span>)&#123;    <span class="comment">//循环元素的位数次</span></span><br><span class="line">		<span class="built_in">memset</span>(temp, <span class="number">0</span>, max * <span class="number">4</span>);    <span class="comment">//每次循环前初始化temp，否则temp的元素值会累加</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; ++j)&#123;</span><br><span class="line">			t = ary[j] / radix % <span class="number">10</span>;    <span class="comment">//得到各个数位上的数</span></span><br><span class="line">			++temp[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; max; ++j)</span><br><span class="line">			temp[j] += temp[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = size - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">			t = ary[j] / radix % <span class="number">10</span>;</span><br><span class="line">			result[temp[t] - <span class="number">1</span>] = ary[j];</span><br><span class="line">			--temp[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)        <span class="comment">//将结果复制进原数组</span></span><br><span class="line">			ary[i] = result[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[]result;</span><br><span class="line">	<span class="keyword">delete</span>[]temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testRadixSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">329</span>,<span class="number">457</span>,<span class="number">657</span>,<span class="number">839</span>,<span class="number">436</span>,<span class="number">720</span>,<span class="number">355</span>,<span class="number">839</span>,<span class="number">220</span>,<span class="number">653</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr is old :&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">RadixSort</span>(arr, <span class="number">3</span>,<span class="number">10</span>, <span class="number">10</span>);  <span class="comment">//排序后</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr is  new :&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(k*(n+m))【k：关键字字数；m：关键字取值范围为m个值】</p>
<p>空间复杂度：O(n+m)</p>
<p>稳定性：稳定</p>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/cbe7a90620f6d32d96b77d9fdc5e3e2d.gif" alt></p>
<p>算法思想：</p>
<p>计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用</p>
<ol>
<li>统计相同元素出现次数</li>
<li>根据统计的结果将序列回收到原来的序列中</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(a);</span><br><span class="line">    <span class="comment">// 创建计数数组，数组大小为原数组中最大值-最小值+1</span></span><br><span class="line">	<span class="type">int</span> max = a[<span class="number">0</span>], min = a[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; max)&#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; min)&#123;</span><br><span class="line">			min = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * range);</span><br><span class="line">    <span class="comment">// 初始化计数数组为0</span></span><br><span class="line">	<span class="built_in">memset</span>(count, <span class="number">0</span>, range * <span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 统计次数</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		count[a[i] - min]++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 根据次数，进行排序</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range; i++)&#123;</span><br><span class="line">		<span class="keyword">while</span> (count[i]--)&#123;</span><br><span class="line">			a[j++] = i+min;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">free</span>(count);</span><br><span class="line">    count = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>计数排序在数据范围集中时，效率很高，但是适用范围及场景有限。</li>
<li>时间复杂度：O(MAX(n,range))</li>
<li>空间复杂度：O(range)</li>
<li>稳定性：稳定</li>
</ol>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(<span class="type">int</span> ary[], <span class="type">int</span> size)</span></span>&#123;<span class="comment">//以排序百分制成绩为例</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; *bucket = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;[size + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> index, last;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">		index = ary[i] / <span class="number">10</span>;<span class="comment">//计算应该放入哪个桶</span></span><br><span class="line">		bucket[index].<span class="built_in">push_back</span>(ary[i]);</span><br><span class="line">		last = bucket[index].<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//计算插入前的最后一个元素的下标</span></span><br><span class="line">		<span class="keyword">while</span> (last &gt;= <span class="number">0</span> &amp;&amp; bucket[index][last] &gt; ary[i])&#123;<span class="comment">//排序</span></span><br><span class="line">			<span class="built_in">swap</span>(bucket[index][last], bucket[index][last + <span class="number">1</span>]);</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size + <span class="number">1</span>; ++i)    <span class="comment">//按桶顺序将各桶中的元素复制进原数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">			ary[k++] = bucket[i][j];</span><br><span class="line">	<span class="keyword">delete</span>[]bucket;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testBucketSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">0</span>,<span class="number">45</span>,<span class="number">57</span>,<span class="number">89</span>,<span class="number">100</span>,<span class="number">70</span>,<span class="number">35</span>,<span class="number">39</span>,<span class="number">20</span>,<span class="number">53</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr is old :&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">BucketSort</span>(arr, <span class="number">10</span>);  <span class="comment">//排序后</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr is  new :&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>当我们要排序的文件太大以至于内存无法一次性装下的时候，这时候我们可以使用外部排序，将数据在外部存储器和内存之间来回交换，以达到排序的目的</p>
<p>外部排序的提高的核心问题是：减少外部存储读写的次数。在一般情况下，对m个初始归并段进行K-路平衡归并，归并的趟数：s=以k为底，m的对数结果的向上取整值</p>
<h2 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h2><ol>
<li>每归并一次，参与归并的每个记录都要读一次和写一次。</li>
<li>总的读记录数（写记录数与之相同）：<ul>
<li>(F1+F2+F3+F4的记录数)×2=24=对起始12条记录读（写）了2遍=log2m</li>
<li>该数越大，效率越差</li>
<li>当m不满足2的i次方时，增加两个长度为0的虚段</li>
</ul>
</li>
<li>总的读记录数等同于哈夫曼树WPL（带权路径长度）：<ul>
<li>从根结点到各个叶结点的路径长度与相应结点权值的乘积的和</li>
<li>显然不同的归并方案所需要的读写记录数是不同的（使用二路归并或归并方案不同的二路归并、三路归并造成的读写次数也不同）</li>
</ul>
</li>
<li>影响k路平衡归并的因素<ul>
<li><strong>归并时需要读写磁盘的次数</strong><br>k路平衡归并时读写磁盘次数的计算：m=8，假设每个归并段4个记录：k=2<br>读记录次数 = WPL = 8×4×3 = 96（如果每个记录占用一个物理块，读写磁盘次数=96×2=192次）<br>采用k路平衡归并时，通常k越大，读写磁盘次数会减少。</li>
<li><strong>归并时需要关键字比较的次数</strong><br>k路平衡归并时关键字比较次数的计算<br>采用k路平衡归并时，则相应的归并树有[logkm]+1层，要对数据进行[logkm]趟扫描。<br><strong>总共需要的关键字比较次数为：</strong><br><img src="https://img-blog.csdnimg.cn/20200620205903476.png" alt="在这里插入图片描述"><br><strong>增大归并路数k，读写磁盘次数减少，而关键字比较次数会增大。若k增大到一定的程度，就会抵消掉由于减少读写磁盘次数而赢得的时间。</strong></li>
</ul>
</li>
</ol>
<h2 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h2><p><strong>置换－选择排序方法生成初始归并段，该方法可以减少生成的初始归并段个数（初始归并段个数越少，则越接近最后排序结果，可以减少归并次数）</strong></p>
<ol>
<li>从待排文件Fin中按内存工作区WA的容量w读入w个记录。设归并段编号i=1。</li>
<li>从WA中选出关键字最小的记录Rmin。</li>
<li>将Rmin记录输出到当前归并段Fi。</li>
<li>若Fin不空，则从Fin中读入下一个记录x放在Rmin所在的工作区位置代替Rmin。</li>
<li>在工作区中所有≥Rmin的记录中选择出最小记录作为新的Rmin，重复（3），直到选不出这样的Rmin。</li>
<li>设i=i+1，开始一个新的归并段。</li>
<li>若工作区已空，则初始归并段已全部产生；否则执行（2）</li>
</ol>
<p><strong>总结</strong>：</p>
<ol>
<li><p>共有n个记录，内存工作区WA的容量为w：</p>
</li>
<li><p>若在w个记录中选取最小关键字的采用简单比较方法，每次需要w-1次比较。</p>
<p>使用败者树可以提高比较效率。</p>
</li>
<li><p>总的时间复杂度为O(nw)。(读出和写入均为n)</p>
</li>
</ol>
<h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2><ol>
<li><p>性质和构造完全相同于哈弗曼树</p>
</li>
<li><p>与哈弗曼树的区别：</p>
<p>k叉树，其中k &gt; 2时：需要判断是否能满足构造完全k叉树，若不满足，则需要添加长度为0的“虚段”</p>
<p>①若（初始归并段数量 - 1） % （k - 1） = 0，则能构成完全k叉树</p>
<p>②若（初始归并段数量 - 1） % （k - 1）= u ≠ 0，则说明需要添加（k - 1）- u 个虚段才能构成完全二叉树</p>
</li>
</ol>
<h1 id="综合比较"><a href="#综合比较" class="headerlink" title="综合比较"></a>综合比较</h1><ol>
<li>时间性能：<ul>
<li>时间复杂度为O(nlogn)：==快速排序==，归并排序，堆排序</li>
<li>时间复杂度为O(n^2)：==直接插入排序==，冒泡排序，简单选择排序</li>
<li>时间复杂度为O(n)：基数排序</li>
</ul>
</li>
<li>空间性能（指排序过程中所需辅助空间大小）<ul>
<li>所有简单排序和堆排序的空间复杂度为O(1)</li>
<li>快速排序为O(logn)，为栈所需的辅助空间</li>
<li>归并排序所需辅助空间最多，为O(n)</li>
<li>链式基数排序需附设队列首位指针，为O(rd)</li>
</ul>
</li>
<li>稳定性<ul>
<li>稳定的排序方法是指，对于两个关键字相等的记录，它们在序列中的相对位置，在排序前和排序后没有改变</li>
<li>LSD方法排序，需要稳定的排序方法</li>
<li>快速排序和堆排序是最不稳定的排序方法</li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数学知识</title>
    <url>/post/374e1302.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/post/2ba40472.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>计算机系统自下而上可大致分为4部分：硬件、操作系统、应用程序和用户。而操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。在计算机系统的运行过程中，操作系统提供了正确使用这些资源的方法。</p>
<p><strong>操作系统(Operating System, OS)：</strong>是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织、调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境的软件集合；它是计算机系统中最基本的系统软件。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol>
<li><p>并发</p>
<p>并发是指两个或多个时间在同一时间间隔内发生。操作系统的并发性则是指计算机系统中同时存在多个运行的程序，因此具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的就是为了使程序能并发执行。</p>
</li>
<li><p>共享</p>
<p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式。</p>
<ul>
<li><p>互斥共享方式：系统中的某些资源，如打印机、磁带机等，虽然可供多个进程使用，但为使得所打印或记录的结果不一致造成混淆，应规定在一段时间内只允许一个进程访问该资源。为此，当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统将之分配给进程A使用，此后若有其他进程也要访问资源时（只要A未用完）就必须等待。仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为<strong>临界资源。</strong>计算机系统中的大多数物理设备以及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p>
</li>
<li><p>同时访问方式：系统中还有一类资源，这类资源允许在一段时间内由多个进程“同时”访问。这里说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源就是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即允许若干个用户同时访问该文件</p>
<p><strong>互斥共享要求一种资源在一段时间内只满足一个请求</strong>，<strong>同时访问共享通常要求一个请求分几个时间片段间隔地完成</strong>，其效果与连续完成效果相同。</p>
</li>
</ul>
<p><strong>并发和共享是操作系统两个最基本的特征</strong>，两者互为存在的条件：①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；②若系统不能对资源共享实施有效的管理，则必将影响到程序并发执行，甚至根本无法并发执行。</p>
</li>
<li><p>虚拟</p>
<p>虚拟是指把一个物理上的实体变为若干逻辑上的对应物。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p>
<p>虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为他服务。利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</p>
<p>操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时复用；空分复用技术，如虚拟存储器。</p>
</li>
<li><p>异步</p>
<p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p>
</li>
</ol>
<h2 id="目标-作用-功能"><a href="#目标-作用-功能" class="headerlink" title="目标,作用,功能"></a>目标,作用,功能</h2><p>目标：方便性，有效性，可扩充性，开放性</p>
<p>作用：</p>
<ol>
<li>作为用户与计算机硬件系统间的接口</li>
<li>作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象</li>
</ol>
<p>功能：</p>
<p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<ol>
<li>处理机管理：在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。 进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li>
<li>存储器管理：存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</li>
<li>文件管理：计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</li>
<li>设备管理：设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</li>
<li>接口管理：方便用户对OS的使用<ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200220181209621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt></p>
<h1 id="发展和分类"><a href="#发展和分类" class="headerlink" title="发展和分类"></a>发展和分类</h1><p><img src="https://img-blog.csdnimg.cn/20200222160313682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20200222161909768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt></p>
<h1 id="运行机制和体系结构"><a href="#运行机制和体系结构" class="headerlink" title="运行机制和体系结构"></a>运行机制和体系结构</h1><h2 id="操作系统的运行机制和体系结构（大内核、小内核）"><a href="#操作系统的运行机制和体系结构（大内核、小内核）" class="headerlink" title="操作系统的运行机制和体系结构（大内核、小内核）"></a>操作系统的运行机制和体系结构（大内核、小内核）</h2><h2 id="中断和异常（内中断和外中断、中断处理过程）"><a href="#中断和异常（内中断和外中断、中断处理过程）" class="headerlink" title="中断和异常（内中断和外中断、中断处理过程）"></a>中断和异常（内中断和外中断、中断处理过程）</h2><h2 id="系统调用（执行过程、访管指令、库函数与系统调用）"><a href="#系统调用（执行过程、访管指令、库函数与系统调用）" class="headerlink" title="系统调用（执行过程、访管指令、库函数与系统调用）"></a>系统调用（执行过程、访管指令、库函数与系统调用）</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/post/4b6d6bc1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>查找</title>
    <url>/post/33cb1151.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="查找总结.png" alt="查找总结"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/post/79666db.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="一般哈希——存储结构"><a href="#一般哈希——存储结构" class="headerlink" title="一般哈希——存储结构"></a>一般哈希——存储结构</h2><p>拉链法<br>开放寻址法</p>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/842/">模拟散列表</a></strong><br>维护一个集合，支持如下几种操作：<br>1、<code>I x</code>，插入一个数 x ；<br>2、<code>Q x</code>，询问数 x 是否在集合中出现过；<br>现在要进行 N 次操作，对于每个询问操作输出对应的结果。</p>
<p>输入格式<br>第一行包含整数 N ，表示操作数量。<br>接下来 N 行，每行包含一个操作指令，操作指令为 I x，Q x 中的一种。</p>
<p>输出格式<br>对于每个询问指令 Q x，输出一个询问结果，如果 x 在集合中出现过，则输出 Yes，否则输出 No。 每个结果占一行。</p>
<p>数据范围<br>1≤N≤105<br>−109≤x≤109<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">Q 2</span><br><span class="line">Q 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><strong>拉链法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N+N)%N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>开放寻址法</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目：<a href="https://www.acwing.com/problem/content/description/843/">字符串哈希</a></strong><br>给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2 ，请你判断 [l1,r1]和 [l2,r2]这两个区间所包含的字符串子串是否完全相同。<br>字符串中只包含大小写英文字母和数字。</p>
<p>输入格式<br>第一行包含整数 n 和 m ，表示字符串长度和询问次数。<br>第二行包含一个长度为 n 的字符串，字符串中只包含大小写英文字母和数字。<br>接下来 m 行，每行包含四个整数 l1,r1,l2,r2 ，表示一次询问所涉及的两个区间。<br>注意，字符串的位置从 1 开始编号。</p>
<p>输出格式<br>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 Yes，否则输出 No。 每个结果占一行。</p>
<p>数据范围<br>1≤n,m≤105<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><br>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str+<span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">        h[i] = h[i<span class="number">-1</span>]*P+str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2))&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构概述</title>
    <url>/post/35ca0ba5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://img-blog.csdn.net/20180925135349677?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0eXFpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="思维导图"></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构包括以下几个方面：</p>
<ul>
<li>数据的逻辑结构：是指数据元素之间的逻辑关系<ul>
<li>线性结构：线性表，栈（特殊线性表），队列（特殊线性表），字符串、数组、广义表</li>
<li>非线性结构：树形结构，图形结构</li>
</ul>
</li>
<li>数据的存储结构（物理结构）：数据元素及其逻辑关系在计算机存储器中的存储方式，一般只在高级语言的层次上来讨论存储结构。不同的逻辑结构有不同的存储结构<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
<li>索引存储结构</li>
<li>哈希（散列）存储结构</li>
</ul>
</li>
<li>数据的运算：检索，排序，插入，删除，修改等</li>
</ul>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><p>数据：是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p>
<p>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。</p>
<p>数据对象：是性质相同的数据元素的集合，是数据的一个子集。</p>
<p>数据结构：又称逻辑结构，是相互之间存在一种或多种特定关系的数据元素的集合。通常有以下四类基本结构：集合、线性结构、树形结构、图状结构或网状结构。</p>
<p>存储结构（物理结构）：是数据结构在计算机中的表示（又称映像）。</p>
<p>数据类型：是一个值的集合和定义在这个值集上的一组操作的总称。</p>
<p>抽象数据类型：是指一个数学模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。</p>
<h3 id="抽象数据类型的表示与实现"><a href="#抽象数据类型的表示与实现" class="headerlink" title="抽象数据类型的表示与实现"></a>抽象数据类型的表示与实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">操作<span class="number">1</span></span><br><span class="line">前置条件：执行此操作前数据所必须的状态</span><br><span class="line">输 入：执行此操作所需要的输入</span><br><span class="line">功 能：该操作将完成的功能</span><br><span class="line">输 出：执行该操作后产生的输出</span><br><span class="line">后置条件：执行该操作后数据的状态</span><br><span class="line">操作<span class="number">2</span></span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">操作n</span><br><span class="line">……</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h3 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h3><p>算法：是对特定问题求解步骤的一种描述，是指令的有限序列</p>
<p>算法的五大特性：输入，输出，有穷性，确定性，可行性</p>
<p>算法设计的要求：正确性，可读性，健壮性，效率和低存储需求</p>
<p>算法分析：事后统计法、事前分析估算法</p>
<h4 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>复杂度分析法则：</p>
<ol>
<li>单段代码看高频：比如循环</li>
<li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度</li>
<li>嵌套代码求乘积：比如递归、多重循环等</li>
<li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加</li>
</ol>
<p>时间频度：一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<p>时间复杂度：在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度</p>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>只关注循环执行次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200415110541459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20200415110548576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>常见时间复杂度</strong></p>
<p><img src="https://img-blog.csdn.net/20180927120135678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0eXFpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p>
<ul>
<li><p>常数阶O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="type">int</span> m = i + j;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长</p>
</li>
<li><p>线性阶O(n)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的</p>
</li>
<li><p>对数阶O(logN)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线性对数阶O(nlogN)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>平方阶O(n2)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=n; x++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>立方阶O(n³)、K次方阶O(n^k)</p>
</li>
</ul>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p>
<p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)</p>
<p>O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="type">int</span> m = i + j;</span><br></pre></td></tr></table></figure>
<p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p>
<p>O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] m = <span class="keyword">new</span> <span class="title class_">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈、队列</title>
    <url>/post/a1359bee.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/post/40f24371.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="线性表总结.png" alt="线性表总结"></p>
<h1 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h1><p>线性表是具有<strong>相同数据类型</strong>的n（n≥0）个数据元素的<strong>有限序列</strong>，其中n为表长，当n = 0时线性表是一个空表。除第一个元素（表头元素）外，每个元素都有且仅有一个直接前驱；除最后一个元素（表尾元素）外，每个元素有且仅有一个直接后继</p>
<p>线性表的特点：</p>
<ol>
<li>表中元素的个数<strong>有限</strong></li>
<li>表中元素具有逻辑上的<strong>顺序性</strong>，表中有其先后次序</li>
<li>表中元素都是数据元素，每个元素都是单个元素</li>
<li>表中元素的数据类型相同，每个元素占有相同大小的存储空间</li>
</ol>
<p>抽象数据类型线性表的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">    数据对象:D=&#123;a:| a_ FElemSet, i=<span class="number">1</span>,<span class="number">2</span>,,n,n&gt;≥<span class="number">0</span>)</span><br><span class="line">    数据关系:Rl=&#123;&lt;aji-iva:&gt;lag-i,a;ED,i=<span class="number">2</span>,…,m)</span><br><span class="line">    基本操作:</span><br><span class="line">    </span><br><span class="line">&#125;ADT List;</span><br></pre></td></tr></table></figure>
<p>基本操作：</p>
<ul>
<li><p><strong>InitList(&amp;L)</strong>：<strong>初始化表</strong></p>
<p>操作结果：构造一个空的线性表</p>
</li>
<li><p><strong>DestroyList(&amp;L)</strong>：<strong>销毁操作</strong></p>
<p>初始条件：线性表L已存在</p>
<p>操作结果：销毁线性表，并释放线性表 L所占用的内存空间</p>
</li>
<li><p><strong>ClearList(&amp;L)</strong>:<strong>清除操作</strong></p>
<p>初始条件：线性表L已存在</p>
<p>操作结果：将线性表L重置为空表</p>
</li>
<li><p><strong>ListEmpty(L)</strong>：<strong>判空操作</strong></p>
<p>初始条件：线性表L已存在</p>
<p>操作结果：若 L 为空表，则返回 true，否则返回 false</p>
</li>
<li><p><strong>ListLength(L)</strong>：<strong>求表长</strong></p>
<p>初始条件：线性表L已存在</p>
<p>操作结果：返回线性表L的长度，即L中数据元素的个数</p>
</li>
<li><p><strong>GetElem(L , i，&amp;e)</strong>：<strong>按位查找操作</strong></p>
<p>初始条件：线性表L已存在，1&lt;=i&lt;=ListLength(L)</p>
<p>操作结果：获取表 L 中第i 个位置的元素的值，并用e返回</p>
</li>
<li><p><strong>LocateElem(L , e，compare())</strong>：<strong>按值查找操作</strong></p>
<p>初始条件：线性表L已存在，compare()是数据元素判定函数</p>
<p>操作结果：在表L中查找具有给定关键字值的元素，返回 L中第 1 个与e满足关系 compare()的数据元素的位序。若这样的数据元素<br>不存在,则返回值为0</p>
</li>
<li><p><strong>PriorElem(L, cur. e,&amp;pre_e)</strong>：<strong>求前驱</strong></p>
<p>初始条件：线性表L已存在</p>
<p>操作结果：若 cu—e 是L的数据元素,且不是第一个,则用 pre.e 返回它的前驱,否则操作失败,pre.e无定义</p>
</li>
<li><p><strong>NextElem( L, cur.e,&amp;.next_e)</strong>：<strong>求后继</strong></p>
<p>初始条件：线性表L已存在</p>
<p>操作结果：若 cur-e 是工的数据元素,且不是最后一个,则用 next_.e返回它的后继，否则操作失败,next.e 无定义</p>
</li>
<li><p><strong>ListInsert(&amp;L , i , e)</strong>：<strong>插入操作</strong></p>
<p>初始条件：线性表工已存在,1&lt;=i&lt;=ListLength(L)+ 1<br>操作结果：在表L中的第 i 个位置上插入指定元素e，L的长度加</p>
</li>
<li><p><strong>ListDelete(&amp;L , i , &amp;e)</strong>：<strong>删除操作</strong>。删除表L中第 i 个位置的元素，并用e返回删除元素的值</p>
<p>初始条件:线性表工已存在且非空,1≤i≤Listlength(L)</p>
<p>操作结果:删除工的第i个数据元素,并用e返回其值,工的长度减 1</p>
</li>
<li><p><strong>ListTraverse(L, visit())</strong>：<strong>遍历</strong></p>
<p>初始条件:线性表L已存在</p>
<p>操作结果:依次对工的每个数据元素调用函数 visit()。一旦 visit()失败,则操作失败</p>
</li>
<li><p><strong>PrintList(L)</strong>：<strong>输出操作</strong>。按前后顺序输出线性表 L 的所有元素值</p>
</li>
</ul>
<h1 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h1><p>在计算机内，线性表有两种基本的存储结构，顺序存储结构和链式存储结构</p>
<p>线性表的顺序表又称为顺序存储结构或顺序映像</p>
<p>线性表：简称表，是n（n&gt;=0）个数据元素的有限序列。L=（a1,a2,a3,……,an）长度：线性表中数据元素的个数称为线性表的长度。 长度等于零的线性表称为空表。</p>
<p>线性表的逻辑特征：第一个元素无前驱，其余元素有且仅有一个前驱；最后一个元素无后继，其余元素有且仅有一个后继。</p>
<p>数据最常用的五个运算：插入、删除、修改、查找、排序</p>
<p>线性表的顺序存储结构寻址公式：loc(ai)=loc(a1)+(i-1)*C</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100 <span class="comment">// 线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10  <span class="comment">// 线性表存储空间的分配增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span>&#123;</span></span><br><span class="line">	Elemtype*elem;<span class="comment">//存储空间基址</span></span><br><span class="line">	<span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">    <span class="type">int</span> listsize;<span class="comment">//当前分配存储容量</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的算法"><a href="#顺序表的算法" class="headerlink" title="顺序表的算法"></a>顺序表的算法</h2><p>初始化表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitList_sq</span><span class="params">(SqList &amp;L)</span>&#123;<span class="comment">//构造一个空的线性表</span></span><br><span class="line">	L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	L.length = <span class="number">0</span>;<span class="comment">//空表长度为0</span></span><br><span class="line">	L.listsize = LIST_INIT_SIZE;<span class="comment">//初始存储容量</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化空表  T(n)=O(1)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">seqlist * <span class="title function_">Initlist</span><span class="params">()</span>&#123;</span><br><span class="line">   seqlist *L;</span><br><span class="line">   L-&gt;length = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> (L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化非空表  T(n)=O(1)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">seqlist *L；</span><br><span class="line"><span class="type">int</span> createlist（seqlist *L, datatype r[], <span class="type">int</span> n）&#123; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; MaxSize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;空间不足&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        L-&gt;data[i] = r[i];</span><br><span class="line">    L-&gt;length = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断表是否为空  T(n)=O(1)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> empty（seqlist *L）&#123;</span><br><span class="line">   <span class="keyword">if</span>（L-&gt;length == <span class="number">0</span>） </span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求顺序表长度  T(n)=O(1)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(seqlist *L)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L.length=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>销毁表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(L.elem)</span><br></pre></td></tr></table></figure>
<p>顺序表的遍历  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(seqlist *L)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, L-&gt;data[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找i位置的数据元素   T(n)=O(1)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">datatype Get（seqlist *L, <span class="type">int</span> i, datatype *ptr）&#123;</span><br><span class="line">   <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;length)&#123; </span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;参数异常&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123; </span><br><span class="line">       *prt=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找值为x的数据元素  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">Locate</span><span class="params">(Seqlist *L, datatype x)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L-&gt;length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(x == L-&gt;data[i]) <span class="keyword">return</span> (i+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取表中第i个元素</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetElem_sq</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(i &gt; L.length || i &lt; <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">	p = L.elem+(i<span class="number">-1</span>);<span class="comment">//p为第i个元素的位置</span></span><br><span class="line">	e = *p;<span class="comment">//取出的第i个元素的值赋给e</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入算法  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> insertlist（seqlist *L, <span class="type">int</span> i, datatype x）&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length &gt;= Maxsize) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;上溢异常！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置异常！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = L-&gt;length; j &gt;= i; j--)&#123;</span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">        L-&gt;data[i<span class="number">-1</span>] = x;</span><br><span class="line">        L-&gt;length++;;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Listinsert_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line"><span class="comment">//在顺序线性表L中第i个元素之间插入新元素e  </span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (L.length &gt;= L.listsize)&#123;</span><br><span class="line">		newbase = (ElemType*)<span class="built_in">realloc</span>(L.Elem, (L.listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">		<span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">//存储分配失败</span></span><br><span class="line">		L.elem = newbase;</span><br><span class="line">		L.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	q = &amp;(L.elem[i<span class="number">-1</span>]);    <span class="comment">//q为插入位置</span></span><br><span class="line">	<span class="keyword">for</span> (p = &amp;(L.elem[L.length<span class="number">-1</span>]); p &gt;= q; --p) </span><br><span class="line">        *(p+<span class="number">1</span>) = *p;</span><br><span class="line">	*q = e;</span><br><span class="line">	++L.length;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在第i个元素之前插入的概率pi，<br>则在长度为n的线性表中插入一个元素所需移动元素次数的期望值为:<br><img src="https://img-blog.csdnimg.cn/dc3f1dce4e1d4c1a810b4c22b4dc7a1f.png" alt="在这里插入图片描述"></p>
<p>若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为:<br><img src="https://img-blog.csdnimg.cn/09154cd367004d52b6e8067f297c431a.png" alt="在这里插入图片描述"></p>
<p>删除算法  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deletelist</span><span class="params">(seqlist *L, <span class="type">int</span> i, datatype *ptr)</span>&#123;   </span><br><span class="line">     <span class="keyword">if</span>(L-&gt;length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;下溢异常！&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;位置异常！&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      *ptr = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">for</span>(j = i; j &lt;= L-&gt;length<span class="number">-1</span>; j++)&#123;</span><br><span class="line">          L-&gt;data[j<span class="number">-1</span>] = L-&gt;data[j];</span><br><span class="line">          L-&gt;length--;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="comment">//在顺序线性表L中删除第i个元素，并用e返回其值i的合法值为1&lt;=j&lt;=ListLength_Sq(L)</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">	p = &amp;(L.elem[i<span class="number">-1</span>);    <span class="comment">//p指向被删除的元素</span></span><br><span class="line">	e = *p; <span class="comment">//被删除元素的值赋给e</span></span><br><span class="line">	q = L.elem+L.length<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (++p; p &lt;= q; ++p) *(p<span class="number">-1</span>) = *p;</span><br><span class="line">	--L.length;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设删除第i个元素的概率为qi,<br>则在长度为n的线性表中删除一个元素所需移动元素次数的期望值为:<br><img src="https://img-blog.csdnimg.cn/84b84fda271343b0b3e349803eb6c756.png" alt="在这里插入图片描述"><br>若假定在线性表中任何一个位置上进行删除的概率都是相等的，则移动元素的期望值为:<br><img src="https://img-blog.csdnimg.cn/e260caa2bebf4cb4b9865e6b0dbc0ac1.png" alt="在这里插入图片描述"></p>
<p>逆置算法  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> reverse（<span class="type">int</span> r[],<span class="type">int</span> n）&#123;  </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        t = r[i];</span><br><span class="line">        r[i] = r[n<span class="number">-1</span>-i]; </span><br><span class="line">        r[n<span class="number">-1</span>-i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>循环左移K的位置的算法  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> reverse（<span class="type">int</span> r[],<span class="type">int</span> s,<span class="type">int</span> e）&#123;  </span><br><span class="line">    <span class="type">int</span> i;    </span><br><span class="line">    <span class="keyword">for</span>(i = s, j = e; i &lt; j; i++,j--)&#123;</span><br><span class="line">        t = r[i];</span><br><span class="line">        r[i] = r[j];</span><br><span class="line">        r[j]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n,<span class="type">int</span> k)</span>&#123;   </span><br><span class="line">    reverse(r[],<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">    reverse(r[],k,n<span class="number">-1</span>);</span><br><span class="line">    reverse(r[],<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>奇偶划分  T(n)=O(n)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;   </span><br><span class="line">       <span class="keyword">while</span> (r[i]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">       <span class="keyword">while</span> (r[j]%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">           t = r[i];</span><br><span class="line">           r[i] = r[j];</span><br><span class="line">           r[j] = t;</span><br><span class="line">           i++;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类c有关操作"><a href="#类c有关操作" class="headerlink" title="类c有关操作"></a>类c有关操作</h2><p>数组静态分配，数组动态分配</p>
<p>C语言动态内存分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> strut &#123;           </span><br><span class="line">    ElemType *date;         <span class="comment">//指针变量，表示数组</span></span><br><span class="line">    <span class="comment">//该方法需要内存动态分配函数</span></span><br><span class="line">    <span class="comment">//Sqlist L；L即为顺序表，由L.data存放数据元素，L.Length存放当前顺序表元素个数</span></span><br><span class="line">    <span class="comment">//L.date=(ElemType*)malloc(sizeof(ElemType) * MaxSize)</span></span><br><span class="line">    <span class="comment">//(ElemType*)表示强制转换为需要的类型</span></span><br><span class="line">    <span class="comment">//malloc(m)：开辟m字节长度的地址空间，并返回这段空间的首地址(参数要求为整数)</span></span><br><span class="line">    <span class="comment">//sizeof(x)：计算变量x的长度</span></span><br><span class="line">    <span class="comment">//free(p)：释放指针p所指变量的存储空间，即彻底删除一个变量</span></span><br><span class="line">    <span class="comment">//使用内存动态分配函数需要加载头文件：&lt;stdlib.h&gt;</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//整型变量</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表类型</span></span><br></pre></td></tr></table></figure>
<p>c++的动态存储分配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new 类型名T（初值列表）</span><br><span class="line">  <span class="comment">//int *p = new int; 或 int *p = new int(10);</span></span><br><span class="line">  <span class="comment">//功能：</span></span><br><span class="line">  <span class="comment">//  申请用于存放T类型对象的内存空间，并依初值列表赋以初值</span></span><br><span class="line">  <span class="comment">//结果值：</span></span><br><span class="line">  <span class="comment">//  成功：T类型的指针，指向新分配的内存</span></span><br><span class="line">  <span class="comment">//  失败：0（NULL）</span></span><br></pre></td></tr></table></figure>
<p>要释放指针p所指向的内存，需用 delete 指针p。p必须是new操作的返回值。</p>
<p>c++参数传递：</p>
<ul>
<li><p>传值方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">float</span> m,<span class="type">float</span> n)</span></span>&#123;<span class="comment">//m,n为形参</span></span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    temp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;                <span class="comment">//交换m、n的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b;               <span class="comment">//定义a,b两个实参</span></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);               <span class="comment">//将a传递给m，将b传递给n</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;  <span class="comment">//ab的值无变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传地址</p>
<ul>
<li><p>参数为指针变量</p>
<p>情况一：形参变化<strong>影响实参</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">float</span> *m,<span class="type">float</span> *n)</span></span>&#123;<span class="comment">//传递给两个指针变量</span></span><br><span class="line">    <span class="type">float</span> t;                <span class="comment">//定义实型变量</span></span><br><span class="line">    t = *m;                 <span class="comment">//交换指针变量所指的内容</span></span><br><span class="line">    *m = *n;</span><br><span class="line">    *n = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b,*p1,*p2;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    p1 = &amp;a;             <span class="comment">//p1指向a</span></span><br><span class="line">    p2 = &amp;b;             <span class="comment">//p1指向b</span></span><br><span class="line">    <span class="built_in">swap</span>(p1,p2);         <span class="comment">//调用函数将两个指针作为实参传递</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情况二：形参变化<strong>不影响实参</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">float</span> *m,<span class="type">float</span> *n)</span></span>&#123;<span class="comment">//传递给两个指针变量</span></span><br><span class="line">    <span class="type">float</span> *t;               <span class="comment">//定义指针变量</span></span><br><span class="line">    t = m;                 <span class="comment">//交换指针变量本身</span></span><br><span class="line">    m = n;</span><br><span class="line">    n = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b,*p1,*p2;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    p1 = &amp;a;             <span class="comment">//p1指向a</span></span><br><span class="line">    p2 = &amp;b;             <span class="comment">//p1指向b</span></span><br><span class="line">    <span class="built_in">swap</span>(p1,p2);         <span class="comment">//调用函数将两个指针作为实参传递</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数为引用类型</p>
<p>引用类型作形参的三点说明</p>
<ol>
<li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li>
<li>引用类型作形参，在内存中并没有产生实际副本，它直接对实参操作；而一般变量作参数，形参与实参就占用不同的储存单元，所以形参变量的值是实参变量的副本。因此，当参数传递的数据量较大的时候，用引用比用一般变量传递参数的时间和空间效率都要好。</li>
<li>指针参数虽然也能够达到与使用引用的效果，但在被调函数中需要重复使用“指针变量名”的形式进行运算，这样容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">float</span> &amp;m,<span class="type">float</span> &amp;n)</span>&#123;<span class="comment">//定义两个引用，m引用a,n引用b</span></span><br><span class="line">    <span class="type">float</span> temp;             </span><br><span class="line">    temp = m;<span class="comment">//对m、n的操作即为对a、b的操作</span></span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    swap(p1,p2);         </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数为数组名</p>
<p>传递的是数组的首地址</p>
<p>对形参数组所作的任何改变都将反映到实参数组中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span>    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">char</span> b[])</span></span>&#123;   <span class="comment">//传递存放地址的数组，b[]可用*b替代</span></span><br><span class="line">    b[] = <span class="string">&quot;world&quot;</span>;   <span class="comment">//给b数组重新赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;<span class="comment">//定义一个字符型的a数组，存放了五个字符组成的字符串</span></span><br><span class="line">    <span class="built_in">sub</span>(a);              <span class="comment">//利用函数，传递了首地址</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;       <span class="comment">//a数组已改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h1><p>链式存储结构：结点在存储器中的位置是任意的，即<strong>逻辑上相邻的数据元素在物理上不一定相邻</strong>。 线性表的链式表示又称为非顺序映像或链式映像</p>
<p>链式存储的结构包含两个域：一个用于存储数据元素的信息，另一个用于存储直接后继的存储位置；<strong>存储数据元素信息的域称为数据域</strong>，<strong>存储直接后继存储位置的域称为指针域</strong></p>
<p>结点只有一个指针域的链表，称为单链表或线性链表</p>
<p>结点有两个指针域的链表，称为双链表</p>
<p>收尾相连的链表称为循环链表</p>
<p>头指针：是指向链表中第一个结点的指针</p>
<p>首元结点：是指链表中存储第一个数据元素a1的结点</p>
<p>头结点：是在链表的首元结点之前附设的一个结点</p>
<p>特点：</p>
<ul>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等。</li>
<li>这种存取元素的方法被称为<strong>顺序存取法</strong></li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：①数据元素的个数可以自由扩充；②插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li>
<li>缺点：①存储密度小；②存取效率不高，必须采用<strong>顺序存取</strong>，即存取数据元素时，只能按链表的顺序进行访问</li>
</ul>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表是由表头唯一确定，因此可以用头指针的名字来命名</p>
<p>定义和表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********** 单链表的定义 **********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    elemType data;<span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">// 指针域，其类型为指向节点的指针类型LNode*</span></span><br><span class="line">&#125; LNode, *LinkedList;<span class="comment">//*LinkList为指向结构体LNode的指针类型</span></span><br></pre></td></tr></table></figure>
<p>基本操作：</p>
<p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitList_L</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line"><span class="comment">//构造一个空的单链表L</span></span><br><span class="line">	L=new LNode;  <span class="comment">//生成新节点作为头结点，用头指针L指向头结点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头指针的指针域置空</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取值</p>
<p>①用指针p指向首元节点，用j做计数器初值赋1<br>②从首元节点开始依次顺着链域next向下访问，只要指向当前节点的指针p不为空（NULL），并且没有到达序号为i的节点，则循环执行以下操作：</p>
<ul>
<li>p指向下一个节点；</li>
<li>计数器j相应加1</li>
</ul>
<p>③退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法（i大于表长n或小于等于0）；取值失败返回ERROR；否则取值成功，此时j=i时，p所指的节点就是要找的第i个节点，用参数e保存当前节点的数据域，返回OK。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取线性表L中的某个数据元素的内容</span></span><br><span class="line">Status <span class="title function_">GetElem_L</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="comment">//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据的值</span></span><br><span class="line">	p=L-&gt;next;j=<span class="number">1</span>;  <span class="comment">//初始化，p指向首元节点，计数器j初值赋为1</span></span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;  <span class="comment">//向后扫描，直到p指向第i个元素或p为空</span></span><br><span class="line">	p=p-&gt;next;  <span class="comment">//p指向下一个节点</span></span><br><span class="line">	++j;   <span class="comment">//计算器相应加1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p || j&gt;i) <span class="keyword">return</span> ERROR;  <span class="comment">//第i个元素不存在</span></span><br><span class="line">	e=p-&gt;data;  <span class="comment">//取第i个元素</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度：T(n) = O(n)，平均查找长度：ASL = (n-1)/2</p>
<p>查找</p>
<p>①用指针p指向首元节点<br>②从首元节点开始依次顺着链域next向下查找，只要指向当前节点的指针p不为空，并且所指节点的数据域不等于给定值e，则循环执行以下操作：p指向下一个节点<br>③返回p。若查找成功，p此时指向节点的地址值，若查找失败，则p的值为NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线性表L中查找值为e的数据元素</span></span><br><span class="line">LNode *<span class="title function_">LocateElem_L</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">	p=L-&gt;next;  <span class="comment">//初始化，p指向首元节点</span></span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)  <span class="comment">//顺序链域向后查找，直到p为空或者所指节点的数据域等于e</span></span><br><span class="line">		p=p-&gt;next;  <span class="comment">//p指向下一个节点</span></span><br><span class="line">	<span class="keyword">return</span> p;  <span class="comment">//查找成功返回值为e的节点地址p，查找失败p为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：T(n) = O(n)</p>
<p>插入</p>
<p><img src="https://img-blog.csdnimg.cn/41f3f1d15c8243ac852e3de684543187.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在L中的第i个元素之前插入数据元素e</span></span><br><span class="line">Status <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;</span><br><span class="line">	p=L;j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; (j&lt;i<span class="number">-1</span>))&#123;</span><br><span class="line">		p=p-&gt;next;++j; &#125; <span class="comment">//查找第i-1个节点，p指向该节点</span></span><br><span class="line">	<span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR;  <span class="comment">//i&gt;n+1或者i&lt;1</span></span><br><span class="line">	s=new LNode;  <span class="comment">//生成新节点*s</span></span><br><span class="line">	s-&gt;data=e;  <span class="comment">//将节点*s的数据域置为e</span></span><br><span class="line">	s-&gt;next=p-&gt;next;  <span class="comment">//将节点*s的指针域指向节点a</span></span><br><span class="line">	p-&gt;next=s;   <span class="comment">//将节点*p的指针域指向节点*s</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：T(n) = O(n)</p>
<p>删除</p>
<p><img src="https://img-blog.csdnimg.cn/9ce5514cc74e42dd89509125367358bc.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将线性表L中第i个数据元素删除</span></span><br><span class="line">Status <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="comment">//在带头结点的单链表L中，删除第i个元素</span></span><br><span class="line">	p=L;j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((p-&gt;next) &amp;&amp; (j&lt;i<span class="number">-1</span>))&#123;  <span class="comment">//查找第i-1个节点，p指向该节点</span></span><br><span class="line">		p=p-&gt;next;++j; &#125; </span><br><span class="line">	<span class="keyword">if</span>(!(p-&gt;next) || (j&gt;i<span class="number">-1</span>)) <span class="keyword">return</span> ERROR;  <span class="comment">//i&gt;n或者i&lt;1,删除位置不合理</span></span><br><span class="line">	q=p-&gt;next;   <span class="comment">//临时保存被删节点的地址以备释放</span></span><br><span class="line">	p-&gt;next=q-&gt;next; <span class="comment">//改变删除节点前驱节点的指针域</span></span><br><span class="line">	delete q;  <span class="comment">//释放删除节点的空间</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：T(n) = O(n)<br><img src="https://img-blog.csdnimg.cn/70d44c56c6ec4240a48b9b2729eba368.png" alt="在这里插入图片描述"></p>
<p>创建</p>
<p>前插法</p>
<p><img src="https://img-blog.csdnimg.cn/b0ac9e4a478048bd9d1613c4b585c7d0.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_H</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">//逆位序输入n个元素的值，建立带表头节点的单链表L</span></span><br><span class="line">	L=new LNode;  </span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//先建立一个带头节点的空链表</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		p=new LNode;  <span class="comment">//生成新节点*p</span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;p-&gt;next;  <span class="comment">//输入元素值赋给新节点*p的数据域</span></span><br><span class="line">		p-&gt;next=L-&gt;next;  <span class="comment">//将新节点*p插入到头结点之后</span></span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：T(n) = O(n)</p>
<p>后插法</p>
<p><img src="https://img-blog.csdnimg.cn/8307dac343344099aaa2a69d69499ed7.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_R</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">//正位序输入n个元素的值，建立带表头节点的单链表L</span></span><br><span class="line">	L=new LNode;  </span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//先建立一个带头节点的空链表</span></span><br><span class="line">	r=L;  <span class="comment">//尾指针r指向头结点</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		p=new LNode;  <span class="comment">//生成新节点</span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;p-&gt;data;  <span class="comment">//输入元素值赋给新节点*p的数据域</span></span><br><span class="line">		p-&gt;next=<span class="literal">NULL</span>;  <span class="comment">//将新节点*p插入到尾结点*r之后</span></span><br><span class="line">		r-&gt;next=p;</span><br><span class="line">		r=p;  <span class="comment">//r指向新的尾结点*p</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：T(n) = O(n)</p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p><strong>循环链表</strong>是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环，由此，从表中任一结点出发均可找到任意其他结点，有单链表的循环链表，还有多重链的循环链表。</p>
<p>循环链表的合并</p>
<p><img src="https://img-blog.csdnimg.cn/fdb45c9fc5784a12a8e5dac8f700e736.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">Connect</span><span class="params">(LinkList Ta,LinkList Tb)</span>&#123; <span class="comment">//假设Ta,Tb都是非空的单循环链表</span></span><br><span class="line">	p=Ta-&gt;next;  <span class="comment">//p存表头节点</span></span><br><span class="line">	Ta-&gt;next=Tb-&gt;next-&gt;next; <span class="comment">//Tb表头连接Ta表尾</span></span><br><span class="line">	delete Tb-&gt;next;  <span class="comment">//释放Tb表头结点</span></span><br><span class="line">	Tb-&gt;next=p;  <span class="comment">//修改指针</span></span><br><span class="line">	<span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表的每个结点里在<strong>增加一个指向其直接前驱的指针域</strong>prior，这样链表中就形成了有两个方向不同的链。</p>
<p>双向链表的存储结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">	ElemType data;   <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span>  <span class="comment">//指向直接前驱</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向直接后继</span></span><br><span class="line">&#125;DuLNode,*DuLinkList</span><br></pre></td></tr></table></figure>
<p>双向链表的操作</p>
<p>插入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert_Dul</span><span class="params">(DulinkList &amp;L,<span class="type">int</span> i,ElemType e)</span>&#123;  <span class="comment">//在带头结点的双向链表L中第i个位置之前插入元素e</span></span><br><span class="line">	<span class="keyword">if</span>(!(p=GetElemP_Dul(L,i))) <span class="comment">//在L中确定第i个元素的位置指针p</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;   <span class="comment">//p为NULL时，第i个元素不存在</span></span><br><span class="line">	s=new DulNode;  <span class="comment">//生成新节点*s</span></span><br><span class="line">	s-&gt;data=e;   <span class="comment">//将节点*s的数据域置为e</span></span><br><span class="line">	s-&gt;prior=p-&gt;prior;  <span class="comment">//将节点*s插入L中，对应上图的①</span></span><br><span class="line">	p-&gt;prior-&gt;next=s;  <span class="comment">//对应上图的②</span></span><br><span class="line">	s-&gt;next=p;   <span class="comment">//对应上图的③</span></span><br><span class="line">	p-&gt;prior=s; <span class="comment">//对应上图的④</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete_Dul</span><span class="params">(DulinkList &amp;L,<span class="type">int</span> i)</span>&#123;  <span class="comment">//删除带头结点的双向链表L中的第i个元素</span></span><br><span class="line">	<span class="keyword">if</span>(!(p=GetElemP_Dul(L,i))) <span class="comment">//在L中确定第i个元素的位置指针p</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;   <span class="comment">//p为NULL时，第i个元素不存在</span></span><br><span class="line">	p-&gt;prior-&gt;next=p-&gt;next;  <span class="comment">//修改删除节点的前驱节点的后继指针</span></span><br><span class="line">	p-&gt;next-&gt;prior=p-&gt;prior;  <span class="comment">//修改被删节点的后继节点的前驱指针</span></span><br><span class="line">	delete p;  <span class="comment">//释放被删节点的空间</span></span><br><span class="line"> 	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><p><img src="https://img-blog.csdnimg.cn/5ebdc7227bc94b64bf424f976cc85e2f.png" alt></p>
<h1 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h1><h2 id="线性表的合并"><a href="#线性表的合并" class="headerlink" title="线性表的合并"></a>线性表的合并</h2><p>算法步骤：</p>
<p>①分别获取La表长m和Lb表长n</p>
<p>②从Lb中第1个数据元素开始，循环n次执行以下操作：</p>
<ul>
<li>从Lb中查找第i（1≤i≤n）个元素数据赋给e</li>
<li>在La中查找元素e，如果不存在，则将e插在表La的最后</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList</span><span class="params">(List &amp;La,List &amp;Lb)</span>&#123;  <span class="comment">//将所有在线性表Lb中但不在La中的数据元素插入La中</span></span><br><span class="line">	m=ListLength(La);  <span class="comment">//求线性表的长度</span></span><br><span class="line">	n=ListLength(Lb);   <span class="comment">//求线性表的长度</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		GetElem(Lb,i,e);  <span class="comment">//取Lb中第i个数据元素赋给e</span></span><br><span class="line">		<span class="keyword">if</span>(!LocateElem(La,e))  <span class="comment">//La不存在和e相同的数据元素</span></span><br><span class="line">			ListInsert(&amp;La,++m,e);  <span class="comment">//将e插在La的最后</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：T(n) = O(m*n)</p>
<h2 id="有序表的合并"><a href="#有序表的合并" class="headerlink" title="有序表的合并"></a>有序表的合并</h2><p><img src="https://img-blog.csdnimg.cn/481af319fd1345dc9a954140640e921a.png" alt></p>
<ul>
<li><p>顺序有序表的合并</p>
<p>算法步骤：<br>①创建一个表长为m+n的空表LC<br>②指针pc初始化，指向LC的第一个元素<br>③指针pa和pb初始化，分别指向LA和LB的第一个元素<br>④当指针pa和pb均未达到相应表尾时，则依次比较pa和pb所指向的元素值，从LA或LB“摘取”元素值较小的节点插入LC的最后<br>⑤如果pb已到达LB的表尾，依次将LA的剩余元素插到LC的最后<br>⑥如果pa已到达LA的表尾，依次将LB的剩余元素插到LC的最后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_Sq</span><span class="params">(SqList LA,SqList LB,SqList &amp;LC)</span>&#123;  </span><br><span class="line">    <span class="comment">//已知顺序有序表LA和LB的元素按值非递减排列</span></span><br><span class="line">    <span class="comment">//归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排序</span></span><br><span class="line">    LC.length=LA.length+LB.length;  <span class="comment">//新表长度为待合并两表的长度之和</span></span><br><span class="line">    LC.elem=new ElemType[LC.length];  <span class="comment">//为合并后的新表分配一个数组空间</span></span><br><span class="line">    pc=LC.elem;   <span class="comment">//指针pc指向新表的第一个元素</span></span><br><span class="line">    pa=LA.elem; </span><br><span class="line">    pb=LB.elem;  <span class="comment">//指针pa和pb的初值分别指向两个表的第一个元素</span></span><br><span class="line">    pa_last=LA.elem+LA.length<span class="number">-1</span>;  <span class="comment">//指针pa_last指向LA的最后一个元素</span></span><br><span class="line">    pb_last=LB.elem+LB.length<span class="number">-1</span>;  <span class="comment">//指针pb_last指向LB的最后一个元素</span></span><br><span class="line">    <span class="keyword">while</span>((pa&lt;=pa_last) &amp;&amp; (pb&lt;=pb_last))&#123;  <span class="comment">//为达到LA和LB的表尾</span></span><br><span class="line">   		<span class="keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++;  <span class="comment">//依次摘取两表中值较小的节点插入LC的最后</span></span><br><span class="line">   		<span class="keyword">else</span> *pc++=*pb++; </span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">while</span>(pa&lt;=pa_last)  *pc++=*pa++;  <span class="comment">//已到达LB表尾，依次将LA的剩余元素插入到LC的最后</span></span><br><span class="line">   	<span class="keyword">while</span>(pb&lt;=pb_last)  *pc++=*pb++;  <span class="comment">//已到达LA表尾，依次将LB的剩余元素插入到LC的最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/27af84bba388465b9ebf0a69eb57865a.png" alt></p>
</li>
<li><p>链式有序表的合并</p>
<p>算法步骤：</p>
<p><img src="https://img-blog.csdnimg.cn/fd6cadab0a2c416eb2c168b60fd2e9ce.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_L</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC)</span>&#123;</span><br><span class="line"><span class="comment">//已知单链表LA和LB的元素按值非递减排列</span></span><br><span class="line"><span class="comment">//归并LA和LB得到新的单链表LC，LC的元素也按值非递减排列</span></span><br><span class="line">	pa=LA-&gt;next;pb=LB-&gt;next;  <span class="comment">//pa和pb的初值分别指向两个表单的第一个结点</span></span><br><span class="line">	LC=LA;  <span class="comment">//用LA的头结点作为LC的头节点</span></span><br><span class="line">	pc=LC;  <span class="comment">//pc的初值指向LC的头节点</span></span><br><span class="line">	<span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">	<span class="comment">//LA和LB均为到达表尾，依次摘取量表中值较小的节点插入到LC的最后</span></span><br><span class="line">		<span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123;  <span class="comment">//摘取pa所指节点</span></span><br><span class="line">			pc-&gt;next=pa; <span class="comment">//将pa所指节点链接到pc所指节点之后</span></span><br><span class="line">			pc=pa;   <span class="comment">//pc指向pa</span></span><br><span class="line">			pa=pa-&gt;next;  <span class="comment">//pa指向下一节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;   <span class="comment">//摘取pb所指节点</span></span><br><span class="line">			pc-&gt;next=pb; <span class="comment">//将pb所指节点链接到pc所指节点之后</span></span><br><span class="line">			pc=pb;   <span class="comment">//pc指向pb</span></span><br><span class="line">			pb=pb&gt;next;  <span class="comment">//pb指向下一节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;     <span class="comment">//while</span></span><br><span class="line">	pc-&gt;next=pa?pa:pb;  <span class="comment">//将非空表的剩余段插入到pc所指节点之后</span></span><br><span class="line">	delete LB;   <span class="comment">//释放LB的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/78f6582a4825459ab882f24768627971.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/post/7b216a3b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树是n(n&gt;=0)个结点的有限集      树的定义是一个递归的定义</p>
<ul>
<li>n=0,为空树</li>
<li>n&gt;0,满足以下两个条件<ol>
<li>有且仅有一个特定称为根的结点</li>
<li>其余结点可分为m个互不相交的有限集，其中每一个集合本身又是一棵树，并称为根的子树</li>
</ol>
</li>
</ul>
<h1 id="树和二叉树的定义"><a href="#树和二叉树的定义" class="headerlink" title="树和二叉树的定义"></a>树和二叉树的定义</h1><h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p>树的表示方式：树，嵌套集合，广义表，凹入表示</p>
<p>根节点：非空树中无前驱结点的结点</p>
<p>结点的度：结点拥有的子树树</p>
<p>树的度：树内各结点的度的最大值</p>
<p>叶子结点，内部结点</p>
<p>双亲，孩子，祖先，子孙</p>
<p>森林：m棵互不相交的树的集合</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线性结构</th>
<th>树结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个数据元素        无前驱</td>
<td>根结点(只有一个)       无双亲</td>
</tr>
<tr>
<td>最后一个数据元素      无后继</td>
<td>叶子结点(可以有多个)       无孩子</td>
</tr>
<tr>
<td>其他数据元素</td>
<td>其他结点—中间结点</td>
</tr>
<tr>
<td>一个前驱，一个后继</td>
<td>一个双亲，多个孩子</td>
</tr>
<tr>
<td>一对一</td>
<td>一对多</td>
</tr>
</tbody>
</table>
</div>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是n(n&gt;0)个结点的有限集，它或者是空集(n=0)，或者由一个根节点及两颗互不相交的的分别称作这棵树的左子树和右子树</p>
<p>特点：</p>
<ol>
<li>每个结点最多有两个孩子（二叉树中不存在度大于2）</li>
<li>子树有左右之分，其次序不能颠倒</li>
<li>二叉树可以是空子集，根可以有空的左子树或空的右子树</li>
</ol>
<p><strong>二叉树不是树的特殊情况，是两个概念，但是有关树的基本术语对二叉树都适用</strong></p>
<h1 id="树和二叉树的抽象数据类型定义"><a href="#树和二叉树的抽象数据类型定义" class="headerlink" title="树和二叉树的抽象数据类型定义"></a>树和二叉树的抽象数据类型定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT BinaryTree&#123;</span><br><span class="line">    数据对象D:D是具有相同特性的数据元素的结合</span><br><span class="line">    数据关系R：若D=</span><br><span class="line">    基本操作P:<span class="comment">//至少有20个</span></span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>
<p>基本操作：</p>
<ul>
<li><p><strong>CreateBiTree(&amp;T, definition)</strong>：</p>
<p>初始条件：definition给出二叉树T的定义</p>
<p>操作结果：按definition构造二叉树T</p>
</li>
<li><p><strong>PreOrderTraverse(T)</strong>：</p>
<p>初始条件：二叉树T存在</p>
<p>操作结果：先序遍历T，对每个结点访问一次</p>
</li>
<li><p><strong>InOrderTraverse(T)</strong>：</p>
<p>初始条件：二叉树T存在</p>
<p>操作结果：中序遍历T，对每个结点访问一次</p>
</li>
<li><p><strong>PostOrderTraverse(T)</strong>：</p>
<p>初始条件：二叉树T存在</p>
<p>操作结果：后序遍历T，对每个结点访问一次</p>
</li>
</ul>
<h1 id="二叉树的的性质和存储结构"><a href="#二叉树的的性质和存储结构" class="headerlink" title="二叉树的的性质和存储结构"></a>二叉树的的性质和存储结构</h1><p>满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树</p>
<p>完全二叉树：完全二叉树是由满二叉树引出的。满二叉树要求每一层的节点数都达到最大值，完全二叉树仅要求除最后一层外的节点数达到最大值，也就是说最后一层可以不满。我们可以把满二叉树看错特殊的完全二叉树。</p>
<p><img src="https://img-blog.csdnimg.cn/d790444f0801485f98eb4397631eb29c.png" alt="img"></p>
<p>性质</p>
<ol>
<li><p>任意二叉树第 i ii 层最大结点数为2 i − 1 。 ( i ≥ 1 )</p>
<p>归纳法证明</p>
</li>
<li><p>深度为 k kk 的二叉树最大结点总数为2 k − 1 。 ( k ≥ 1 )</p>
<p>证明：</p>
</li>
<li><p>对于任意二叉树，用n 0 , n 1 , n 2 n_0,n_1,n_2，分别表示叶子结点，度为1的结点，度为2的结点的个数，则有关系式n 0 = n 2 + 1</p>
</li>
</ol>
<ol>
<li><p>n个结点完全二叉树深度为⌊ l o g 2 n ⌋ + 1</p>
</li>
<li><p><strong>性质5其实描述的是完全二叉树中父子结点间的逻辑对应关系。</strong></p>
</li>
<li><p>假如对一棵完全二叉树的所有顶点按层序遍历的顺序从1开始编号,对于编号后的结点i ii：<br>（1）i = 1 i=1i=1时表示i ii是根结点；<br>（2）i &gt; 1 i&gt;1i&gt;1时：①i ii的根结点为i/2。②若2i&gt;n，结点i 无左孩子，且为叶子结点。③若2i+1&gt;n，结点i 无右孩子，可能为叶子结点。</p>
</li>
</ol>
<p>存的目的是为了取，而取的关键在于如何通过父结点拿到它的左右子结点，不同存储方式围绕的核心也就是这</p>
<h2 id="存储结构："><a href="#存储结构：" class="headerlink" title="存储结构："></a>存储结构：</h2><ul>
<li><p>顺序存储结构</p>
<p>使用一组地址连续的存储单元存储，顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面会专门讲解。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。为了在存储结构中能得到父子结点之间的映射关系，二叉树中的结点必须按层次遍历的顺序存放。具体是：</p>
<ul>
<li><p>对于完全二叉树，只需要自根结点起从上往下、从左往右依次存储。</p>
</li>
<li><p>对于非完全二叉树，首先将它变换为完全二叉树，空缺位置用某个特殊字符代替（比如#），然后仍按完全二叉树的存储方式存储。</p>
<p>假设将一棵二叉树按此方式存储到数组后，左子结点下标=2倍的父结点下标+1，右子节点下标=2倍的父结点下标+2。若数组某个位置处值为#，代表此处对应的结点为空。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/adec0262943d431db9e7519bb5561b94.png" alt="img"></p>
<p><strong>注意：空节点的地方在数组中要空出来，不然无法模拟出树的结构</strong></p>
<ul>
<li><p>链式存储结构</p>
<p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，高阶数据结构如红黑树等会用到三叉链。如图：左边为二叉链，右边为三叉链。</p>
</li>
</ul>
<p>​            <img src="https://img-blog.csdnimg.cn/c9ec6d9571ed4b04847732bcc9d8e1a1.png" alt="img"></p>
<h1 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>定义：顺着某一条搜索路径寻访二叉树的结点，使得每个结点均被访问一次，而且仅被访问一次</p>
<p>目的：得到树中所有结点的一个线性排列</p>
<p>方法：</p>
<ol>
<li><p>先序遍历   DLR</p>
<p><img src="https://img-blog.csdnimg.cn/202012091634524.gif#pic_center" alt></p>
<p>算法思路：</p>
<p>若二叉树为空则，结束返回，否则：</p>
<p>（1）访问根结点。</p>
<p>（2）前序遍历左子树。</p>
<p>（3）前序遍历右子树 。</p>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span> <span class="params">(BinTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T!=<span class="literal">NULL</span>) &#123; <span class="comment">//不为空 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">		PreOrder(T-&gt;left);</span><br><span class="line">		PreOrder(T-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历    LDR</p>
<p><img src="https://img-blog.csdnimg.cn/20201209164211397.gif#pic_center" alt></p>
<p>算法思路：</p>
<p>若二叉树为空，则结束返回，否则：</p>
<p>（1）中序遍历左子树</p>
<p>（2）访问根结点</p>
<p>（3）中序遍历右子树</p>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MidOrder</span> <span class="params">(BinTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T!=<span class="literal">NULL</span>) &#123; <span class="comment">//不为空 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">		MidOrder(T-&gt;left);</span><br><span class="line">		MidOrder(T-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历    LRD</p>
<p><img src="https://img-blog.csdnimg.cn/2020120916532175.gif#pic_center" alt></p>
<p>算法思路：</p>
<p>若二叉树为空则结束返回，否则：</p>
<p>（1）后序遍历左子树</p>
<p>（2）后序遍历右子树</p>
<p>（3）访问根结点</p>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BackOrder</span> <span class="params">(BinTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T!=<span class="literal">NULL</span>) &#123; <span class="comment">//不为空 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">		BackOrder(T-&gt;left);</span><br><span class="line">		BackOrder(T-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>遍历算法的分析：去掉输出语句，从递归的角度看，三种算法是完全相同的，或者说三种算法的访问路径是相同的，只是访问结点的时机不同</p>
<p>时间效率：O(n)  //每个结点只访问一次</p>
<p>空间效率：O(n)  //栈占用的最大辅助空间</p>
<blockquote>
<p>例题：</p>
<ol>
<li><p>写出二叉树的各种遍历顺序</p>
</li>
<li><p>用二叉树表示算术表达式</p>
<p>先序：先缀表示（波兰式）</p>
<p>中序：中缀表示</p>
<p>后序：后缀表示（逆波兰式）</p>
</li>
<li><p>已知先序和中序求二叉树</p>
<p><strong>由先序序列确定根，由中序序列确定左右子树</strong></p>
</li>
<li><p>已知中序和后序求二叉树</p>
<p><strong>后序遍历，根结点必在后序序列尾部</strong></p>
</li>
</ol>
</blockquote>
<p>遍历二叉树的非递归算法：</p>
<ul>
<li><p>中序遍历非递归算法</p>
<p>关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根和右子树</p>
<p>基本思想：</p>
<ol>
<li>建立一个栈</li>
<li>根节点进栈，遍历左子树</li>
<li>根节点出栈，输出根节点，遍历右子树</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历非递归遍历算法</span></span><br><span class="line"><span class="comment">//堆栈实现，遇见一个结点，就压栈，去遍历它的左子树</span></span><br><span class="line"><span class="comment">//左子树遍历完后，从栈顶弹出结点并访问它</span></span><br><span class="line"><span class="comment">//然后遍历右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">(BinTree BT)</span>&#123;</span><br><span class="line">    BinTree T=BT;</span><br><span class="line">    Stack S=CreatStack(MaxSize);<span class="comment">//创建并初始化堆栈</span></span><br><span class="line">    <span class="keyword">while</span>(T||!IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(T)&#123;</span><br><span class="line">            Push(S,T);</span><br><span class="line">            T=T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            T=Pop(S);<span class="comment">//结点弹出堆栈</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,T-&gt;Data);</span><br><span class="line">            T=T-&gt;Right;<span class="comment">//转向右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>层次遍历</p>
<p>对于一颗二叉树，从根节点开始，按从上到下、从左到右的顺序访问每一个结点，<strong>每个结点仅仅访问一次</strong></p>
<p>算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="comment">//队列实现：遍历从根节点入队，然后开始执行循环</span></span><br><span class="line"><span class="comment">//:结点入队，访问该节点，然后左右儿子入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(BinTree BT)</span>&#123;</span><br><span class="line">    Queue Q;BinTree T;</span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span>;<span class="comment">//空树则直接返回</span></span><br><span class="line">    Q=CreatQueue(MaxSize);<span class="comment">//创建并初始化队列Q</span></span><br><span class="line">    AddQ(Q,BT);<span class="comment">//把结点添加到队列</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmptyQ(Q))&#123;</span><br><span class="line">        T=DeleteQ(Q);<span class="comment">//弹出结点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left) AddQ(Q,T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right) AddQ(Q,T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>代码：</p>
<ul>
<li><p>递归遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  <span class="comment">//树结点</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//指向左右子树的指针</span></span><br><span class="line">&#125; BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">CreateLink</span><span class="params">()</span>&#123; <span class="comment">//二叉树的递归创建</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);<span class="comment">//读入当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(data==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入%d的左子树: &quot;</span>,data); <span class="comment">//读入最左结点</span></span><br><span class="line">        T-&gt;lchild=CreateLink();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入%d的右子树: &quot;</span>,data);<span class="comment">//读入右结点</span></span><br><span class="line">        T-&gt;rchild=CreateLink();</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入根节点数据: &quot;</span>);</span><br><span class="line">    T=CreateLink();<span class="comment">// 1 2 -1 4 6 -1 -1 -1 3 -1 5 -1 -1</span></span><br><span class="line">    PreOrder(T);<span class="comment">//1 2 4 6 3 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    InOrder(T);<span class="comment">// 2 6 4 1 3 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    PostOrder(T);<span class="comment">//6 4 2 5 3 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非递归遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  <span class="comment">//树结点</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//指向左右子树的指针</span></span><br><span class="line">&#125; BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    BiTree data[MaxSize]; </span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">    S-&gt;top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack *S,BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==MaxSize<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S-&gt;data[++S-&gt;top]=T;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack *S,BiTree *T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *T=S-&gt;data[S-&gt;top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqStack *S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack *S,BiTree *T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *T=S-&gt;data[S-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">CreateLink</span><span class="params">()</span>&#123; <span class="comment">//二叉树的递归创建</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);<span class="comment">//读入当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(data==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入%d的左子树: &quot;</span>,data); <span class="comment">//读入最左结点</span></span><br><span class="line">        T-&gt;lchild=CreateLink();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入%d的右子树: &quot;</span>,data);<span class="comment">//读入右结点</span></span><br><span class="line">        T-&gt;rchild=CreateLink();</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历(非递归)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    BiTree p=T;</span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(&amp;S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);  <span class="comment">//与中序遍历拜访位置不同</span></span><br><span class="line">            Push(&amp;S,p);  <span class="comment">//左结点入队</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(&amp;S,&amp;p); <span class="comment">//如果为空遍历右结点</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历(非递归)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S); <span class="comment">//初始化栈S</span></span><br><span class="line">    BiTree p=T;<span class="comment">// p用于遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(&amp;S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(&amp;S,p); <span class="comment">//左儿子存在,直接入栈</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(&amp;S,&amp;p); <span class="comment">//左儿子不存在,出栈</span></span><br><span class="line">            visit(p); <span class="comment">//注意visit的位置</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历(非递归)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    BiTree p=T,r=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(&amp;S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(&amp;S,p); <span class="comment">//一直走到树最左端</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//向右&#123;</span></span><br><span class="line">            GetTop(&amp;S,&amp;p); <span class="comment">// 获取栈顶元素,此时不需要出栈</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)&#123;</span><br><span class="line">                p=p-&gt;rchild; <span class="comment">//如果最左侧结点的右子树存在,则继续向右侧遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果不存在则弹出该结点&#123;</span></span><br><span class="line">                Pop(&amp;S,&amp;p);</span><br><span class="line">                visit(p);</span><br><span class="line">                r=p;<span class="comment">//记录最近访问过的结点</span></span><br><span class="line">                p=<span class="literal">NULL</span>; <span class="comment">//访问完后重置p指针,意味着下一次一定执行else</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入根节点数据: &quot;</span>);</span><br><span class="line">    T=CreateLink();<span class="comment">// 1 2 -1 4 6 -1 -1 -1 3 -1 5 -1 -1</span></span><br><span class="line">    PreOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    InOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    PostOrder(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列层次遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>  Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  <span class="comment">//树结点</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//指向左右子树的指针</span></span><br><span class="line">&#125; BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqQueue</span>&#123;</span></span><br><span class="line">    BiTree data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;<span class="comment">//队尾指向下一个要入队的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MaxSize==Q-&gt;front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=T;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,BiTree *T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队空</span></span><br><span class="line">    *T=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">CreateLink</span><span class="params">()</span>&#123; <span class="comment">//二叉树的递归创建</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);<span class="comment">//读入当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(data==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入%d的左子树: &quot;</span>,data); <span class="comment">//读入最左结点</span></span><br><span class="line">        T-&gt;lchild=CreateLink();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入%d的右子树: &quot;</span>,data);<span class="comment">//读入右结点</span></span><br><span class="line">        T-&gt;rchild=CreateLink();</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueuePrint</span><span class="params">(SqQueue *Q)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=Q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span>(i!=Q-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d--&gt;&quot;</span>,Q-&gt;data[i]-&gt;data);</span><br><span class="line">        i=(i+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(&amp;Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(&amp;Q))&#123;</span><br><span class="line">        DeQueue(&amp;Q,&amp;p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(&amp;Q,p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(&amp;Q,p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入根节点数据: &quot;</span>);</span><br><span class="line">    T=CreateLink();<span class="comment">// 1 2 -1 4 6 -1 -1 -1 3 -1 5 -1 -1</span></span><br><span class="line">    LevelOrder(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>二叉树遍历算法的应用</p>
<ul>
<li><p>二叉树的建立</p>
<p>按先序遍历序列建立二叉树的二叉链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历初始化二叉树 </span></span><br><span class="line"><span class="comment">//先序遍历顺序来建立节点。并且利用&amp;引用不断连接左右子节点的方向。</span></span><br><span class="line">BinTree <span class="title function_">Create</span><span class="params">(BinTree T)</span> &#123; <span class="comment">//传入的是拷贝的指针，对这个拷贝的指针进行了一系列处理，如果不想返回，则需用二重指针 </span></span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//传递的是指针，还没有开辟二叉树的存储空间 </span></span><br><span class="line">		T = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));<span class="comment">//开辟空间 </span></span><br><span class="line">		T-&gt;data = ch;<span class="comment">//赋值 </span></span><br><span class="line">		T-&gt;left = Create(T-&gt;left);<span class="comment">//继续递归，将左儿子的空间开辟，赋值 </span></span><br><span class="line">		T-&gt;right = Create(T-&gt;right);<span class="comment">//继续递归，将右儿子的空间开辟，赋值	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制二叉树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果是空树，递归结束</span><br><span class="line">否则，申请新结点空间，复制根节点</span><br><span class="line">    递归复制左子树</span><br><span class="line">    递归复制右子树</span><br><span class="line"><span class="comment">//利用二叉树的先序遍历</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Copy</span><span class="params">(BiTree T,BiTree &amp;NewT)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		NewT = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		NewT = new BiTNode;</span><br><span class="line">		NewT-&gt;data = T-&gt;data;</span><br><span class="line">		Copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">		Copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算二叉树深度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果是空树，则深度为<span class="number">0</span></span><br><span class="line">否则，递归计算左子树深度为m，递归计算右子树深度为n，则二叉树深度则为m和n的较大者加<span class="number">1</span></span><br><span class="line"><span class="comment">//利用后序遍历，即访问顺序是：左右根</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getTreeDepth</span><span class="params">(Tree *p)</span> &#123;</span><br><span class="line">	<span class="comment">//分别标识左右子树的深度</span></span><br><span class="line">	<span class="type">int</span> L, R;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//如果是空树,那就肯定是0了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//求左子树的深度</span></span><br><span class="line">		L = getTreeDepth(p-&gt;left);</span><br><span class="line">		R = getTreeDepth(p-&gt;right);</span><br><span class="line">		<span class="comment">//用最大的那个+1,便是了</span></span><br><span class="line">		<span class="keyword">return</span> (L &gt; R ? L : R) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算二叉树结点总数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果是空树，则结点个数为<span class="number">0</span></span><br><span class="line">否则，结点个数为左子树结点个数+右子树结点个数+<span class="number">1</span></span><br><span class="line"><span class="comment">//利用后序遍历顺序</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算二叉树叶子结点数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果是空树，则叶子结点个数为<span class="number">0</span></span><br><span class="line">否则，为左子树的叶子结点个数+右子树的叶子结点个数</span><br><span class="line"><span class="type">void</span> <span class="title function_">CountLeaf</span><span class="params">(BiTree T,<span class="type">int</span> &amp;count)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T)&#123;</span><br><span class="line">		<span class="keyword">if</span>((!T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))</span><br><span class="line">			count++;</span><br><span class="line">		CountLeaf(T-&gt;lchild,count);</span><br><span class="line">		CountLeaf(T-&gt;rchild,count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树</p>
<p>性质：设x是二叉搜索树中的一个结点。如果y是x左子树中的一个结点，那么y.key≤x.key。如果y是x右子树中的一个结点，那么y.key≥x.key。</p>
<p>在二叉搜索树中：</p>
<p>1.若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</p>
<p>2.若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</p>
<p>3.任意结点的左、右子树也分别为二叉搜索树。</p>
<p>利用二叉链表中的空指针域</p>
<ul>
<li>先序线索二叉树</li>
<li>中序线索二叉树</li>
<li>后序线索二叉树</li>
</ul>
<blockquote>
<p>【题目】<a href="[1589. 构建二叉搜索树 - AcWing题库](https://www.acwing.com/problem/content/description/1591/">1589. 构建线索二叉树(acwing）</a></p>
<p>【思路】：</p>
<ul>
<li>将原数组排序，然后将序列按照中序遍历的顺序（左根右）将所有数填到树里边即可（递归填数）！</li>
<li>bfs输出层序遍历结果</li>
</ul>
<p>【代码实现】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> l[N], r[N], inorder[N];<span class="comment">//左子树，右子树， 权值 </span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现中序遍历：左根右</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span> ;<span class="comment">// 当前节点为空</span></span><br><span class="line">    dfs(l[u]);<span class="comment">// 左！</span></span><br><span class="line">    inorder[u] = a[k ++];<span class="comment">// 根！ a[]数组经过排序了！当前节点的权值为a[k ++]</span></span><br><span class="line">    dfs(r[u]);<span class="comment">// 右！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现中序遍历：左根右</span></span><br><span class="line"><span class="comment">// void dfs(int u)&#123; </span></span><br><span class="line"><span class="comment">//     if(l[u] != -1)// 左子树不为空</span></span><br><span class="line"><span class="comment">//         dfs(l[u]);// 左！      </span></span><br><span class="line"><span class="comment">//     inorder[u] = a[k ++];// 根！ a[]数组经过排序了！当前节点的权值为a[k ++]</span></span><br><span class="line"><span class="comment">//     if(r[u] != -1)// 左子树不为空</span></span><br><span class="line"><span class="comment">//         dfs(r[u]);// 右！</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出二叉搜索树的层序遍历结果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);<span class="comment">// 根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; inorder[t] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(l[t] != <span class="number">-1</span>) q.push(l[t]);<span class="comment">// 存在左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(r[t] != <span class="number">-1</span>) q.push(r[t]);<span class="comment">// 存在右儿子        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);<span class="comment">// 排序    </span></span><br><span class="line">    dfs(<span class="number">0</span>);<span class="comment">// 从第0个位置开始填</span></span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><p>森林：m（m&gt;0）棵互不相交的树的集合</p>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><ol>
<li><p>双亲表示法</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/525739f19952db583c3c661b14f2820a.png" alt></p>
<p>实现：定义结构数组，存放树的结点，每个结点含两个域</p>
<p>数据域：存放结点本身信息</p>
<p>双亲域：指示本结点的双亲结点在数组中的位置</p>
<p>特点：找双亲容易，找孩子难</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    TElemType date;</span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="comment">//树结构：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r, n;<span class="comment">//根结点的位置和结点个数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  <span class="comment">//树中最多的结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">//结点定义</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    PTNode nodes[MaxSize]; <span class="comment">//双亲表示,存放树中所有结点</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的结点初始化</span></span><br><span class="line"><span class="function">PTree <span class="title">InitPNode</span><span class="params">(PTree tree)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入结点个数： &quot;</span>;</span><br><span class="line">    cin&gt;&gt;tree.n;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入结点的值及其双亲位于数组中的位置下标：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;tree.n; i++)&#123;</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);  <span class="comment">//清空输入缓冲区</span></span><br><span class="line">        cin&gt;&gt;ch&gt;&gt;j;</span><br><span class="line">        tree.nodes[i].data = ch;  <span class="comment">//结点数据</span></span><br><span class="line">        tree.nodes[i].parent = j;  <span class="comment">//双亲结点在数组中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找树中指定结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindParent</span><span class="params">(PTree tree)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入要查询的结点值：&quot;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdin);  <span class="comment">//清空输入缓冲区</span></span><br><span class="line">    <span class="type">char</span> a; </span><br><span class="line">    cin&gt;&gt;a; <span class="comment">//输入要查询的结点值</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;tree.n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree.nodes[i].data == a)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123; <span class="comment">//此时为根结点</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;此结点为根结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ad = tree.nodes[i].parent;</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;<span class="string">&quot;的父结点为： &quot;</span>&lt;&lt;tree.nodes[ad].data&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;存储位置为： &quot;</span>&lt;&lt;ad&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;树中无此结点。&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTree tree;</span><br><span class="line">    tree = <span class="built_in">InitPNode</span>(tree);</span><br><span class="line">    <span class="built_in">FindParent</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>孩子链表</p>
<p>把每个结点的孩子结点排列起来，看成一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表），而n个头指针又构成一个线性表，用顺序表（含n个元素的结构数组）存储。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6e057620e9a547fb1a62881be8a63bcc.png" alt></p>
<p>特点：找孩子容易，找双亲难</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//孩子结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="comment">//双亲结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType date;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ChildNode</span>&#123; <span class="comment">//链表中每个结点的定义</span></span><br><span class="line">    <span class="comment">//链表中每个结点存储的不是数据本身，而是数据在数组中存储的位置下标</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ChildNode</span> *next;</span><br><span class="line">&#125;ChildNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">//树中每个结点的定义</span></span><br><span class="line">    <span class="type">char</span> data;  <span class="comment">//结点的数据类型</span></span><br><span class="line">    ChildNode *firstchild;  <span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CHNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    CHNode nodes[MaxSize];  <span class="comment">//存储结点的数组</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树中结点初始化</span></span><br><span class="line"><span class="function">CTree <span class="title">InitTree</span><span class="params">(CTree tree)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入结点总数：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;tree.n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;tree.n; i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个结点的值：&quot;</span>;</span><br><span class="line">        <span class="built_in">fflush</span>(stdin);</span><br><span class="line">        cin&gt;&gt;tree.nodes[i].data;</span><br><span class="line">        <span class="comment">//链表结点</span></span><br><span class="line">        tree.nodes[i].firstchild = (ChildNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ChildNode));</span><br><span class="line">        tree.nodes[i].firstchild-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入结点&quot;</span>&lt;&lt;tree.nodes[i].data&lt;&lt;<span class="string">&quot;的孩子结点数量：&quot;</span>;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        <span class="keyword">if</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            ChildNode *p = tree.nodes[i].firstchild; <span class="comment">//p为操作指针</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;num; j++)&#123;</span><br><span class="line">                ChildNode *q = (ChildNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ChildNode)); <span class="comment">//新建结点</span></span><br><span class="line">                q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个孩子结点在顺序表中的存储位置: &quot;</span>;</span><br><span class="line">                cin&gt;&gt;q-&gt;child;</span><br><span class="line">                p-&gt;next = q;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindKids</span><span class="params">(CTree tree, <span class="type">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;tree.n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree.nodes[i].data == a)&#123;</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;<span class="string">&quot;的所有孩子结点为： &quot;</span>;</span><br><span class="line">			ChildNode *p = tree.nodes[i].firstchild-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//输出所有的孩子结点</span></span><br><span class="line">                cout&lt;&lt;tree.nodes[p-&gt;child].data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此结点为叶子节点&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CTree tree;</span><br><span class="line">    tree = <span class="built_in">InitTree</span>(tree);</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入要查找其孩子结点的结点：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="built_in">FindKids</span>(tree, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带双亲的孩子链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxTree 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//孩子节点</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> chird;<span class="comment">//孩子节点下标</span></span><br><span class="line">	Pchird* next;<span class="comment">//下一个孩子节点指针</span></span><br><span class="line">&#125;*Pchird;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//双亲节点</span></span><br><span class="line">&#123;</span><br><span class="line">	string data;<span class="comment">//节点数据</span></span><br><span class="line">	<span class="type">int</span> parent;<span class="comment">//节点的双亲节点下标</span></span><br><span class="line">	Pchird firstChird;<span class="comment">//表头节点的第一个孩子节点</span></span><br><span class="line">&#125;Pparent;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	Pparent nodes[maxTree];<span class="comment">//节点数组</span></span><br><span class="line">	<span class="type">int</span> r, n;<span class="comment">//r存放根的位置，n代表节点数目</span></span><br><span class="line">&#125;Pnode;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>孩子兄弟表示法(二叉树表示法，二叉链表表示法)</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e34bce72b7b04d3c8ee329f67b956bf.png" alt></p>
<p>实现：用二叉链表作树的存储结构，链表中的每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针    </span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="树和二叉树的转换"><a href="#树和二叉树的转换" class="headerlink" title="树和二叉树的转换"></a>树和二叉树的转换</h2><blockquote>
<p>树转换成二叉树</p>
<p>①加线：在兄弟之间加一连线</p>
<p>②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>
<p>③旋转：以树的结点为轴心，将树顺时针选择45°</p>
<p><strong>树变二叉树：兄弟相连留长子</strong></p>
<p>二叉树转换成树</p>
<p>①加线：若p结点是双亲结点的左孩子，则将p的右孩子，孩子的孩子·····沿分支找到的所有的右孩子，都与p的双亲用线连起来</p>
<p>②抹线：抹掉原二叉树中双亲与右孩子的连线</p>
<p>③旋转：将结点按层次排列，形成树结构</p>
<p><strong>二叉树变树：左孩右右连双亲，去掉原来右孩线</strong></p>
</blockquote>
<h2 id="森林和二叉树的转换"><a href="#森林和二叉树的转换" class="headerlink" title="森林和二叉树的转换"></a>森林和二叉树的转换</h2><blockquote>
<p>森林转换成二叉树</p>
<p>①将各棵树分别转换成二叉树</p>
<p>②将每棵树的根节点用线相连</p>
<p>③以第一棵树根节点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树型结构</p>
<p><strong>森林变二叉树：树变二叉根相连</strong></p>
<p>二叉树转换成森林</p>
<p>①抹线：将二叉树中根节点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉看，使之变成孤立的二叉树</p>
<p>②还原：将孤立的二叉树还原成树</p>
<p><strong>二叉树变森林：去掉全部右孩线，孤立二叉再还原</strong></p>
</blockquote>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ol>
<li><p>先根（次序）遍历</p>
<p>若树不为空，则先访问根节点，然后依次先根遍历各棵子树</p>
</li>
<li><p>后根（次序）遍历</p>
<p>若树不为空，则先依次后根遍历各棵子树，然后访问根节点</p>
</li>
<li><p>层次遍历：</p>
<p>若树不为空则自上而下自左而右访问树中每个结点</p>
</li>
</ol>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><p>将森林看作由三部分构成：1.森林中第一棵树的根节点；2.森林中第一棵树的子树森林；3.森林中其他树构成的森林</p>
<ol>
<li><p>先序遍历</p>
<p>若森林不空，则：1.访问森林中第一棵树的根节点；2.先序遍历森林中第一棵树的子树森林；3.先序遍历森林中（除第一棵树之外）其余树构成的森林</p>
<p>即：依次从左至右对森林中的每一棵树进行先根遍历</p>
</li>
<li><p>中序遍历</p>
<p>若森林不空，则：1.中序遍历森林中第一棵树的子树森林；2.访问森林中第一棵树的根节点；3.中序遍历森林中（除第一棵树之外）其余树构成的森林</p>
<p>即：依次从左到右对森林中的每一棵树进行后根遍历</p>
</li>
</ol>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径</p>
<p>结点间的路径长度：两结点间路径上的分支长度</p>
<p>树的路径长度：从树根到每一个结点的路径长度之合，记作TL</p>
<p><strong>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树</strong></p>
<p>权(weight)：将树中结点赋给一个有着某种含义的值，则这个数值称为该结点的权</p>
<p>结点的带权路径长度：从根节点到该结点之间的路径长度与该结点的权的乘积</p>
<p>树的带权路径长度：树中所有叶子结点的带权路径长度之和记作 W=</p>
<p>哈夫曼树：最优树  带权路径长度(WPL)最短的树</p>
<p>哈夫曼树：最优二叉树  带权路径长度(WPL)最短的二叉树</p>
<h3 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h3><p>哈夫曼树中权越大的叶子离根越近</p>
<p>哈夫曼算法：1.构造森林全是根；2.选用两小造新树；3.删除两小添新人；4.重复2.3剩单根</p>
<p>包含n棵树的森林需要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点</p>
<p>包含n个叶子结点的哈夫曼树共有2n-1个结点</p>
<p>哈夫曼树的结点的度为0或2，没有度为1的结点</p>
<blockquote>
<p>总结：</p>
<ol>
<li>在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树</li>
<li>经过n-1次合并形成n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点</li>
</ol>
<p>可见：哈夫曼树中有2n-1个结点，且所有分支结点的度均不为1</p>
</blockquote>
<h3 id="哈夫曼树构造算法的实现"><a href="#哈夫曼树构造算法的实现" class="headerlink" title="哈夫曼树构造算法的实现"></a>哈夫曼树构造算法的实现</h3><ul>
<li><p>采用顺序存储结构——一维结构数组</p>
<p>结点类型定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哈夫曼树的类型定义*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> N 30						<span class="comment">//叶子结点的最大值</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> M 2 * N - 1				<span class="comment">//所有结点的最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> weight;						<span class="comment">//结点的权值</span></span><br><span class="line">	<span class="type">int</span> parent;						<span class="comment">//双亲的下标</span></span><br><span class="line">	<span class="type">int</span> LChild;						<span class="comment">//左孩子结点的下标</span></span><br><span class="line">	<span class="type">int</span> RChild;						<span class="comment">//右孩子结点的下标</span></span><br><span class="line">&#125;HTNode, HuffmanTree[M + <span class="number">1</span>];		<span class="comment">//HuffmanTree是一个结构数组类型，0号单元不用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在ht[1]至ht[n]的范围内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree ht, <span class="type">int</span> n, <span class="type">int</span>* s1, <span class="type">int</span>* s2)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, min1 = MAX, min2 = MAX;</span><br><span class="line">	*s1 = <span class="number">0</span>;</span><br><span class="line">	*s2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ht[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ht[i].weight &lt; min1) &#123;</span><br><span class="line">				min2 = min1;</span><br><span class="line">				*s2 = *s1;</span><br><span class="line">				min1 = ht[i].weight;</span><br><span class="line">				*s1 = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ht[i].weight &lt; min2) &#123;</span><br><span class="line">				min2 = ht[i].weight;</span><br><span class="line">				*s2 = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建哈夫曼树算法*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CrtHuffmanTree</span><span class="params">(HuffmanTree ht, <span class="type">int</span> w[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">//构造哈夫曼树ht[M+1],w[]存放n个权值</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;		<span class="comment">//1至n号单元存放叶子结点，初始化</span></span><br><span class="line">		ht[i].weight = w[i - <span class="number">1</span>];</span><br><span class="line">		ht[i].parent = <span class="number">0</span>;</span><br><span class="line">		ht[i].LChild = <span class="number">0</span>;</span><br><span class="line">		ht[i].RChild = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;				<span class="comment">//所有结点总数</span></span><br><span class="line">	<span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;	<span class="comment">//n+1至m号单元存放非叶结点，初始化</span></span><br><span class="line">		ht[i].weight = <span class="number">0</span>;</span><br><span class="line">		ht[i].parent = <span class="number">0</span>;</span><br><span class="line">		ht[i].LChild = <span class="number">0</span>;</span><br><span class="line">		ht[i].RChild = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化完毕，开始创建非叶结点*/</span></span><br><span class="line">	<span class="type">int</span> s1, s2;</span><br><span class="line">	<span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;	<span class="comment">//创建非叶结点，建哈夫曼树</span></span><br><span class="line">		Select(ht, i - <span class="number">1</span>, &amp;s1, &amp;s2);<span class="comment">//在ht[1]至ht[i-1]的范围内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2</span></span><br><span class="line">		ht[i].weight = ht[s1].weight + ht[s2].weight;</span><br><span class="line">		ht[s1].parent = i;</span><br><span class="line">		ht[s2].parent = i;</span><br><span class="line">		ht[i].LChild = s1;</span><br><span class="line">		ht[i].RChild = s2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>对一棵具有n个叶子结点的哈夫曼树，若对树中的每个左分支赋0，右分支赋1（或左1右0），则从根到每个叶子的通路上，各个分支的赋值分别构成一个二进制串，该二进制串就称为<strong>哈夫曼编码</strong>。哈夫曼编码是<strong>最优前缀编码</strong>，能使各种报文对应的二进制串的平均长度最短。</p>
<blockquote>
<ol>
<li><p>为什么哈夫曼编码能够保证是前缀编码</p>
<p>因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的的前缀</p>
</li>
<li><p>为什么哈夫曼编码能够保证字符编码总长最短</p>
<p>因为哈夫曼树的带权路径长度最短，故字符编码总长最短</p>
</li>
</ol>
</blockquote>
<p>性质：</p>
<ol>
<li>哈夫曼编码是前缀码</li>
<li>哈夫曼编码是最优前缀码</li>
</ol>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哈夫曼编码*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CrtHuffmanCode</span><span class="params">(HuffmanTree ht, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">//从叶子结点到根，逆向求每个叶子结点(共n个)对应的哈夫曼编码</span></span><br><span class="line">	<span class="type">char</span>* cd;</span><br><span class="line">	cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">char</span>));	<span class="comment">//分配当前编码的工作空间</span></span><br><span class="line">	cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;						<span class="comment">//从右向左逐位存放编码，首先存放编码结束符</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;			<span class="comment">//求n个叶子结点对应的哈夫曼编码</span></span><br><span class="line">		<span class="type">int</span> start = n - <span class="number">1</span>, c = i, p = ht[i].parent;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">			--start;</span><br><span class="line">			<span class="keyword">if</span> (ht[p].LChild == c)			<span class="comment">//左分支标0</span></span><br><span class="line">				cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cd[start] = <span class="string">&#x27;1&#x27;</span>;			<span class="comment">//右分支标1</span></span><br><span class="line">			c = p;							<span class="comment">//向上倒堆</span></span><br><span class="line">			p = ht[p].parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cd[j] == <span class="string">&#x27;0&#x27;</span> || cd[j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, cd[j]);		<span class="comment">//编码输出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(cd, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件的编码和解码：</p>
<ul>
<li><p>编码</p>
<p>①输入各字符及权值</p>
<p>②构造哈夫曼树——HT[i]</p>
<p>③进行哈夫曼编码——HC[i]</p>
<p>④查HC[i]，得到各字符的哈夫曼编码</p>
</li>
<li><p>解码</p>
<p>①构造哈夫曼树</p>
<p>②依次读入二进制码</p>
<p>③读入0，则走向左孩子；读入1，则走向右孩子</p>
<p>④一旦到达某叶子时，则可译出字符</p>
<p>⑤然后从根出发继续译码，指导结束</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">	<span class="type">int</span> parent, Lchild, Rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(Element hufftree[], <span class="type">int</span> &amp;i1, <span class="type">int</span> &amp;i2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> min1 = <span class="number">10000</span>, min2 = <span class="number">10000</span>, i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (hufftree[i].weight != <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (min1 &gt; hufftree[i].weight&amp;&amp; hufftree[i].parent == <span class="number">-1</span>)&#123;</span><br><span class="line">			min1 = hufftree[i].weight;</span><br><span class="line">			i1 = i;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (hufftree[i].weight != <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (min2 &gt; hufftree[i].weight&amp;&amp; hufftree[i].parent == <span class="number">-1</span> &amp;&amp; i != i1)&#123;</span><br><span class="line">			min2 = hufftree[i].weight;</span><br><span class="line">			i2 = i;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HuffManTree</span><span class="params">(Element hufftree[], <span class="type">int</span> n,<span class="type">int</span> w[])</span></span>&#123;<span class="comment">//哈夫曼树的创建函数</span></span><br><span class="line">	<span class="type">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		hufftree[i].weight = w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">Select</span>(hufftree, i1, i2);</span><br><span class="line">		hufftree[i].weight = hufftree[i1].weight + hufftree[i2].weight;</span><br><span class="line">		hufftree[i].Lchild = i1; hufftree[i].Rchild = i2;</span><br><span class="line">		hufftree[i1].parent = i; hufftree[i2].parent = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findelementNum</span><span class="params">(<span class="type">char</span> code[], <span class="type">char</span> p[],<span class="type">int</span> w[])</span></span>&#123;<span class="comment">//找出字符串中的不同字符，并计算其权重</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(code) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">1</span>;<span class="comment">//记录code中不同的字符个数</span></span><br><span class="line">	p[<span class="number">0</span>] = code[<span class="number">0</span>];</span><br><span class="line">	w[<span class="number">0</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(code); i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (code[i] == p[j])&#123;<span class="comment">//code[i]已经出现过，则其权值加1，并退出内循环</span></span><br><span class="line">				w[j]++; </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j == num - <span class="number">1</span>)&#123;<span class="comment">//code[i]未出现过，则录入p中，其权值变为1</span></span><br><span class="line">				p[num] = code[i];</span><br><span class="line">				w[num]++;</span><br><span class="line">				num++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makecode</span><span class="params">(<span class="type">int</span> q[][<span class="number">10</span>],<span class="type">int</span> road[], Element huffTree[],<span class="type">int</span> n)</span></span>&#123;<span class="comment">//编码函数</span></span><br><span class="line">	<span class="type">int</span> bianma[<span class="number">10</span>] ;<span class="comment">//储存字符的编码</span></span><br><span class="line">	<span class="type">int</span> parent = <span class="number">0</span>, current = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(bianma,<span class="number">0</span>,<span class="built_in">sizeof</span>(bianma));</span><br><span class="line">	<span class="type">int</span> x= <span class="number">0</span>;<span class="comment">//bianma字符串数组的指针</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		current= i;  <span class="comment">//current保存当前节点下标</span></span><br><span class="line">		parent = huffTree[current].parent;</span><br><span class="line">		<span class="keyword">while</span> (parent!=<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (huffTree[parent].Lchild == current)&#123;<span class="comment">//当前节点为其双亲的左孩子，编码为0</span></span><br><span class="line">				bianma[x] = <span class="number">0</span>;</span><br><span class="line">				road[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (huffTree[parent].Rchild == current)&#123;<span class="comment">//当前节点为其双亲的右孩子，编码为1</span></span><br><span class="line">				bianma[x] = <span class="number">1</span>;</span><br><span class="line">				road[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">			x++;</span><br><span class="line">			current = parent;</span><br><span class="line">			parent = huffTree[parent].parent;<span class="comment">//向上寻找双亲节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; x; y++)&#123;</span><br><span class="line">			q[i][y] = bianma[x - y <span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		x = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;编码成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">int</span> code2[],Element Hufftree[],<span class="type">char</span> p[],<span class="type">int</span> n)</span></span>&#123;<span class="comment">//解码函数</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">2</span> * n - <span class="number">2</span>, x = <span class="number">0</span>, count = <span class="number">0</span>;<span class="comment">//j为根节点下标</span></span><br><span class="line">	<span class="keyword">while</span> (code2[i] == <span class="number">1</span>||code2[i]==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (code2[i] == <span class="number">1</span>)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			x = Hufftree[j].Rchild;</span><br><span class="line">			j = x;<span class="comment">//更新根节点</span></span><br><span class="line">			<span class="keyword">if</span> (Hufftree[x].Rchild == <span class="number">-1</span>)&#123;<span class="comment">//当前节点没有右孩子，说明他为叶子节点(原因是哈夫曼树的特点是只存在度为0和度为2的节点)，即找到对应解码</span></span><br><span class="line">				cout &lt;&lt; p[x];</span><br><span class="line">				j = <span class="number">2</span> * n - <span class="number">2</span>;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (code2[i + <span class="number">1</span>] == <span class="number">-1</span> &amp;&amp; Hufftree[x].Rchild != <span class="number">-1</span>)&#123;<span class="comment">//给出的二进制编码已经结束但是却未能找到对应解码，说明这段编码有误</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;(第&quot;</span> &lt;&lt; i - count+<span class="number">1</span> &lt;&lt; <span class="string">&quot;到第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;号编码有误)&quot;</span>;</span><br><span class="line">				j = <span class="number">2</span> * n - <span class="number">2</span>;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (code2[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			x = Hufftree[j].Lchild;</span><br><span class="line">			j = x;</span><br><span class="line">			<span class="keyword">if</span> (Hufftree[x].Rchild == <span class="number">-1</span>)&#123;</span><br><span class="line">				cout &lt;&lt; p[x];</span><br><span class="line">				j = <span class="number">2</span> * n - <span class="number">2</span>;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (code2[i + <span class="number">1</span>] == <span class="number">-1</span> &amp;&amp; Hufftree[x].Rchild != <span class="number">-1</span>)&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;(第&quot;</span> &lt;&lt; i - count+<span class="number">1</span> &lt;&lt; <span class="string">&quot;到第&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;号编码有误)&quot;</span>;</span><br><span class="line">				j = <span class="number">2</span> * n - <span class="number">2</span>;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> q[][<span class="number">10</span>],<span class="type">char</span> p[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		cout &lt;&lt;p[i] &lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (q[i][j] != <span class="number">-1</span>)&#123;</span><br><span class="line">			cout &lt;&lt; q[i][j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Element huffTree[SIZE];</span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//叶子节点的个数</span></span><br><span class="line">	<span class="type">int</span> w[SIZE] ;<span class="comment">//储存叶子节点的权重</span></span><br><span class="line">	<span class="type">int</span> road[SIZE];<span class="comment">//储存叶子节点到根节点的路径长度</span></span><br><span class="line">	<span class="type">int</span> q[SIZE][<span class="number">10</span>] ;<span class="comment">//储存不同字符的编码</span></span><br><span class="line">	<span class="type">char</span> code[<span class="number">50</span>];<span class="comment">//待编码的字符串</span></span><br><span class="line">	<span class="type">char</span> p[<span class="number">27</span>] = &#123; <span class="number">-1</span> &#125;;<span class="comment">//储存字符串中不同的字符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(huffTree, <span class="number">-1</span>, <span class="built_in">sizeof</span>(huffTree));</span><br><span class="line">	<span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">	<span class="built_in">memset</span>(road, <span class="number">0</span>, <span class="built_in">sizeof</span>(road));</span><br><span class="line">	<span class="built_in">memset</span>(q, <span class="number">-1</span>, <span class="built_in">sizeof</span>(q));</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入待编码的字符串:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; code;</span><br><span class="line">	n = <span class="built_in">findelementNum</span>(code, p, w);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;叶子节点个数为：&quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;各叶子节点的权重为:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		cout &lt;&lt;p[i]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt; w[i] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">HuffManTree</span>(huffTree, n, w);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; i;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; huffTree[i].parent;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; huffTree[i].Lchild;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; huffTree[i].Rchild;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; huffTree[i].weight&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">makecode</span>(q,road, huffTree, n);</span><br><span class="line">	<span class="built_in">print</span>(q,p, n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;各叶子节点的路径为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt; road[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> code2[SIZE],t,I=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(code2, <span class="number">-1</span>, <span class="built_in">sizeof</span>(code2));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入待解码编码（以-1截止）:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t != <span class="number">-1</span>)&#123;</span><br><span class="line">		code2[I] = t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		I++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">decode</span>(code2, huffTree, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯真题</title>
    <url>/post/7420a9e6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十一届"><a href="#第十一届" class="headerlink" title="第十一届"></a>第十一届</h1><h1 id="第十二届"><a href="#第十二届" class="headerlink" title="第十二届"></a>第十二届</h1><h1 id="第十三届"><a href="#第十三届" class="headerlink" title="第十三届"></a>第十三届</h1><h1 id="第十四届"><a href="#第十四届" class="headerlink" title="第十四届"></a>第十四届</h1>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/post/90f1d201.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>打表：当数据范围较小或者数据有规律时，可以通过搜素求出所有的答案，然后放到一个数组中，直接输出</strong></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>C++代码中的操作次数控制在 10^7∼10^8 为最佳。<br>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>
<ol>
<li>n≤30 , 指数级别, dfs+剪枝，状态压缩dp</li>
<li>n≤100 =&gt; O(n^3)，floyd，dp，高斯消元</li>
<li>n≤1000 =&gt; O(n^2)，O(n2logn)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li>
<li>n≤10000 =&gt; O(n∗n√)，块状链表、分块、莫队</li>
<li>n≤100000 =&gt; O(nlogn)=&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li>
<li>n≤1000000 =&gt; O(n), 以及常数较小的 O(nlogn)算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)的做法：sort、树状数组、heap、dijkstra、spfa</li>
<li>n≤10000000 =&gt; O(n)，双指针扫描、kmp、AC自动机、线性筛素数</li>
<li>n≤109 =&gt; O(n√)，判断质数</li>
<li>n≤1018 =&gt; O(logn)，最大公约数，快速幂，数位DP</li>
<li>n≤101000 =&gt; O((logn)2)，高精度加减乘除</li>
<li>n≤10100000 =&gt; O(logk×loglogk)，k表示位数 ，高精度加减、FFT/NTT</li>
</ol>
<h1 id="递归和递推"><a href="#递归和递推" class="headerlink" title="递归和递推"></a>递归和递推</h1><h1 id="二分与前缀和"><a href="#二分与前缀和" class="headerlink" title="二分与前缀和"></a>二分与前缀和</h1><h1 id="数学与简单DP"><a href="#数学与简单DP" class="headerlink" title="数学与简单DP"></a>数学与简单DP</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="买不到的数目"><a href="#买不到的数目" class="headerlink" title="买不到的数目"></a><a href="https://www.acwing.com/problem/content/1207/">买不到的数目</a></h3><p>小明开了一家糖果店。 他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。<br>小朋友来买糖的时候，他就用这两种包装来组合。<br>当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。<br>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。<br>大于17的任何数字都可以用4和7组合出来。<br>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p>
<p>输入格式<br>两个正整数 n,m ，表示每种包装中糖的颗数。</p>
<p>输出格式<br>一个正整数，表示最大不能买到的糖数。</p>
<p>数据范围<br>2≤n,m≤1000 ，<br>保证数据一定有解。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 7</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure></p>
<p>思路：<br>引理：给定a，b ，若d=gcd(a,b)&gt;1 ,则一定不能凑出最大数<br>结论： 如果 a,b 均是正整数且互质，那么由 ax+by,x≥0,y≥0 ，不能凑出的最大数是 (a−1)(b−1)−1<br><a href="https://www.cnblogs.com/Yuzao/p/7074465.html">证明</a><br>1.直接使用结论<br>2.暴力打表找规律<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个m，是否能用p和q凑出来</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m &gt;= p &amp;&amp; <span class="built_in">dfs</span>(m - p,p,q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= q &amp;&amp; <span class="built_in">dfs</span>(m - q,p,q)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p,q;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,p,q)) res = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    cout &lt;&lt; (n<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="蚂蚁感冒"><a href="#蚂蚁感冒" class="headerlink" title="蚂蚁感冒"></a><a href="https://www.acwing.com/problem/content/1213/">蚂蚁感冒</a></h3><p>题目：<br>长 100 厘米的细长直杆子上有 n 只蚂蚁。<br>它们的头有的朝左，有的朝右。<br>每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。<br>当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。<br>这些蚂蚁中，有 1 只蚂蚁感冒了。 并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。<br>请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</p>
<p>输入格式<br>第一行输入一个整数 n , 表示蚂蚁的总数。<br>接着的一行是 n 个用空格分开的整数 Xi , Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。<br>正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。<br>其中，第一个数据代表的蚂蚁感冒了。</p>
<p>输出格式<br>输出1个整数，表示最后感冒蚂蚁的数目。</p>
<p>数据范围<br>1&lt;n&lt;50 ,<br>0&lt;|Xi|&lt;100</p>
<p>输入样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5 -2 8</span><br></pre></td></tr></table></figure><br>输出样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><br>输入样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">-10 8 -20 12 25</span><br></pre></td></tr></table></figure><br>输出样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br>思路：<br><img src="蚂蚁.png" alt><br>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;<span class="comment">//左边向右走，右边向左走</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i])&lt;<span class="built_in">abs</span>(a[<span class="number">0</span>]) &amp;&amp; a[i]&gt;<span class="number">0</span>) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i])&gt;<span class="built_in">abs</span>(a[<span class="number">0</span>]) &amp;&amp; a[i]&lt;<span class="number">0</span>) right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>]&gt;<span class="number">0</span> &amp;&amp; right==<span class="number">0</span> || a[<span class="number">0</span>]&lt;<span class="number">0</span> &amp;&amp; left==<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; left+right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="饮料换购"><a href="#饮料换购" class="headerlink" title="饮料换购"></a><a href="https://www.acwing.com/problem/content/1218/">饮料换购</a></h3><p>乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。<br>请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。</p>
<p>输入格式<br>输入一个整数 n ,表示初始买入的饮料数量。</p>
<p>输出格式<br>输出一个整数，表示一共能够喝到的饮料数量。</p>
<p>数据范围<br>0&lt;n&lt;10000</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">149</span><br></pre></td></tr></table></figure></p>
<p>思路：<br>1.<strong>模拟：</strong><br>2.<strong>数学公式：</strong><br>当有3个空瓶时，可以兑换1瓶饮料，这时已经喝的饮料+1, 剩余空瓶为1<br>当有4个空瓶时，可以兑换1瓶饮料，这时已经喝的饮料+1, 剩余空瓶为2<br>当有5个空瓶时，可以兑换2瓶饮料，这是已经喝的饮料+2, 剩余空瓶为1<br>总空瓶里面，用1个瓶子来装兑换后的酒，每次兑换消耗2个空瓶。<br>每次兑换消耗3个空瓶，兑换1瓶饮料，又补充了1个空瓶，所以理解为每次兑换消耗2个空瓶、 （这个前提是空瓶的剩余数量 &gt;= 3，也就是说如果空瓶数量为2时，不满足兑换条件。)<br>=&gt; 总共n个空瓶, 拿出1个空瓶, 剩下的 n-1 个空瓶用来兑换, 每次兑换消耗2个空瓶。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：模拟</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        res += n/<span class="number">3</span>;</span><br><span class="line">        n = n/<span class="number">3</span>+n%<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：数学公式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; n + (n - <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="简单DP"><a href="#简单DP" class="headerlink" title="简单DP"></a>简单DP</h2><p><strong>从集合角度分析</strong><br>动态规划</p>
<ul>
<li>状态表现<ul>
<li>集合      <em>化零为整</em></li>
<li>属性</li>
</ul>
</li>
<li>状态计算 —— 集合的划分（划分依据：<strong>找最后一个不同点</strong>）</li>
</ul>
<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><a href="https://www.acwing.com/problem/content/2/">01背包问题</a></h3><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。<br>第 i 件物品的体积是 vi ，价值是 wi 。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p>
<p>输入格式<br>第一行两个整数，N，V ，用空格隔开，分别表示物品数量和背包容积。<br>接下来有 N 行，每行两个整数 vi,wi ，用空格隔开，分别表示第 i 件物品的体积和价值。</p>
<p>输出格式<br>输出一个整数，表示最大价值。</p>
<p>数据范围<br>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><br>思路：<br><strong>组合模型</strong></p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> v1, v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;v1, &amp;v2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v1; j -- )&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v1]+v2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a><a href="https://www.acwing.com/problem/content/1017/">摘花生</a></h3><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。<br>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。<br>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。<br>Hello Kitty只能向东或向南走，不能向西或向北走。<br>问Hello Kitty最多能够摘到多少颗花生。<br><img src="https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif" alt></p>
<p>输入格式<br>第一行是一个整数T，代表一共有多少组数据。<br>接下来是T组数据。<br>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。<br>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p>
<p>输出格式<br>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p>
<p>数据范围<br>1≤T≤100 ,<br>1≤R,C≤100 ,<br>0≤M≤1000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">2 3 4</span><br><span class="line">1 6 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">16</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<ol>
<li>状态表示<br>集合：定义f[i][j]为从(1, 1)到达(i, j)的所有方案<br>属性：最大值</li>
<li>状态转移<br>(i, j)从(i-1, j)即上方过来<br>(i, j)从(i, j-1)即左方过来</li>
<li>空间压缩<br>f[i][j]只需要用到这一层和上一层的f元素，所以可以压缩成滚动数组。在此之上，还可以直接压缩成一维数组。</li>
</ol>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法一：</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法二：</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法三：</span></span><br></pre></td></tr></table></figure></p>
<h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href>最长上升子序列</a></h3><p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="地宫取宝"><a href="#地宫取宝" class="headerlink" title="地宫取宝"></a><a href>地宫取宝</a></h3><p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="波动数列"><a href="#波动数列" class="headerlink" title="波动数列"></a><a href>波动数列</a></h3><p>思路：</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="枚举，模拟与排序"><a href="#枚举，模拟与排序" class="headerlink" title="枚举，模拟与排序"></a>枚举，模拟与排序</h1><h1 id="树状数组与线段树"><a href="#树状数组与线段树" class="headerlink" title="树状数组与线段树"></a>树状数组与线段树</h1><h1 id="双指针，BFS与图论"><a href="#双指针，BFS与图论" class="headerlink" title="双指针，BFS与图论"></a>双指针，BFS与图论</h1><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>常用证明方法：微扰，范围缩放，决策包容性，反证法，数学归纳法<br>通常会用到排序或堆等数据结构维护某些性质</p>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h1 id="复杂DP"><a href="#复杂DP" class="headerlink" title="复杂DP"></a>复杂DP</h1>]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全</title>
    <url>/post/2812c128.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><h2 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>域名：由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<p><img src="https://i0.hdslb.com/bfs/article/2b4ba04293ead7b15fdc0f8eeedc44e063b928a8.png@867w_428h_progressive.webp" alt></p>
<p>域名注册与查询：</p>
<p>Godaddy，Gandi，Hover，Namesilo，Namecheap，万网</p>
<p>二级域名和多级域名：</p>
<p>国际顶级域名下二级域名， 二级域名一般是指域名注册人选择使用的网上名称，如“yahoo.com”；上网的商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如“microsoft.com”</p>
<p>国家顶级域名下二级域名，在国家顶级域名之下二级域名一般是指类似于国际顶级域名的表示注册人类别和功能的标志。例如，在“．com.cn”域名结构中，“.com”此时是置于国家顶级域名“.cn”下的二级域名，表示商业性组织</p>
<p>域名对安全测试的意义：</p>
<ol>
<li><p>相同的二级域名的网站架构、源码、密码可能相似</p>
</li>
<li><p>两个网站的域名解析的ip地址可能相同</p>
</li>
</ol>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统（Domain Name System，DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。是Internet上解决网上机器命名的一种系统。 Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP/IP中的IP地址是由四段以“.”分开的数字组成(此处以IPv4的地址为例，IPv6的地址同理)，记起来总是不如名字那么方便，所以，就采用了域名系统来管理名字和IP的对应关系。</p>
<p>本地hosts与DNS的关系：</p>
<p>Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。<br>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>浏览器访问网站，要首先通过DNS服务器把要访问的网站域名解析成一个唯一的IP地址，之后，浏览器才能对此网站进行定位并且访问其数据。</p>
<blockquote>
<p>如何查看hosts</p>
<ol>
<li>Win + R：打开运行输入drivers</li>
<li>输入：c:\windows\system32\drivers\etc</li>
<li>选择使用记事本或者Notepad、Vs Code 等编程软件打开</li>
</ol>
</blockquote>
<p>CDN：</p>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<p>通过超级ping的网站可以看到CDN的解析情况</p>
<p>常见的DNS安全攻击</p>
<ul>
<li><p>DDOS</p>
<p>DDoS攻击也叫做分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器。其他服务器的回复会被发送到被伪造服务器的真实地址，造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃</p>
</li>
<li><p>DNS缓存中毒</p>
<p>DNS缓存中毒攻击者给DNS服务器注入非法网络域名地址，如果服务器接受这个非法地址，那说明其缓存就被攻击了，而且以后响应的域名请求将会受黑客所控。当这些非法地址进入服务器缓存，用户的浏览器或者邮件服务器就会自动跳转到DNS指定的地址。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址</p>
</li>
<li><p>域名劫持（DNS重定向）</p>
<p>域名劫持是通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据</p>
</li>
<li><p>DNS查询嗅探</p>
<p>攻击者主要利用对DNS的配置信息获取网络环境的信息，为之后的攻击做好的准备</p>
<p>针对这些情况，我们需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割</p>
</li>
<li><p>ARP欺骗</p>
<p>ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。ARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障</p>
<p>ARP欺骗通常是在用户局网中，造成用户访问域名的错误指向。如果IDC机房也被ARP病毒入侵后，则也可能出现攻击者采用ARP包压制正常主机、或者压制DNS服务器，以使访问导向错误指向的情况</p>
</li>
<li><p>本机劫持</p>
<p>本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。</p>
</li>
</ul>
<h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><p>一种介乎于 HTML 和诸如 JAVA 、 Visual Basic 、 C++ 等编程语言之间的一种特殊的语言。尽管它更接近后者，但它却不具有编程语言复杂、严谨的语法和规则。</p>
<p>常见的脚本语言有：Python、JavaScript、Asp (逐渐淘汰，基本都是小站点在使用)、Aspx、Php （目前比较流行）javaweb、 pl、cgi等</p>
<p>不同脚本类型与安全漏洞的关系：</p>
<p>不同的脚本语言的编写规则不一样，程序产生的漏洞自然也不一样（代码审计）。</p>
<p>漏洞挖掘代码审计与脚本类型的关系：</p>
<p>漏洞挖掘代码审计：要熟悉相关代码和相关逻辑机制</p>
<h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>在信息安全领域，后门是指绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。</p>
<p>后门的分类：</p>
<ol>
<li>网页后门 ：此类后门程序一般都是服务器上正常 的web服务来构造自己的连接方式，比如现在非常流行的ASP、cgi脚本后门等。</li>
<li>线程插入后门：利用系统自身的某个服务或者线程，将后门程序插入到其中，具体原理原来《黑客防线》曾具体讲解过，感兴趣的朋友可以查阅。这也是现在最流行的一个后门技术。</li>
<li>扩展后门：所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有很强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用————但是，功能越强，个人觉得反而脱郭后门“隐蔽”的初衷，具体看法就看各位使用都的喜好了。</li>
<li>C/S后门（客户端服务器后门）：和传统的木马程序类似的控制方法，采用“客记端/服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。</li>
</ol>
<p>后门在安全测试中的意义：</p>
<ul>
<li>方便下次更方便的进来。</li>
<li>获取到相关权限之后，后门相当于一个管道，便于操作。</li>
<li>即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。</li>
<li>大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。</li>
</ul>
<p>玩法（创建后门之后我们可以怎么样操作？）<br>网站后门：便于控制网站<br>软件后门：用于控制<br>服务器后门：可以进行脱库、盗取信息</p>
<p>免杀技术全称为反杀毒技术Anti Anti-Virus简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。<br>由于免杀技术的涉猎面非常广，其中包含反汇编、逆向工程、系统漏洞等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。<br>其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。</p>
<p>后门需要掌握的核心技能，防止杀毒软件检查到</p>
<h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>web组成框架模型：网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库</p>
<p><img src="web组成框架.png" alt></p>
<p>架构漏洞安全测试的简要测试：</p>
<ul>
<li><p>通信层</p>
<p>主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一般关注开源协议已存在漏洞即可，无需重点关注。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。</p>
</li>
<li><p>应用层</p>
<p>应用层包含开发人员开发代码，为整个安全测试的核心模块。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。</p>
</li>
<li><p>系统层</p>
<p>主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。</p>
</li>
<li><p>管理层</p>
<p>主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。</p>
</li>
</ul>
<h3 id="web相关漏洞"><a href="#web相关漏洞" class="headerlink" title="web相关漏洞"></a>web相关漏洞</h3><p><img src="web漏洞.png" alt></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/post/34811d5f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Acwing算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理</title>
    <url>/post/852cfab6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>为了使程序可以并发执行，操作系统引入了进程的概念。进程是具有一定独立功能的程序在一个数据集合上的一次动态执行过程，它是操作系统进行资源分配和调度的一个独立单位。进程是操作系统的基本运行单位，是<code>CPU</code>资源分配的基本单位。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
